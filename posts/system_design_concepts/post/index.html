<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>System Design Fundamentals Mega-Blog | Minh T. Nguyen</title>
<meta name="keywords" content="long-read">
<meta name="description" content="Notes on fundamentals system design concepts, collected from Sahn Lam&#39;s lecture series.">
<meta name="author" content="Minh T. Nguyen">
<link rel="canonical" href="https://mnguyen0226.github.io/posts/system_design_concepts/post/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mnguyen0226.github.io/favicon/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://mnguyen0226.github.io/favicon/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mnguyen0226.github.io/favicon/android-chrome-192x192.png">
<link rel="apple-touch-icon" href="https://mnguyen0226.github.io/favicon/android-chrome-192x192.png">
<link rel="mask-icon" href="https://mnguyen0226.github.io/favicon/android-chrome-192x192.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="System Design Fundamentals Mega-Blog" />
<meta property="og:description" content="Notes on fundamentals system design concepts, collected from Sahn Lam&#39;s lecture series." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mnguyen0226.github.io/posts/system_design_concepts/post/" /><meta property="og:image" content="https://mnguyen0226.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-01-20T00:00:00+00:00" />
<meta property="og:see_also" content="https://mnguyen0226.github.io/posts/profile_matching/post/" /><meta property="og:see_also" content="https://mnguyen0226.github.io/posts/web_dev_odin/post/" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://mnguyen0226.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="System Design Fundamentals Mega-Blog"/>
<meta name="twitter:description" content="Notes on fundamentals system design concepts, collected from Sahn Lam&#39;s lecture series."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://mnguyen0226.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "System Design Fundamentals Mega-Blog",
      "item": "https://mnguyen0226.github.io/posts/system_design_concepts/post/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "System Design Fundamentals Mega-Blog",
  "name": "System Design Fundamentals Mega-Blog",
  "description": "Notes on fundamentals system design concepts, collected from Sahn Lam's lecture series.",
  "keywords": [
    "long-read"
  ],
  "articleBody": "[v.1.0] (01/20/2023): Post started!\nComputer Memory \u0026 Storage Storage HDD (hard disk drive): it works by spinning magnetics disk. SSD (solid state drive): it uses NAND-based flash memory, providing fast data access, reduces power consumption, and increases durability. It is more expensive. USB Drive: is a small plug-and-play device for convenient data transfer between computers. SD Card is commonly found in camera and smartphone. There is SD Card, Mini Card, and Micro Card. Memory RAM (random access memory): is a type of memory that store data temperarily while the computer is running. It’s fast and flexible. However, all the data is lost after the power is off. SRAM (static random access memory): is a fast and expensive DRAM used in high speed application like CPU caches, where quick access time is crucial. DRAM (dynamic random access memory): is slower and cheaper than SRAM. It needs to be constantly refreshed to maintain data. SDRAM DDR SDRAM: with examples like DDR4, DDR5. GGDDR SDRAM: is a specialized of DRAM with faster data transfer rates for parallel processing. ROM (read only memory): is a type of memory that retains data, even when the memory is off. It is used to store essential information like firmware and BIOS. Firmware: is a type of software stored in ROM that determines how hardware devices communicate with each others BIOS (basic input-output systems): first run when you booth up the computer. It is responsible for starting your computer, initializes hardware components, and hands over controls to the OS. Domain Name System (DNS) It is the backbone of the internet.\nBut how does it work?\nDNS is a directory: it translates human-readable domain names (i.e, www.google.com) to machine-readable IP-addresses.\nThere are different DNS servers with different purposes. The DNS Resolver can be provided by Cloudflare (1.1.1.1) or Google (8.8.8.8).\nHow does the DNS Resolver find the authoritative nameservers?\nThere are 3 levels of DNS:\nRoot Nameservers: stores the IP-addresses of the TLD nameservers. There are 13 logical Root Nameservers. Ex: .com, .org, .edu Top Level Domain (TLD) Nameservers: stores the IP-addresses of the Authoritative Nameservers. Ex: google.com, wikipedia.org, mit.edu. Authoritative Nameservers: stores authoritative answers to queries Such design above make DNS decentralized and robust.\nHow does the workflow look like?\nFig. 1: DNS workflow (Image source: ByteByteGo.com). The user types “google.com” to browser. The browser first checks its cache, if there is no answer, it makes the OS call to get the answer. The OS then reachs out to DNS Resolver. The DNS Resolver first checks its cache, if it is not there or if the answer is expired, it will ask the Root Nameservers. The Rootname Servers responses with the root name TLD Nameservers. Here, if the RootName Servers found the root name TLD Nameservers (i.e. .com as it is common) in its cache, it will return. The DNS Resolver then reachout to the TLD Nameservers, which return the Authoritative Nameservers for “google.com”. The DNS Resolver then reachout to the Authoritative Nameservers and get the IP-address of “google.com”. The DNS Resolver then returns the address of the IP system to the OS, and the OS returns it to the browswer. Common Latency Numbers Fig. 2: Latency number hierachy (Image source: ByteByteGo.com). 1 ns: Accessing CPU registers, CPU clock cycle. 1-10 ns: L1/L2 cache, Branch mispredict. 10-100 ns: L3 cache. 100-1000 ns: System call, MD5 hash. 1-10 µs: Context switches between threads. 10-100 µs: Higher level operations such as process a http request, sequential read, read a 8K page. 100-1000 µs: SSD write latency, intra-zone networking round trip, memcache/redis get operation. 1-10 ms: Intra-zone network latency, seek time of HDD. 10-100 ms: Network round-trip from US West-East. 100-1000 ms: Bcrypt a password, TLS handshake, reading sequentially 1GB of SSD. 1 s: Tranfer 1GB over the network within the same cloud region. REST API Representational State Transfer Application Programming Interface (REST API) is the most popular communication standard between computers over Internet. API is a way for two computers to talk to each other. The common API used by mobile and web applications to talk to the servers is called REST. For instance, Twilio, Stripe, Google Maps use REST API.\nREST is not a specification, it is a loose set of rules for building web API since the early 2000s. Those rules are:\nUniform Interface. Client-Server. Stateless. Cacheable. Layered System. Code on Demand (Optional). Basics of REST API The REST API organizes resources into a set of unique Uniform Resource Identifiers (URIs). The URIs differentiate types of resources on a server.\nhttps://example.com/api/v3/products https://example.com/api/v3/users A client connects to resources by making a request to the endpoint for the resource over HTTP. The request has a specific format such as POST/products HTTP/1.1.\nHere are the operations (CRUD)\nPOST: CREATE a new resource. GET: READ the data about an existing resource. PUT: UPDATE an existing resource. DELETE: DELETE an existing resource. In the body of these request, there could be an optional HTTP request body that contains a custom payload of data, usually encoded in JSON.\nPOST/produccts HTTP/1.1 Accept: application/json JSON: { \"customer\": \"Minh Nguyen\", \"quantity\": 1, \"price\": 19.00 } The server receives a request, processes it and form the result into response.\nHTTP/1.1 200 OK Some HTTP status codes:\n200: Request is successful. 400: Something is wrong with our request, such as wrong syntax. 500: Something is wrong at the server level, such as the server is not available. Stateless A REST implementation should be stateless. This means that the two parties don’t need to store any information about each other, and every request and response (cycle) is independent from all others. This attribute leads to the web application that is easy to scale and well behaved.\nPagination If the return endpoint returns a huge amount of data, we should use pagination. A common scheme uses limit and offset as parameters. If they are not specified, the server should assume sensible default values.\n/products?limit=25\u0026offset=50 Versioning Versioning allows an implementation to provide backward compatibility, so that if we introduce breaking changes from one version to another, consumers can get enough time to move to the next version.\nThere are many ways to versioning an API. The most common way is to prefix the version before the resource on the URI.\n/v1/products /v2/products RESTful API is sensible if used correctly as it is simple and good enough, and that’s why it is so widely used. Other options are GraphQL and gRPC.\n10 Key Data Structures in System Design The choice of correct data structures based on the specification and constraints of the projects is important. To refresh the fundamentals of these data structures, please visit https://neetcode.io/.\nLinked List Linked list (or list) is a versatile and essential data structure in software development. It is great for storing and manipulating ordered data. They are useful in various applications such as task-management, social media feeds, and shopping carts.\nFor task-management application, a list can be used to store and organize tasks for each user. Tasks can be added, removed, or reordered easily, and users can mark them as complete or incomplete.\nIn social media application, e.g. Twitter (X), where they can store and display a users’ feeds in real-time, ensuring the order is correct in real-time.\nArray Array provdes a fixed-size, ordered collection of elements. They are suitable for situation where the size of the collections is known or isn’t changed frequently. Arrays are commonly used in mathematical operations, storing large datasets, or when there is a need for random access to elements.\nFor instance, in the weather application, an array can store temperature readings for a specific location over a defined period. This allows for easy calculations like average temperature or trends analysis.\nArrays are also used in image-processing, where each pixel’s color data can be represented in a 2D array. It enables efficient manipulation and transformation of the image.\nStack Stacks follow the LIFO principle, and they are perfect for supporting undo/redo operations in text editors or maintaining browsing history in web browsers.\nIn the text editors, a stack can be used to store each change made to the text, making it simple to revert to a previous state when the user triggers an undo operation.\nQueue Queues operate on the FIFO principle, and they are good for managing printer jobs, sending actions in games, or handling messages in chat applications. Specifically, in chat applications, a queue can be used to store incoming messages in the order they are received. It ensures that they are displayed to the recipient in the correct sequence.\nHeap Heaps are used for task scheduling and memory management. They are helpful in implementing priority queues where we need to access the highest or lowest priority item efficiently.\nTree Trees organize data hierarchically. They are useful for representing data with natural hierarchies or relationships. Trees are used in database indexing, file systems, or AI decision tree.\nFor database indexing, tree helps speed up search, insert, or delete operations. For example, B-trees and B+ trees are commonly used in relational databases to efficiently manage and index large amount of data.\nHash Table Hash table (or hashmap) allows for efficent data lookup, insertion, and deletion. They use a hash function to map keys to their corresponding storage locations. It enables constant-time access to the stored values. Hash tables are widely used in various applications, such as search engines, caching systems, and programming language interpreters or compilers.\nIn search engine, hash table allows to store and quickly retrieve indexed data based on keywords. This provides fast and relevant search results.\nCaching systems may use hash tables to store and manage cached data. It allows for eapid access to frequently requested resources and improves overall system performance.\nSuffix Tree Suffix trees (or tries) are specialized for searching strings in documents. This makes them perfect for text editors and search algorithms. In a search engine, a suffix tree can be used to efficiently locate all occurrences of a search term within a larger corpus of text.\nGraph Graphs are all about tracking relationships or finding paths. This makes them invaluable in social networks, recommendation engines, and pathfinding algorithms.\nIn a social network, a graph can be used to represent a connections between users. It enables features like friend suggestion or analyzing network trends.\nR-tree R-trees are good at finding nearest neighbors. They are crucial for mapping apps and geolocation services. In a mapping applications, R-trees can be used to store spatial data, such as points of interest. This enables efficient queries to find the nearest locations based on the user’s current position.\nCache Friendliness Relations to Data Structures CPU cache is a small, fast memory between the main memory (RAM) and the CPU. It stores recently accessed data and instructions, so the CPU can access them quickly without fetching them from the slower main memory.\nDifferent data structures have different levels of cache friendliness based on how their elements are stored in memory. Contiguous memory storage (arrays) allows for better cache locality and fewer cache misses, resulting in improved performance. When an array element is accessed, the cache can be prefetch and store nearby elements, anticipating that they might be accessed soon. While data structures with non-contiguous memory storage (linked-list) can experience more cache misses and reduce performance. In a linked list, elements are stored in nodes scattered throughout the memory and each node contains a pointer to the next node in the sequence. This makes it difficult for the CPU to predict and load the next node before it’s needed.\nOther data structures have varying degrees of cache friendliness based on their implementation and use case. This disparity in access times can lead to performance issues in modern computing, particularly in situations where cache misses occur frequently.\nCache Systems Caching is a common technique in modern computing to system performance and reduce response time. From the front-end to back-end, caching plays a crucial role in improving the efficiency of various applications and systems.\nA typical system architecture involves several layers of caching. At each layer, there are multiple strategies and mechanisms for caching data, depending on the requirements and constraints of the specific application.\nComputer Caching Mechanism The most common hardware cache are L1, L2, and L3 caches.\nL1 cache (KBs) is the smallest and fastest cache, typically integrated into the CPU itself. It stores frequently accessed data and instructions, allowing the CPU to quickly access them without having to fetch them from slower memory. L2 cache (MBs) is larger but slower than L1. It is typically located on the CPU die or on a separate chip. L3 cache is larger but slower than L2. It is typically shared between multiple CPU cores. Another common hardware cache is the translation lookaside buffer (TLB). It stores recently used virtual-to-physical address translations. It is used by the CPU to quickly translate virtual memory addresses to physical memory addresses, reducing the time needed to access data from memory\nAt the OS level, there are page cache and other file system caches. Page cache is managed by the OS and resides in the main memory. It is used to store recently used disk blocks in memory. When a program requests data from the disk, the OS can quickly retrieve the data from memory instead of reading it from disk. There are other caches managed by the OS, such as inode cache. These caches are used to speed up file system operations by reducing the number of disk accesses required to access files and directories.\nCache in System Architecture Fig. 3: Cache in System Architecture (Image source: ByteByteGo.com). Front-end: web browsers can cache HTTP response to enable faster retrieval of data. When we request data over HTTP for the first time and it returned with an expiration policy in the HTTP header; we request thee same data again, and the broweser returns the data from its cache if available.\nCDNs: are used to improve the delivery of static contents (images, videos, web assets). When a user requests a content from a CDN, the CDN network looks for the requested content in its cache. If the content is not already in the cache, the CDN fetches it from the origin server and caches it on its edge servers. When another user requests the same content, the CDN can deliever the content directly from its cache, eliminating the need to fetch it from the origin server again.\nLoad-balancers: implement cache resources to reduce the load on back-end servers. When a user requests content from a server behind a load balancer, the load balancer can cache the response and server it directly to future users who request the same content. This can improve response times and reduce the load on back-end servers.\nMesseging infrastructure, message brokers such as Kafka can cache a massive amount of messages on disk. This allows consumers to retrieve the message at their own pace. The messages can be cached for a long period of time based onthe retention policy.\nDistributed caches such as Redis can store key-value pairs in memory, providing high read/write performance compared to traditional databases.\nFull-text search engines like Elastic Search can index data for document search and log search, providing quick and efficient access to specific data.\nRelational database: has multiple levels of caching:\nData is typicaly written to WAL (write-ahead-log), before indexed in a B-tree. Buggerpool is a memory area used to cache query results. Materialized-view can precompute query results for faster performance. Transaction-log records all transactions and updates to the database. Replication-log tracks the replication state in the database cluster. Redis’s Versitality Redis is an in-memory data structure store. It is most commonly used as a cache. It support many data structure such as strings, hashes, lists, sets, and sorted sets. Redis is known for its speed.\nCache The number one use case for Redis is caching objects to speed up web applications. Here, Redis stores frequently requested data in memory. They allows the web servers to return frequently accessed data quickly. This reduces the load on the database and improves the response time for the application.\nAt scale, the cache is distributed among a cluster of Redis servers. Sharding is a common technique to distribute the cache load evenly across the cluster.\nSession Redis can be used as a session storage to share session data among stateless servers. When a user logs into a web application, a session data is stored in Redis along with a unique session ID that is returned to the client as cookie. When the user makes a request to the application, the session ID is included in the request and the stateless web server retrieves the session data from Redis using the ID.\nRedis is an in-memory database. The session data stored in Redis will be lost if the Redis server restarts. Even through Redis provides persistence options like snapshots or AOF (Append-Only File) that allow session data to be saved to disk and reloaded into memory in the event of a restart, these options often take too long to load on restart to be practical.\nIn production, replication is usually used instead such as back-up instance. If there is a crash, the back-up instance will be promoted to take over the traffic.\nDistributed Lock Distributed locks are used when multiple nodes in an application need to coordinate access to some shared resource. Redis is used as a distributed lock with is atomic commands like SETNX (set if not exist). The command allows a caller to set a key only if it does not already exist.\nFor instance, client_1 tries to acquire the lock by setting a key with a unique value and a timeout using the SETNX command, SETNX lock \"1234abcd\" EX 3. If the key was not already set, the SETNX command returns 1, indicating that the lock has been acquired by client_1. client_1 finishes its work and releases the lock by deleting the key. If the key was already set, the SETNX command returns 0, indicating that the lock is already held by another client. In this case, client_1 waits and retries the SETNX until the lock is released by other client.\nRate Limiter Redis can be used as a rate limiter by using its increment command on some counters and setting expiration times on those counters.\nBasic rate-limiting: For each incoming request, the request IP or user ID is used as a key. The number of requests for the key is incremented using the INCR command in Redis. The current count is compared to the allowed rate limit. If the count is within the rate limit, the request is processed. If the count is over the rate limit, the request is rejected. The keys are set to expire after a specific time-window (minutes) to reset the counts for the next time window.\nThere is also a Leaky Bucket Algorithm implemented using Redis.\nRank/Leaderboard For most games that are not super high scale, Redis is a way to implement various types of gaming leaderboards. Sorted Sets (or sorted container or sorted hashmap) are the fundamental data structure that enables this. Here, we can retrieve the data in O(logN).\nContinuous Integration / Continuous Delivery (CI/CD) CI/CD is a software development process including:\nContinuous Integration Code commit (multiple developers). Build. Unit and integration tests. Create application or service image. Continuous Delivery Functional testing. User acceptance testing. Configuration automation. Load testing. Deployment. It eliminates much of the manual human intervention traditionally require to get new code to production. CI/CD promises software teams to deploy better quality software and faster.\nFig. 4: CI/CD Toolkits (Image source: ByteByteGo.com). Continuous Integration: Build, Test, Release CI is the practice of using automation to enable teams to merge code changes into the shared repository early and often. Each commit triggers an automated workflow on a CI server that runs a series of tasks to make sure the commit is safe to merge into the main branch.\nA good CI process relies on a set of good tests. It is non-trivial to maintain a set of tests with sufficient coverage that is not flakey.\nHigh test coverage usually takes longer to run. This impacts developer’s productivity.\nContinuous Deployment: Deploy, Operate, Monitor Real CD is hard as the practice is not as common as CI. Many teams only practice CD on the most basic types of systems. These systems are usually stateless such as API or web server tiers.\nA very few teams has the resource to implement real continuous, hands-off deployment on complex stateful systems like database, backend clusters, or other types of stateful systems like websocket cluster.\nInstead, these systems are usually on a fixed deploy cadence. The deployment process is manual, risky, and time consuming. They require the care of dedicated platform team. It is rare to see these systems deployed fully, continuously, and automatically.\nKubernetes (K8s) Kubernetes is an open-source container orchestration platform. It automates the deployment, scaling, and management of containerized applications.\nKubernestes is a set of machines called nodes, that are used to run containerized applications. There are two core pieces in a Kubernestes cluster:\nControl plane: responsible for managing the state of the cluster. In production environment, the control plane runs on multiple nodes that span across several data center zones. Fig. 5: Control Plane (Image source: ByteByteGo.com). Set of worker nodes: run the containerized application workloads. The containerized applications run in a Pod. Pods are the smallest deployable units in Kubernetes. Pods hosts one or more containers and provides shared sotrage and networking for those containers. Pods are created and managed by the Kubernetes control plane. They are the basic building blocks of Kubernetes applications Fig. 6: Worker Nodes and Pods (Image source: ByteByteGo.com). Control Plane Control plane consists of a number of core components such as API server, controller manager, scheduler, etcd. The API server is the primary interface between the control plane and the rest of the cluster. It is used by the API server and other components of the control and retrieve information about the cluster. It exposes a RESTful API that allows clients to interact with the control plane and submit requests to manage the cluster.\nFig. 7: Control Plane Connections (Image source: ByteByteGo.com). Etcd Etcd is a distributed key-value store. It stores the cluster’s persistent state.\nFig. 8: Etcd (Image source: ByteByteGo.com). Scheduler The scheduler is responsible for scheduling pods onto the worker nodes in the cluster. It uses the information about the resource required by the pods and available resources on the worker nodes to make the placement decisions\nFig. 9: Scheduler (Image source: ByteByteGo.com). Controller Manager Controller manager is responsible for running controllers that manage the state of the cluster. For instance\nThe replication controller ensures that the desired number of replicas of a pod are running. apiVersion: v1 kind: ReplicationController metadata: name: nginx spec: replicas: 4 The deployment controller, which manages the rolling update and rollback of deployments. Worker Nodes The core compoenents of Kubernetes that run on the worker nodes include Kubelet, Container Runtime, and Kube-proxy.\nKubelet: is a daemon that runs on each worker node. It is responsible for communicating with the control plane. It receives instructions from the control plane about which pods to run on the node and ensures that the desired state of the pods is maintained. Container Runtime runs the containers on the worker nodes. It is responsible for pilling the container images from a registry, starting and stopping the containers, and managing the containers’ resources. Kube-proxy: is a network proxy that runs on each worker node. It is responsible for routing traffic to the correct pods. It also provides load balancing for the pods and ensures that the traffic is distributed evenly across the pods Use Cases It’s about trade-off.\nPros:\nKubernetes is scalable and highly available. It provides features like self-healing, automatic rollbacks, and horizontal scaling. It makes it easy to scale out applications up and down as needed, allowing us to respond to changes in demannd quickly. Kubernetes is portable. It helps us deploy and manage applications in a consistent and reliable way regardless of the underlying infrastructure. It runs on-premise, in a public cloud, or in a hybrid environment. it provides a uniform way to package, deploy, and manage applications. Cons:\nKubernetes is complex to set up and operate! The upfront cost is high, especially for organizations new to container orchestration. It requires a high level of expertise and resources to set up and manage a production Kubernetes environment. Kubernetes is costly. It requires a certain minimum level of resources to run in order to support all the features. Thus, it is an overkill for smaller organizations. Services: Amazon EKS, Google Cloud GKE, or Azure AKS.\nCAP Theorem Consistency-Availability-Partition Tolerance (CAP) Theorem explains the trade-off between consistency, availability, and partition tolerance in distributed systems. The CAP theorem helps us think in a high-level trade-off to consider when there is network partition.\nFig. 10: CAP Theorem Illustration (Image source: ByteByteGo.com). Consistency refers to the property of a system where all nodes have a consistent view of the data. It means all clients see the same data at the same time no matter which node they connect to.\nAvailability refers to the ability of a system to respond to requests from users at all time.\nPartition Tolerance refers to the ability of a system to continue operating even if there is a network partition.\nNetwork Partition A network partition happens when nodes in a distributed system are unable to communicate with each other due to network failures. When this happen, a system must choose between consistency and availability.\nIf the system prioritizes consistency, it may becomes unavailable until the partition is resolved. If the system prioritizes availability, it may allow updates to the data. This could result in data inconsistencies until the partition is resolved. Banking System Example For instance, let’s say we have a tiny bank with 2 ATMs connected over a network. The ATMs support 3 operations: deposit, withdraw, and check balance. No matter what happens, the lance should never go below zero. There is no central database to keep the account balance, it is stored on both ATMs. When a customer uses an ATM, the balance is updated on both ATMs over the network. This ensures that the ATMs have a consistent view of the account balance.\nIf there is a network partiotion and the ATM are unable to communicate with each other, the system must choose between consistency and availability.\nIf the bank prioritizes consistency, the ATM may refuse to process deposit or withdrawals until the partition is resolved. This ensures that the balance remains consistent, but the system is unavailable to customers. Fig. 11: Bank Consistency (Image source: ByteByteGo.com). If the bank prioritizes availability, the bank may allow deposit or withdrawals to occur but the balance may be inconsistent until the partition is resolved. When there is a network partition, the customer could withdraw the entire balance from both ATMs. When the network is back online, the inconsistency is resolve and the balance is negative, which is not good Fig. 12: Bank Availability (Image source: ByteByteGo.com). 7 Layers of OSI Model The Open System Interconnect (OSI) model is a theoretical framework that provides one way of thinking about networking. It splits the network communication between two devices on a network into seven abstraction layers.\nFig. 13: Seven Layers of OSI Model (Image source: ByteByteGo.com). Physical Layer The physical layer is responsible for transmitting raw bits of data across a physical connection.\nFig. 14: Physical Layer (Image source: ByteByteGo.com). Data Link Layer The data link layer takes the raw bits from the physical layer and organizes them into frames. It ensures that the frames are delivered to the correct destination. The Ethernet primarily lives in this layer.\nFig. 15: Data Link Layer (Image source: ByteByteGo.com). Network Layer The network layer is responsible for routing data frames across different networks. The IP part of TCP/IP is a well-known example of this layer.\nFig. 16: Network Layer (Image source: ByteByteGo.com). Transport Layer The transport layer handles end-to-end communication between 2 nodes. This is the layer where the TCP and UDP protocols live.\nFig. 17: Transport Layer (Image source: ByteByteGo.com). TCP provides reliable, end-to-end communication between devices. It does this by dividing the data into small, manageable segments and sending each segment individually. Each segment has asequence number attached to it. The receiving end uses the sequence numbers to reassemble the data in the correct order.\nFig. 18: TCP in Transport Layer (Image source: ByteByteGo.com). TCP also provide error checking to make sure that the data was not corrupted during transmission.\nUDP is a protocal that is similar to TCP but is simpler and faster. Unlike TCP, UDP does not provide the same level of error-checking and reliability. It simply send packets of data from one device to another. The receiving end is responsible for determining whether the packets were received correctly. If an error is detected, the receiving end simply discards the packet.\nSession, Presentation, Application Layers The analysis of these layers in OSI model is not useful in practice as the OSI is too fine-grained and does not reflect reality. Let’s consider them as application protocols like HTTP.\nNetworking Workflow Fig. 19: OSI Workflow (Image source: ByteByteGo.com). Let’s see how the data is move through the layer:\nWhen a user sends an HTTP request to a webserver over the network, the HTTP header is added to the data at the application layer. A TCP header is added to the data. It encapsulated into TCP segments at the transport layer. The header contains the source port, destination port, and sequence number. The segments are then encapsulated with an IP header at the network layer. The IP header contains the source and destination IP addresses. A MAC header is added at the data link layer, with the source and destination MAC addresses. Here, the MAC addresses are the ones of routing devices, not the computer itself in reality. The encapsulated frames are sent over the network in raw bits in the physical layer. 6-10. When the webserver receives the raw bits from the network, it reverses the process. The headers are removed layer-by-layer, and eventually, the webserver processes the HTTP request. CDN Content delivery network (CDN) should be used whenever HTTP traffic is served. Fundamentally, a CDN brings content closer to the user. This improves the performance of a web service as perceived by the user. It is noted that performance is critical to user engagement and retentionn as a 0.1-second improvement of mobile site speed increases conversion rates by 8.4% for retails sites and 10.1% for travel sites.\nTo bring the server closer to the users, CDN deploys servers at hundreds of locations all over the world. These server locations are called Point of Presence (PoP). A server inside the PoP is called edge server. Having many PoPs all over the world ensures that every user can reach a fast-edge server close to them.\nRoutings Different CDNs, e.g. Amazon Cloudfront or Cloudflare, use different technologies to direct a user’s request to the closest PoP. Two common ones are DNS-based routing and Anycast.\nWith DNS-based routing, each PoP has its own IP address. When the user looks up the IP address for the CDN, DNS returns the IP address of the PoP closest to them. With Anycast, all PoPs share the same IP address. When the request comes into the Anycast netowrk for that IP address, the network sends the request to the PoP that is closest to the requester. Edge Server \u0026 Static Contents Each edge server acts as a reverse proxy with a huge content cache. Static contents are cached on the edge server in this content cache. If a piece of content is in the cache, it could quickly returned to the user. Since the edge server only ask for a copy of the static content from the origin server if it is not in the cache. This greatly reduces the load and bandwidth requirements of the origin server cluster.\nFig. 20: Edge Server and Static Contents (Image source: ByteByteGo.com). A modern CDN can also transform static content into more optimized formats.\nFig. 21: Static Contents Optimization (Image source: ByteByteGo.com). Performance The edge server also serve an important role in the modern HTTP stack: All TLS connections terminate ath the edge server. TLS handshakes are expensive. The commonly used TLS versions like TLS 1.2 take several network round trips to establish. However, terminating the TLS connection at the edge will significantly reduce the latency for the user to establish an encrypted TCP connection. This is why modern sites send dynamic uncacheable HTTP content over the CDN (single-page website).\nSecurity All modern CDNs have huge network capacity at the edge. This is the key to provide effective DDoS protection against large-scale attacks by having the network with a capacity much larger than the attackers.\nFig. 22: CDNs vs. DDoS (Image source: ByteByteGo.com). Availability The modern CDN improves availability as by nature, a CDN is higly distributed. By having copies of contents available in many PoPs, a CDN can withstand many more hardware failures than the origin servers.\ngRPC gRPC is an open-source remote procedure call framework created by Google in 2016. It’s a rewritten software of Google’s internal Remote Procedure Call (RPC).\nRPC is a function call within a process to execute some code. A remote procedure call enables one machine to invoke some code on another machine as if it is a local function call from a user’s perspective.\ngRPC is a popular implementation of RPC. Many organizations have adopted gRPC as the preferred RPC mechanism to connect a large number of microservices running within and across data centers.\nWhy gRPC so popular? gRPC has a large ecosystem for all languages. It’s very easy to produce production ready and type-safe APIs that scale well. The core of this ecosystem is the use of Protocol Buffers as its data interchange format. Protocol Buffers is a language-agnostic nad platform-agnostic mechanism for encoding structured data. gRPC uses Protocol Buffers to encode and send data over the wire by default. While gRPC could support other encoding formats like JSON, Protocol Buffers provide several advantages that make it the encoding format of choice for gRPC. Protocol Buffers support strongly-typed schema definitions. The structure of the ata over the wire is defined in a proto file. Protocol Buffers provide broad tooling support to turn the schema defined in the proto file into data access classes for all popular programming languages. A gRPC service is also defined in a proto file by specifying RPC method parameters and return types. The same tooling is used to generate gRPC client and server code from the proto file. Developers use these generated classes in the client to make RPC calls and in the server to fulfill the RPC requests. By supporting many programming languages, the client and server can independently choose the programming language and ecosystem best suited for their own particular use cases. This is not common for most other RPC frameworks. gRPC is also known for its high-performance out of the box with 2 factors. First, Protocol Buffers is a very efficient binary encoding format. This is much faster than JSON. Second, gRPC is built on top of HTTP/2 to provide a high-performance foundation at scale. The use of HTTP/2 brings many benefits (multiplexing, stream prioritization, binary protocol, server push). gRPC uses HTTP/2 streams which allows multiple streams of messages over a single long-lived TCP connection. This allows the gRPC framework to handle many concurrent RPC calls over a small number of TCP connections between clients and servers. Workflow Fig. 23: gRPC Workflow Example (Image source: ByteByteGo.com). Let’s walk through a flow from a gRPC client to a gRPC server.\nWhen the Order Service make a gRPC call the the Payment Service, it invokes the client code generated by gRPC tooling at build time. This generated client code is called a client stub. gRPC encodes the data passed to the client stub into Protocol Buffers and sends it to the low-level transport layer. gRPC sends the data over the network as a stream of HTTP/2 data frames. Due to binary encoding and network optimization, gRPC is said to be 5 times fasters than JSON. 4-6. The Payment Service receives the packets from the network, decodes them, and invokes the server application. 7-9. The result returned from the server application gets encoded into Protocol Buffers and sent to the transport layer. 10-13. The Order Service receives the packets, decodes them, and sends the result to the client application. Use Case gRPC is known to be the inter-service communication mechanism of choice between microservices in the data centers. Its broad support for many programming languages allows services to choose their own language and developer ecosystems best suited for their own use cases.\nGraphQL GraphQL is a query language for API developed by Meta. It provides a schema of the data in the API and gives clients the power to ask for exactly what they need. GraphQL sits between the client and the backend services. It could aggregate multiple resource requests into a single query. It also supports mutations and subscriptions.\nMutations are GraphQL’s way of applying data modifications to resources.\nSubscriptions are GraphQL’s way for clients to receive notifications on data modifications.\nGraphQL vs. REST: Similarity In practice, both GraphQL and REST send HTTP requests and receive HTTP responses.\nFig. 24: GraphQL vs REST (Image source: ByteByteGo.com). Let’s look at a REST operation\n# rest https://example.com/api/v3/products https://example.com/api/v3/user REST centers around resources, and each resource is identified by an URL. To fetch a book from a bookstore API, it could look something like this\n{ \"title\": \"Harry Porter\", \"authors\": [ { \"name\": \"J.K.Rowling\" }, ... ] } The end point will be GET /book/123.\nLet’s look at a REST operation\n# graphql query type Query { book(id: ID!): Book } Here’s what data transfer looks like for GraphQL\ntype Book { id: ID title: String authors: [Author] } type Author { id: ID name: String books: [Book] } The end point will be GET /graphql?query={ book(id: \"123\") {title, authors {name}}}.\nAs we can see, both REST and GraphQL make a request via an URL and both can return a JSON response in the same shape.\nGraphQL vs. REST: Difference With GraphQL, we specify the exact resources we want and also which fields we want. While in REST, the API implementer decided that authors are included as related resources (as example above). With GraphQL, the client decides what to include.\nPros \u0026 Cons of GraphQL Pros:\nThe main benefit of GraphQL is that it doesn’t use URLs to specify the resources that are available in the API. Instead, it uses the GraphQL schema. This means that we can send a complex query that fetches additional data according to the relationship defined in the schema. Doing the same in REST is more complicated, as we have to do it client-side with multiple requests. This is a common problem resulting in N+1 queries. Cons:\nFor REST, we don’t need special libraries to consume someone else’s API. Requests can be sent using common tools like cURL or web browser. In constrast, GraphQL requires heavier tooling support, both on client and server sides such as GraphQL, Apollo, schema.graphql, codegen.yml, operation.graphql. This cost in resources might not be worth it if the application is a simple CRUD APIs. In addition, GraphQL is more difficult to cache. REST uses HTTP GET for fetching resources, and HTTP GET has a well-defined caching behavior that is leveraged by browsers, CDNs, proxies, and web servers. In constrast, GraphQL has a single point of entry and uses HTTP POST by default. This prevents the full use of HTTP caching. As GraphQL allows users to get the data they need, it is also a threat. API Gateway An API gateway is a single point of entry to the clients of an application, it sits between the clients and a collection of backend services for the application. An API gateway provides several important functions:\nAuthentication and Security Policy Enforcements. Load Balancing and Circuit Breaking. Protocol Translation and Service Discovery. Monitoring, Logging, Analytics, and Billing. Caching. Fig. 25: API Gateway (Image source: ByteByteGo.com). Workflow The client sends a request to the API gateway. The request is typically a HTTP-based. It could be REST, GraphQL, or higher-level abstractions. The API gateway validates the HTTP request. The API gateway checks the caller’s IP address and other HTTP headers against its allow-list and deny-list. It could also perform basic rate limit checks against attributes such as IP address and HTTP headers. For example, it could reject requests from an IP address exceeding a certain rate. The API gateway passes the request to an identity provider for authentication and authorization. The API gateway gets back from the provider with a scope of what the request is allowed to do. A higher level rate-limit check is applied against the authenticated session. If it is over the lomit, the request is rejected at this point. 6-7. With the help of a service discovery component, the API gateway locates the appropriate backend service to handle the request by path matching. The API gateway transform the requests into the appropriate protocol and sends the transformed request to the backend service. A protocol can be gRPC. When the response comes back from the backend service, the API gateway transforms the response back to the public-facing protocol and returns the response to the client. Fig. 26: API Gateway Workflow (Image source: ByteByteGo.com). API gateway should be deployed to multiple regions to improve availability.\nCitation Cited as:\nSystem Design Fundamentals Mega-Blog https://mnguyen0226.github.io/posts/system_design_concepts/post/ Or\n@article{nguyen2023sdmega, title = \"System Design Fundamentals Mega-Blog\", author = \"Nguyen, Minh\", journal = \"mnguyen0226.github.io\", year = \"2023\", month = \"January\", url = \"https://mnguyen0226.github.io/posts/system_design_concepts/post/\" } References [1] A. Xu, System Design Interview - An Insider’s Guide. Independently Published, 2020. ‌\n[2] ByteByteGo, “10+ Key Memory \u0026 Storage Systems: Crash Course System Design #5,” YouTube. Mar. 28, 2023. Accessed: Oct. 25, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=lX4CrbXMsNQ\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf ‌\n[3] ByteByteGo, “Latency Numbers Programmer Should Know: Crash Course System Design #1,” YouTube. Oct. 04, 2022. Accessed: Oct. 31, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=FqR5vESuKe0\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=3 ‌\n[4] ByteByteGo, “What Is REST API? Examples And How To Use It: Crash Course System Design #3,” YouTube. Aug. 24, 2022. Accessed: Oct. 31, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=-mN3VyJuCjM\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=4 ‌\n[5] ByteByteGo, “10 Key Data Structures We Use Every Day,” YouTube. May 01, 2023. Accessed: Oct. 31, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=ouipSd_5ivQ\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=5 ‌\n[6] ByteByteGo, “Cache Systems Every Developer Should Know,” YouTube. Apr. 04, 2023. Accessed: Oct. 31, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=dGAgxozNWFE\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=6 ‌\n[7] ByteByteGo, “Top 5 Redis Use Cases,” YouTube. Feb. 16, 2023. Accessed: Oct. 31, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=a4yX7RUgTxI\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=10 ‌\n[8] ByteByteGo, “CI/CD In 5 Minutes | Is It Worth The Hassle: Crash Course System Design #2,” YouTube. Jan. 18, 2023. Accessed: Nov. 01, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=42UP1fxi2SY\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=11 ‌\n[9] ByteByteGo, “Kubernetes Explained in 6 Minutes | k8s Architecture,” YouTube. Jan. 11, 2023. Accessed: Nov. 01, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=TlHvYWVUZyc\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=12\n[10] ByteByteGo, “CAP Theorem Simplified,” YouTube. Jan. 03, 2023. Accessed: Nov. 01, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=BHqjEjzAicA\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=13 ‌ ‌\n[11] ByteByteGo, “What is OSI Model | Real World Examples,” YouTube. Dec. 23, 2022. Accessed: Nov. 02, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=0y6FtKsg6J4\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=14 ‌\n[12] ByteByteGo, “What Is A CDN? How Does It Work?,” YouTube. Nov. 24, 2022. Accessed: Nov. 02, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=RI9np1LWzqw\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=15 ‌\n[13] ByteByteGo, “What is RPC? gRPC Introduction.,” YouTube. Dec. 01, 2022. Accessed: Nov. 04, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=gnchfOojMk4\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=19\u0026ab_channel=ByteByteGo ‌\n[14] ByteByteGo, “What Is GraphQL? REST vs. GraphQL,” YouTube. Nov. 10, 2022. Accessed: Nov. 04, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=yWzKJPw_VzM\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=17\u0026ab_channel=ByteByteGo ‌\n[15] ByteByteGo, “What is API Gateway?,” YouTube. Nov. 01, 2022. Accessed: Nov. 07, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=6ULyxuHKxg8\u0026list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf\u0026index=20 ‌\nFig. 23: Golden Gate Bridge, San Francisco, U.S.A (Image Source: Maarten van den Heuvel @ Unsplash). ",
  "wordCount" : "7321",
  "inLanguage": "en",
  "datePublished": "2023-01-20T00:00:00Z",
  "dateModified": "2023-01-20T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Minh T. Nguyen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mnguyen0226.github.io/posts/system_design_concepts/post/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Minh T. Nguyen",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mnguyen0226.github.io/favicon/android-chrome-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mnguyen0226.github.io/" accesskey="h" title="Minh T. Nguyen (Alt + H)">Minh T. Nguyen</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mnguyen0226.github.io/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://mnguyen0226.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://mnguyen0226.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://mnguyen0226.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://mnguyen0226.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://mnguyen0226.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mnguyen0226.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://mnguyen0226.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      System Design Fundamentals Mega-Blog
    </h1>
    <div class="post-description">
      Notes on fundamentals system design concepts, collected from Sahn Lam&#39;s lecture series.
    </div>
    <div class="post-meta"><span title='2023-01-20 00:00:00 +0000 UTC'>January 20, 2023</span>&nbsp;·&nbsp;35 min&nbsp;·&nbsp;Minh T. Nguyen

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#computer-memory--storage" aria-label="Computer Memory &amp;amp; Storage">Computer Memory &amp; Storage</a></li>
                <li>
                    <a href="#domain-name-system-dns" aria-label="Domain Name System (DNS)">Domain Name System (DNS)</a></li>
                <li>
                    <a href="#common-latency-numbers" aria-label="Common Latency Numbers">Common Latency Numbers</a></li>
                <li>
                    <a href="#rest-api" aria-label="REST API">REST API</a><ul>
                        
                <li>
                    <a href="#basics-of-rest-api" aria-label="Basics of REST API">Basics of REST API</a></li>
                <li>
                    <a href="#stateless" aria-label="Stateless">Stateless</a></li>
                <li>
                    <a href="#pagination" aria-label="Pagination">Pagination</a></li>
                <li>
                    <a href="#versioning" aria-label="Versioning">Versioning</a></li></ul>
                </li>
                <li>
                    <a href="#10-key-data-structures-in-system-design" aria-label="10 Key Data Structures in System Design">10 Key Data Structures in System Design</a><ul>
                        
                <li>
                    <a href="#linked-list" aria-label="Linked List">Linked List</a></li>
                <li>
                    <a href="#array" aria-label="Array">Array</a></li>
                <li>
                    <a href="#stack" aria-label="Stack">Stack</a></li>
                <li>
                    <a href="#queue" aria-label="Queue">Queue</a></li>
                <li>
                    <a href="#heap" aria-label="Heap">Heap</a></li>
                <li>
                    <a href="#tree" aria-label="Tree">Tree</a></li>
                <li>
                    <a href="#hash-table" aria-label="Hash Table">Hash Table</a></li>
                <li>
                    <a href="#suffix-tree" aria-label="Suffix Tree">Suffix Tree</a></li>
                <li>
                    <a href="#graph" aria-label="Graph">Graph</a></li>
                <li>
                    <a href="#r-tree" aria-label="R-tree">R-tree</a></li>
                <li>
                    <a href="#cache-friendliness-relations-to-data-structures" aria-label="Cache Friendliness Relations to Data Structures">Cache Friendliness Relations to Data Structures</a></li></ul>
                </li>
                <li>
                    <a href="#cache-systems" aria-label="Cache Systems">Cache Systems</a><ul>
                        
                <li>
                    <a href="#computer-caching-mechanism" aria-label="Computer Caching Mechanism">Computer Caching Mechanism</a></li>
                <li>
                    <a href="#cache-in-system-architecture" aria-label="Cache in System Architecture">Cache in System Architecture</a></li></ul>
                </li>
                <li>
                    <a href="#rediss-versitality" aria-label="Redis&amp;rsquo;s Versitality">Redis&rsquo;s Versitality</a><ul>
                        
                <li>
                    <a href="#cache" aria-label="Cache">Cache</a></li>
                <li>
                    <a href="#session" aria-label="Session">Session</a></li>
                <li>
                    <a href="#distributed-lock" aria-label="Distributed Lock">Distributed Lock</a></li>
                <li>
                    <a href="#rate-limiter" aria-label="Rate Limiter">Rate Limiter</a></li>
                <li>
                    <a href="#rankleaderboard" aria-label="Rank/Leaderboard">Rank/Leaderboard</a></li></ul>
                </li>
                <li>
                    <a href="#continuous-integration--continuous-delivery-cicd" aria-label="Continuous Integration / Continuous Delivery (CI/CD)">Continuous Integration / Continuous Delivery (CI/CD)</a><ul>
                        
                <li>
                    <a href="#continuous-integration-build-test-release" aria-label="Continuous Integration: Build, Test, Release">Continuous Integration: Build, Test, Release</a></li>
                <li>
                    <a href="#continuous-deployment-deploy-operate-monitor" aria-label="Continuous Deployment: Deploy, Operate, Monitor">Continuous Deployment: Deploy, Operate, Monitor</a></li></ul>
                </li>
                <li>
                    <a href="#kubernetes-k8s" aria-label="Kubernetes (K8s)">Kubernetes (K8s)</a><ul>
                        
                <li>
                    <a href="#control-plane" aria-label="Control Plane">Control Plane</a></li>
                <li>
                    <a href="#etcd" aria-label="Etcd">Etcd</a></li>
                <li>
                    <a href="#scheduler" aria-label="Scheduler">Scheduler</a></li>
                <li>
                    <a href="#controller-manager" aria-label="Controller Manager">Controller Manager</a></li>
                <li>
                    <a href="#worker-nodes" aria-label="Worker Nodes">Worker Nodes</a></li>
                <li>
                    <a href="#use-cases" aria-label="Use Cases">Use Cases</a></li></ul>
                </li>
                <li>
                    <a href="#cap-theorem" aria-label="CAP Theorem">CAP Theorem</a><ul>
                        
                <li>
                    <a href="#network-partition" aria-label="Network Partition">Network Partition</a></li>
                <li>
                    <a href="#banking-system-example" aria-label="Banking System Example">Banking System Example</a></li></ul>
                </li>
                <li>
                    <a href="#7-layers-of-osi-model" aria-label="7 Layers of OSI Model">7 Layers of OSI Model</a><ul>
                        
                <li>
                    <a href="#physical-layer" aria-label="Physical Layer">Physical Layer</a></li>
                <li>
                    <a href="#data-link-layer" aria-label="Data Link Layer">Data Link Layer</a></li>
                <li>
                    <a href="#network-layer" aria-label="Network Layer">Network Layer</a></li>
                <li>
                    <a href="#transport-layer" aria-label="Transport Layer">Transport Layer</a></li>
                <li>
                    <a href="#session-presentation-application-layers" aria-label="Session, Presentation, Application Layers">Session, Presentation, Application Layers</a></li>
                <li>
                    <a href="#networking-workflow" aria-label="Networking Workflow">Networking Workflow</a></li></ul>
                </li>
                <li>
                    <a href="#cdnhttpswwwyoutubecomwatchvri9np1lwzqwlistplcrmie5fdpsd0gvs500xeoewfystsmejfindex15" aria-label="CDN"><a href="https://www.youtube.com/watch?v=RI9np1LWzqw&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=15">CDN</a></a><ul>
                        
                <li>
                    <a href="#routings" aria-label="Routings">Routings</a></li>
                <li>
                    <a href="#edge-server--static-contents" aria-label="Edge Server &amp;amp; Static Contents">Edge Server &amp; Static Contents</a></li>
                <li>
                    <a href="#performance" aria-label="Performance">Performance</a></li>
                <li>
                    <a href="#security" aria-label="Security">Security</a></li>
                <li>
                    <a href="#availability" aria-label="Availability">Availability</a></li></ul>
                </li>
                <li>
                    <a href="#grpc" aria-label="gRPC">gRPC</a><ul>
                        
                <li>
                    <a href="#why-grpc-so-popular" aria-label="Why gRPC so popular?">Why gRPC so popular?</a></li>
                <li>
                    <a href="#workflow" aria-label="Workflow">Workflow</a></li>
                <li>
                    <a href="#use-case" aria-label="Use Case">Use Case</a></li></ul>
                </li>
                <li>
                    <a href="#graphql" aria-label="GraphQL">GraphQL</a><ul>
                        
                <li>
                    <a href="#graphql-vs-rest-similarity" aria-label="GraphQL vs. REST: Similarity">GraphQL vs. REST: Similarity</a></li>
                <li>
                    <a href="#graphql-vs-rest-difference" aria-label="GraphQL vs. REST: Difference">GraphQL vs. REST: Difference</a></li>
                <li>
                    <a href="#pros--cons-of-graphql" aria-label="Pros &amp;amp; Cons of GraphQL">Pros &amp; Cons of GraphQL</a></li></ul>
                </li>
                <li>
                    <a href="#api-gateway" aria-label="API Gateway">API Gateway</a><ul>
                        
                <li>
                    <a href="#workflow-1" aria-label="Workflow">Workflow</a></li></ul>
                </li>
                <li>
                    <a href="#citation" aria-label="Citation">Citation</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p style="color: #286EE0"><strong>[v.1.0] (01/20/2023):</strong> Post started!</p>
<h2 id="computer-memory--storage">Computer Memory &amp; Storage<a hidden class="anchor" aria-hidden="true" href="#computer-memory--storage">#</a></h2>
<ul>
<li><strong>Storage</strong>
<ul>
<li><strong>HDD</strong> (hard disk drive): it works by spinning magnetics disk.</li>
<li><strong>SSD</strong> (solid state drive): it uses NAND-based flash memory, providing fast data access, reduces power consumption, and increases durability. It is more expensive.</li>
<li><strong>USB Drive</strong>: is a small plug-and-play device for convenient data transfer between computers.</li>
<li><strong>SD Card</strong> is commonly found in camera and smartphone. There is SD Card, Mini Card, and Micro Card.</li>
</ul>
</li>
<li><strong>Memory</strong>
<ul>
<li><strong>RAM</strong> (random access memory): is a type of memory that store data temperarily while the computer is running. It&rsquo;s fast and flexible. However, all the data is lost after the power is off.
<ul>
<li><strong>SRAM</strong> (static random access memory): is a fast and expensive DRAM used in high speed application like CPU caches, where quick access time is crucial.</li>
<li><strong>DRAM</strong> (dynamic random access memory): is slower and cheaper than SRAM. It needs to be constantly refreshed to maintain data.
<ul>
<li><strong>SDRAM</strong></li>
<li><strong>DDR SDRAM</strong>: with examples like DDR4, DDR5.</li>
<li><strong>GGDDR SDRAM</strong>: is a specialized of DRAM with faster data transfer rates for parallel processing.</li>
</ul>
</li>
</ul>
</li>
<li><strong>ROM</strong> (read only memory): is a type of memory that retains data, even when the memory is off. It is used to store essential information like firmware and BIOS.
<ul>
<li><strong>Firmware</strong>: is a type of software stored in ROM that determines how hardware devices communicate with each others</li>
<li><strong>BIOS</strong> (basic input-output systems): first run when you booth up the computer. It is responsible for starting your computer, initializes hardware components, and hands over controls to the OS.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="domain-name-system-dns">Domain Name System (DNS)<a hidden class="anchor" aria-hidden="true" href="#domain-name-system-dns">#</a></h2>
<p>It is the backbone of the internet.</p>
<p><em><strong>But how does it work?</strong></em></p>
<p>DNS is a directory: it translates human-readable domain names (i.e, <a href="https://www.google.com">www.google.com</a>) to machine-readable IP-addresses.</p>
<p>There are different DNS servers with different purposes. The DNS Resolver can be provided by Cloudflare (1.1.1.1) or Google (8.8.8.8).</p>
<p><em><strong>How does the DNS Resolver find the authoritative nameservers?</strong></em></p>
<p>There are 3 levels of DNS:</p>
<ul>
<li><strong>Root Nameservers</strong>: stores the IP-addresses of the TLD nameservers. There are 13 logical Root Nameservers. Ex: .com, .org, .edu</li>
<li><strong>Top Level Domain (TLD) Nameservers</strong>: stores the IP-addresses of the Authoritative Nameservers. Ex: google.com, wikipedia.org, mit.edu.</li>
<li><strong>Authoritative Nameservers</strong>: stores authoritative answers to queries</li>
</ul>
<p>Such design above make DNS decentralized and robust.</p>
<p><em><strong>How does the workflow look like?</strong></em></p>
<center>
    <img style="width: 100%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/2_dns.png" />
</center>
<figcaption class="img_footer">
    Fig. 1: DNS workflow (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<ul>
<li>The user types &ldquo;google.com&rdquo; to browser.</li>
<li>The browser first checks its cache, if there is no answer, it makes the OS call to get the answer.</li>
<li>The OS then reachs out to DNS Resolver.</li>
<li>The DNS Resolver first checks its cache, if it is not there or if the answer is expired, it will ask the Root Nameservers.</li>
<li>The Rootname Servers responses with the root name TLD Nameservers. Here, if the RootName Servers found the root name TLD Nameservers (i.e. .com as it is common) in its cache, it will return.</li>
<li>The DNS Resolver then reachout to the TLD Nameservers, which return the Authoritative Nameservers for &ldquo;google.com&rdquo;.</li>
<li>The DNS Resolver then reachout to the Authoritative Nameservers and get the IP-address of &ldquo;google.com&rdquo;.</li>
<li>The DNS Resolver then returns the address of the IP system to the OS, and the OS returns it to the browswer.</li>
</ul>
<h2 id="common-latency-numbers">Common Latency Numbers<a hidden class="anchor" aria-hidden="true" href="#common-latency-numbers">#</a></h2>
<center>
    <img style="width: 35%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/3_latency.png" />
</center>
<figcaption class="img_footer">
    Fig. 2: Latency number hierachy (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<ul>
<li><strong>1 ns</strong>: Accessing CPU registers, CPU clock cycle.</li>
<li><strong>1-10 ns</strong>: L1/L2 cache, Branch mispredict.</li>
<li><strong>10-100 ns</strong>: L3 cache.</li>
<li><strong>100-1000 ns</strong>: System call, MD5 hash.</li>
<li><strong>1-10 µs</strong>: Context switches between threads.</li>
<li><strong>10-100 µs</strong>: Higher level operations such as process a http request, sequential read, read a 8K page.</li>
<li><strong>100-1000 µs</strong>: SSD write latency, intra-zone networking round trip, memcache/redis get operation.</li>
<li><strong>1-10 ms</strong>: Intra-zone network latency, seek time of HDD.</li>
<li><strong>10-100 ms</strong>: Network round-trip from US West-East.</li>
<li><strong>100-1000 ms</strong>: Bcrypt a password, TLS handshake, reading sequentially 1GB of SSD.</li>
<li><strong>1 s</strong>: Tranfer 1GB over the network within the same cloud region.</li>
</ul>
<h2 id="rest-api">REST API<a hidden class="anchor" aria-hidden="true" href="#rest-api">#</a></h2>
<p><strong>Representational State Transfer Application Programming Interface (REST API)</strong> is the most popular communication standard between computers over Internet. <strong>API</strong> is a way for two computers to talk to each other. The common API used by mobile and web applications to talk to the servers is called <strong>REST</strong>. For instance, Twilio, Stripe, Google Maps use REST API.</p>
<p><strong>REST</strong> is not a specification, it is a loose set of rules for building web API since the early 2000s. Those rules are:</p>
<ul>
<li>Uniform Interface.</li>
<li>Client-Server.</li>
<li>Stateless.</li>
<li>Cacheable.</li>
<li>Layered System.</li>
<li>Code on Demand (Optional).</li>
</ul>
<h3 id="basics-of-rest-api">Basics of REST API<a hidden class="anchor" aria-hidden="true" href="#basics-of-rest-api">#</a></h3>
<p>The REST API organizes resources into a set of unique Uniform Resource Identifiers (URIs). The URIs differentiate types of resources on a server.</p>
<pre tabindex="0"><code>https://example.com/api/v3/products
https://example.com/api/v3/users
</code></pre><p>A client connects to resources by making a request to the endpoint for the resource over HTTP. The request has a specific format such as <code>POST/products HTTP/1.1</code>.</p>
<p>Here are the operations (CRUD)</p>
<ul>
<li><code>POST</code>: <code>CREATE</code> a new resource.</li>
<li><code>GET</code>: <code>READ</code> the data about an existing resource.</li>
<li><code>PUT</code>: <code>UPDATE</code> an existing resource.</li>
<li><code>DELETE</code>: <code>DELETE</code> an existing resource.</li>
</ul>
<p>In the body of these request, there could be an optional HTTP request body that contains a custom payload of data, usually encoded in JSON.</p>
<pre tabindex="0"><code>POST/produccts HTTP/1.1
Accept: application/json

JSON: {
  &#34;customer&#34;: &#34;Minh Nguyen&#34;,
  &#34;quantity&#34;: 1,
  &#34;price&#34;: 19.00
}
</code></pre><p>The server receives a request, processes it and form the result into response.</p>
<pre tabindex="0"><code>HTTP/1.1 200 OK
</code></pre><p>Some HTTP status codes:</p>
<ul>
<li><code>200</code>: Request is successful.</li>
<li><code>400</code>: Something is wrong with our request, such as wrong syntax.</li>
<li><code>500</code>: Something is wrong at the server level, such as the server is not available.</li>
</ul>
<h3 id="stateless">Stateless<a hidden class="anchor" aria-hidden="true" href="#stateless">#</a></h3>
<p>A REST implementation should be stateless. This means that the two parties don&rsquo;t need to store any information about each other, and every request and response (cycle) is independent from all others. This attribute leads to the web application that is easy to scale and well behaved.</p>
<h3 id="pagination">Pagination<a hidden class="anchor" aria-hidden="true" href="#pagination">#</a></h3>
<p>If the return endpoint returns a huge amount of data, we should use pagination. A common scheme uses <code>limit</code> and <code>offset</code> as parameters. If they are not specified, the server should assume sensible default values.</p>
<pre tabindex="0"><code>/products?limit=25&amp;offset=50
</code></pre><h3 id="versioning">Versioning<a hidden class="anchor" aria-hidden="true" href="#versioning">#</a></h3>
<p>Versioning allows an implementation to provide backward compatibility, so that if we introduce breaking changes from one version to another, consumers can get enough time to move to the next version.</p>
<p>There are many ways to versioning an API. The most common way is to prefix the version before the resource on the URI.</p>
<pre tabindex="0"><code>/v1/products
/v2/products
</code></pre><p>RESTful API is sensible if used correctly as it is simple and good enough, and that&rsquo;s why it is so widely used. Other options are <strong>GraphQL</strong> and <strong>gRPC</strong>.</p>
<h2 id="10-key-data-structures-in-system-design">10 Key Data Structures in System Design<a hidden class="anchor" aria-hidden="true" href="#10-key-data-structures-in-system-design">#</a></h2>
<p>The choice of correct data structures based on the specification and constraints of the projects is important. To refresh the fundamentals of these data structures, please visit <a href="https://neetcode.io/">https://neetcode.io/</a>.</p>
<h3 id="linked-list">Linked List<a hidden class="anchor" aria-hidden="true" href="#linked-list">#</a></h3>
<p>Linked list (or list) is a versatile and essential data structure in software development. It is great for storing and manipulating ordered data. They are useful in various applications such as <em>task-management</em>, <em>social media feeds</em>, and <em>shopping carts</em>.</p>
<p>For <em>task-management application</em>, a list can be used to store and organize tasks for each user. Tasks can be added, removed, or reordered easily, and users can mark them as complete or incomplete.</p>
<p>In <em>social media application</em>, e.g. Twitter (X), where they can store and display a users&rsquo; feeds in real-time, ensuring the order is correct in real-time.</p>
<h3 id="array">Array<a hidden class="anchor" aria-hidden="true" href="#array">#</a></h3>
<p>Array provdes a fixed-size, ordered collection of elements. They are suitable for situation where the size of the collections is known or isn&rsquo;t changed frequently. Arrays are commonly used in mathematical operations, storing large datasets, or when there is a need for random access to elements.</p>
<p>For instance, in the <em>weather application</em>, an array can store temperature readings for a specific location over a defined period. This allows for easy calculations like average temperature or trends analysis.</p>
<p>Arrays are also used in <em>image-processing</em>, where each pixel&rsquo;s color data can be represented in a 2D array. It enables efficient manipulation and transformation of the image.</p>
<h3 id="stack">Stack<a hidden class="anchor" aria-hidden="true" href="#stack">#</a></h3>
<p>Stacks follow the LIFO principle, and they are perfect for supporting undo/redo operations in <em>text editors</em> or maintaining <em>browsing history in web browsers</em>.</p>
<p>In the <em>text editors</em>, a stack can be used to store each change made to the text, making it simple to revert to a previous state when the user triggers an undo operation.</p>
<h3 id="queue">Queue<a hidden class="anchor" aria-hidden="true" href="#queue">#</a></h3>
<p>Queues operate on the FIFO principle, and they are good for managing <em>printer jobs</em>, sending actions in <em>games</em>, or handling messages in <em>chat applications</em>. Specifically, in <em>chat applications</em>, a queue can be used to store incoming messages in the order they are received. It ensures that they are displayed to the recipient in the correct sequence.</p>
<h3 id="heap">Heap<a hidden class="anchor" aria-hidden="true" href="#heap">#</a></h3>
<p>Heaps are used for <em>task scheduling</em> and <em>memory management</em>. They are helpful in implementing priority queues where we need to access the highest or lowest priority item efficiently.</p>
<h3 id="tree">Tree<a hidden class="anchor" aria-hidden="true" href="#tree">#</a></h3>
<p>Trees organize data hierarchically. They are useful for representing data with natural hierarchies or relationships. Trees are used in <em>database indexing</em>, <em>file systems</em>, or <em>AI decision tree</em>.</p>
<p>For <em>database indexing</em>, tree helps speed up search, insert, or delete operations. For example, B-trees and B+ trees are commonly used in relational databases to efficiently manage and index large amount of data.</p>
<h3 id="hash-table">Hash Table<a hidden class="anchor" aria-hidden="true" href="#hash-table">#</a></h3>
<p>Hash table (or hashmap) allows for efficent data lookup, insertion, and deletion. They use a hash function to map keys to their corresponding storage locations. It enables constant-time access to the stored values. Hash tables are widely used in various applications, such as <em>search engines</em>, <em>caching systems</em>, and <em>programming language interpreters</em> or <em>compilers</em>.</p>
<p>In <em>search engine</em>, hash table allows to store and quickly retrieve indexed data based on keywords. This provides fast and relevant search results.</p>
<p><em>Caching systems</em> may use hash tables to store and manage cached data. It allows for eapid access to frequently requested resources and improves overall system performance.</p>
<h3 id="suffix-tree">Suffix Tree<a hidden class="anchor" aria-hidden="true" href="#suffix-tree">#</a></h3>
<p>Suffix trees (or tries) are specialized for searching strings in documents. This makes them perfect for <em>text editors</em> and <em>search algorithms</em>. In a <em>search engine</em>, a suffix tree can be used to efficiently locate all occurrences of a search term within a larger corpus of text.</p>
<h3 id="graph">Graph<a hidden class="anchor" aria-hidden="true" href="#graph">#</a></h3>
<p>Graphs are all about tracking relationships or finding paths. This makes them invaluable in <em>social networks</em>, <em>recommendation engines</em>, and <em>pathfinding algorithms</em>.</p>
<p>In a <em>social network</em>, a graph can be used to represent a connections between users. It enables features like friend suggestion or analyzing network trends.</p>
<h3 id="r-tree">R-tree<a hidden class="anchor" aria-hidden="true" href="#r-tree">#</a></h3>
<p>R-trees are good at finding nearest neighbors. They are crucial for <em>mapping apps</em> and <em>geolocation services</em>. In a <em>mapping applications</em>, R-trees can be used to store spatial data, such as points of interest. This enables efficient queries to find the nearest locations based on the user&rsquo;s current position.</p>
<h3 id="cache-friendliness-relations-to-data-structures">Cache Friendliness Relations to Data Structures<a hidden class="anchor" aria-hidden="true" href="#cache-friendliness-relations-to-data-structures">#</a></h3>
<p>CPU cache is a small, fast memory between the main memory (RAM) and the CPU. It stores recently accessed data and instructions, so the CPU can access them quickly without fetching them from the slower main memory.</p>
<p>Different data structures have different levels of cache friendliness based on how their elements are stored in memory. Contiguous memory storage (arrays) allows for better cache locality and fewer cache misses, resulting in improved performance. When an array element is accessed, the cache can be prefetch and store nearby elements, anticipating that they might be accessed soon. While data structures with non-contiguous memory storage (linked-list) can experience more cache misses and reduce performance. In a linked list, elements are stored in nodes scattered throughout the memory and each node contains a pointer to the next node in the sequence. This makes it difficult for the CPU to predict and load the next node before it&rsquo;s needed.</p>
<p>Other data structures have varying degrees of cache friendliness based on their implementation and use case. This disparity in access times can lead to performance issues in modern computing, particularly in situations where cache misses occur frequently.</p>
<h2 id="cache-systems">Cache Systems<a hidden class="anchor" aria-hidden="true" href="#cache-systems">#</a></h2>
<p>Caching is a common technique in modern computing to system performance and reduce response time. From the front-end to back-end, caching plays a crucial role in improving the efficiency of various applications and systems.</p>
<p>A typical system architecture involves several layers of caching. At each layer, there are multiple strategies and mechanisms for caching data, depending on the requirements and constraints of the specific application.</p>
<h3 id="computer-caching-mechanism">Computer Caching Mechanism<a hidden class="anchor" aria-hidden="true" href="#computer-caching-mechanism">#</a></h3>
<p>The most common hardware cache are <em>L1</em>, <em>L2</em>, and <em>L3</em> caches.</p>
<ul>
<li><em>L1 cache</em> (KBs) is the smallest and fastest cache, typically integrated into the CPU itself. It stores frequently accessed data and instructions, allowing the CPU to quickly access them without having to fetch them from slower memory.</li>
<li><em>L2 cache</em> (MBs) is larger but slower than L1. It is typically located on the CPU die or on a separate chip.</li>
<li><em>L3 cache</em> is larger but slower than L2. It is typically shared between multiple CPU cores.</li>
</ul>
<p>Another common hardware cache is the <em>translation lookaside buffer (TLB)</em>. It stores recently used virtual-to-physical address translations. It is used by the CPU to quickly translate virtual memory addresses to physical memory addresses, reducing the time needed to access data from memory</p>
<p>At the OS level, there are <em>page cache</em> and other <em>file system caches</em>. <em>Page cache</em> is managed by the OS and resides in the main memory. It is used to store recently used disk blocks in memory. When a program requests data from the disk, the OS can quickly retrieve the data from memory instead of reading it from disk. There are other caches managed by the OS, such as <em>inode cache</em>. These caches are used to speed up file system operations by reducing the number of disk accesses required to access files and directories.</p>
<h3 id="cache-in-system-architecture">Cache in System Architecture<a hidden class="anchor" aria-hidden="true" href="#cache-in-system-architecture">#</a></h3>
<center>
    <img style="width: 100%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/6_cache.png" />
</center>
<figcaption class="img_footer">
    Fig. 3: Cache in System Architecture (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<p><strong>Front-end</strong>: web browsers can cache HTTP response to enable faster retrieval of data. When we request data over HTTP for the first time and it returned with an expiration policy in the HTTP header; we request thee same data again, and the broweser returns the data from its cache if available.</p>
<p><strong>CDNs</strong>: are used to improve the delivery of static contents (images, videos, web assets). When a user requests a content from a CDN, the CDN network looks for the requested content in its cache. If the content is not already in the cache, the CDN fetches it from the origin server and caches it on its edge servers. When another user requests the same content, the CDN can deliever the content directly from its cache, eliminating the need to fetch it from the origin server again.</p>
<p><strong>Load-balancers</strong>: implement cache resources to reduce the load on back-end servers. When a user requests content from a server behind a load balancer, the load balancer can cache the response and server it directly to future users who request the same content. This can improve response times and reduce the load on back-end servers.</p>
<p><strong>Messeging infrastructure</strong>, <strong>message brokers</strong> such as Kafka can cache a massive amount of messages on disk. This allows consumers to retrieve the message at their own pace. The messages can be cached for a long period of time based onthe retention policy.</p>
<p><strong>Distributed caches</strong> such as Redis can store key-value pairs in memory, providing high read/write performance compared to traditional databases.</p>
<p><strong>Full-text search engines</strong> like Elastic Search can index data for document search and log search, providing quick and efficient access to specific data.</p>
<p><strong>Relational database</strong>: has multiple levels of caching:</p>
<ul>
<li><em>Data</em> is typicaly written to WAL (write-ahead-log), before indexed in a B-tree.</li>
<li><em>Buggerpool</em> is a memory area used to cache query results.</li>
<li><em>Materialized-view</em> can precompute query results for faster performance.</li>
<li><em>Transaction-log</em> records all transactions and updates to the database.</li>
<li><em>Replication-log</em> tracks the replication state in the database cluster.</li>
</ul>
<h2 id="rediss-versitality">Redis&rsquo;s Versitality<a hidden class="anchor" aria-hidden="true" href="#rediss-versitality">#</a></h2>
<p>Redis is an in-memory data structure store. It is most commonly used as a cache. It support many data structure such as strings, hashes, lists, sets, and sorted sets. Redis is known for its speed.</p>
<h3 id="cache">Cache<a hidden class="anchor" aria-hidden="true" href="#cache">#</a></h3>
<p>The number one use case for Redis is caching objects to speed up web applications. Here, Redis stores frequently requested data in memory. They allows the web servers to return frequently accessed data quickly. This reduces the load on the database and improves the response time for the application.</p>
<p>At scale, the cache is distributed among a cluster of Redis servers. <em>Sharding</em> is a common technique to distribute the cache load evenly across the cluster.</p>
<h3 id="session">Session<a hidden class="anchor" aria-hidden="true" href="#session">#</a></h3>
<p>Redis can be used as a session storage to share session data among stateless servers. When a user logs into a web application, a session data is stored in Redis along with a unique session ID that is returned to the client as cookie. When the user makes a request to the application, the session ID is included in the request and the stateless web server retrieves the session data from Redis using the ID.</p>
<p>Redis is an in-memory database. The session data stored in Redis will be lost if the Redis server restarts. Even through Redis provides persistence options like snapshots or AOF (Append-Only File) that allow session data to be saved to disk and reloaded into memory in the event of a restart, these options often take too long to load on restart to be practical.</p>
<p>In production, replication is usually used instead such as back-up instance. If there is a crash, the back-up instance will be promoted to take over the traffic.</p>
<h3 id="distributed-lock">Distributed Lock<a hidden class="anchor" aria-hidden="true" href="#distributed-lock">#</a></h3>
<p>Distributed locks are used when multiple nodes in an application need to coordinate access to some shared resource. Redis is used as a distributed lock with is atomic commands like <code>SETNX</code> (set if not exist). The command allows a caller to set a key only if it does not already exist.</p>
<p>For instance, <code>client_1</code> tries to acquire the lock by setting a key with a unique value and a timeout using the <code>SETNX</code> command, <code>SETNX lock &quot;1234abcd&quot; EX 3</code>. If the key was not already set, the <code>SETNX</code> command returns <code>1</code>, indicating that the lock has been acquired by <code>client_1</code>. <code>client_1</code> finishes its work and releases the lock by deleting the key. If the key was already set, the <code>SETNX</code> command returns <code>0</code>, indicating that the lock is already held by another client. In this case, <code>client_1</code> waits and retries the <code>SETNX</code> until the lock is released by other client.</p>
<h3 id="rate-limiter">Rate Limiter<a hidden class="anchor" aria-hidden="true" href="#rate-limiter">#</a></h3>
<p>Redis can be used as a rate limiter by using its increment command on some counters and setting expiration times on those counters.</p>
<p>Basic rate-limiting: For each incoming request, the request IP or user ID is used as a key. The number of requests for the key is incremented using the <code>INCR</code> command in Redis. The current count is compared to the allowed rate limit. If the count is within the rate limit, the request is processed. If the count is over the rate limit, the request is rejected. The keys are set to expire after a specific time-window (minutes) to reset the counts for the next time window.</p>
<p>There is also a <a href="https://en.wikipedia.org/wiki/Leaky_bucket">Leaky Bucket Algorithm</a> implemented using Redis.</p>
<h3 id="rankleaderboard">Rank/Leaderboard<a hidden class="anchor" aria-hidden="true" href="#rankleaderboard">#</a></h3>
<p>For most games that are not super high scale, Redis is a way to implement various types of gaming leaderboards. <em>Sorted Sets</em> (or sorted container or sorted hashmap) are the fundamental data structure that enables this. Here, we can retrieve the data in <strong>O(logN)</strong>.</p>
<h2 id="continuous-integration--continuous-delivery-cicd">Continuous Integration / Continuous Delivery (CI/CD)<a hidden class="anchor" aria-hidden="true" href="#continuous-integration--continuous-delivery-cicd">#</a></h2>
<p>CI/CD is a software development process including:</p>
<ul>
<li><strong>Continuous Integration</strong>
<ul>
<li>Code commit (multiple developers).</li>
<li>Build.</li>
<li>Unit and integration tests.</li>
<li>Create application or service image.</li>
</ul>
</li>
<li><strong>Continuous Delivery</strong>
<ul>
<li>Functional testing.</li>
<li>User acceptance testing.</li>
<li>Configuration automation.</li>
<li>Load testing.</li>
<li>Deployment.</li>
</ul>
</li>
</ul>
<p>It eliminates much of the manual human intervention traditionally require to get new code to production. CI/CD promises software teams to deploy better quality software and faster.</p>
<center>
    <img style="width: 100%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/11_cicd.png" />
</center>
<figcaption class="img_footer">
    Fig. 4: CI/CD Toolkits (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="continuous-integration-build-test-release">Continuous Integration: Build, Test, Release<a hidden class="anchor" aria-hidden="true" href="#continuous-integration-build-test-release">#</a></h3>
<p>CI is the practice of using automation to enable teams to merge code changes into the shared repository early and often. Each commit triggers an automated workflow on a CI server that runs a series of tasks to make sure the commit is safe to merge into the main branch.</p>
<p>A good CI process relies on a set of good tests. It is non-trivial to maintain a set of tests with sufficient coverage that is not flakey.</p>
<p>High test coverage usually takes longer to run. This impacts developer&rsquo;s productivity.</p>
<h3 id="continuous-deployment-deploy-operate-monitor">Continuous Deployment: Deploy, Operate, Monitor<a hidden class="anchor" aria-hidden="true" href="#continuous-deployment-deploy-operate-monitor">#</a></h3>
<p>Real CD is hard as the practice is not as common as CI. Many teams only practice CD on the most basic types of systems. These systems are usually stateless such as API or web server tiers.</p>
<p>A very few teams has the resource to implement real continuous, hands-off deployment on complex stateful systems like database, backend clusters, or other types of stateful systems like websocket cluster.</p>
<p>Instead, these systems are usually on a fixed deploy cadence. The deployment process is manual, risky, and time consuming. They require the care of dedicated platform team. It is rare to see these systems deployed fully, continuously, and automatically.</p>
<h2 id="kubernetes-k8s">Kubernetes (K8s)<a hidden class="anchor" aria-hidden="true" href="#kubernetes-k8s">#</a></h2>
<p>Kubernetes is an open-source container orchestration platform. It automates the deployment, scaling, and management of containerized applications.</p>
<p>Kubernestes is a set of machines called nodes, that are used to run containerized applications. There are two core pieces in a Kubernestes cluster:</p>
<ul>
<li><strong>Control plane</strong>: responsible for managing the state of the cluster. In production environment, the control plane runs on multiple nodes that span across several data center zones.</li>
</ul>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/12_control_plane.png" />
</center>
<figcaption class="img_footer">
    Fig. 5: Control Plane (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<ul>
<li><strong>Set of worker nodes</strong>: run the containerized application workloads. The containerized applications run in a <strong>Pod</strong>. Pods are the smallest deployable units in Kubernetes. Pods hosts one or more containers and provides shared sotrage and networking for those containers. Pods are created and managed by the Kubernetes control plane. They are the basic building blocks of Kubernetes applications</li>
</ul>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/12_worker_nodes.png" />
</center>
<figcaption class="img_footer">
    Fig. 6: Worker Nodes and Pods (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="control-plane">Control Plane<a hidden class="anchor" aria-hidden="true" href="#control-plane">#</a></h3>
<p>Control plane consists of a number of core components such as API server, controller manager, scheduler, etcd. The API server is the primary interface between the control plane and the rest of the cluster. It is used by the API server and other components of the control and retrieve information about the cluster. It exposes a RESTful API that allows clients to interact with the control plane and submit requests to manage the cluster.</p>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/12_control_plane_detail.png" />
</center>
<figcaption class="img_footer">
    Fig. 7: Control Plane Connections (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="etcd">Etcd<a hidden class="anchor" aria-hidden="true" href="#etcd">#</a></h3>
<p>Etcd is a distributed key-value store. It stores the cluster&rsquo;s persistent state.</p>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/12_etcd.png" />
</center>
<figcaption class="img_footer">
    Fig. 8: Etcd (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="scheduler">Scheduler<a hidden class="anchor" aria-hidden="true" href="#scheduler">#</a></h3>
<p>The scheduler is responsible for scheduling pods onto the worker nodes in the cluster. It uses the information about the resource required by the pods and available resources on the worker nodes to make the placement decisions</p>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/12_scheduler.png" />
</center>
<figcaption class="img_footer">
    Fig. 9: Scheduler (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="controller-manager">Controller Manager<a hidden class="anchor" aria-hidden="true" href="#controller-manager">#</a></h3>
<p>Controller manager is responsible for running controllers that manage the state of the cluster. For instance</p>
<ul>
<li>The replication controller ensures that the desired number of replicas of a pod are running.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">kind: ReplicationController
</span></span><span class="line"><span class="cl">metadata: 
</span></span><span class="line"><span class="cl">  name: nginx
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  replicas: <span class="m">4</span>
</span></span></code></pre></div><ul>
<li>The deployment controller, which manages the rolling update and rollback of deployments.</li>
</ul>
<h3 id="worker-nodes">Worker Nodes<a hidden class="anchor" aria-hidden="true" href="#worker-nodes">#</a></h3>
<p>The core compoenents of Kubernetes that run on the worker nodes include Kubelet, Container Runtime, and Kube-proxy.</p>
<ul>
<li><strong>Kubelet</strong>: is a daemon that runs on each worker node. It is responsible for communicating with the control plane. It receives instructions from the control plane about which pods to run on the node and ensures that the desired state of the pods is maintained.</li>
<li><strong>Container Runtime</strong> runs the containers on the worker nodes. It is responsible for pilling the container images from a registry, starting and stopping the containers, and managing the containers&rsquo; resources.</li>
<li><strong>Kube-proxy</strong>: is a network proxy that runs on each worker node. It is responsible for routing traffic to the correct pods. It also provides load balancing for the pods and ensures that the traffic is distributed evenly across the pods</li>
</ul>
<h3 id="use-cases">Use Cases<a hidden class="anchor" aria-hidden="true" href="#use-cases">#</a></h3>
<p>It&rsquo;s about trade-off.</p>
<p><strong>Pros</strong>:</p>
<ul>
<li>Kubernetes is scalable and highly available. It provides features like self-healing, automatic rollbacks, and horizontal scaling. It makes it easy to scale out applications up and down as needed, allowing us to respond to changes in demannd quickly.</li>
<li>Kubernetes is portable. It helps us deploy and manage applications in a consistent and reliable way regardless of the underlying infrastructure. It runs on-premise, in a public cloud, or in a hybrid environment. it provides a uniform way to package, deploy, and manage applications.</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>Kubernetes is complex to set up and operate! The upfront cost is high, especially for organizations new to container orchestration. It requires a high level of expertise and resources to set up and manage a production Kubernetes environment.</li>
<li>Kubernetes is costly. It requires a certain minimum level of resources to run in order to support all the features. Thus, it is an overkill for smaller organizations.</li>
</ul>
<p><strong>Services</strong>: Amazon EKS, Google Cloud GKE, or Azure AKS.</p>
<h2 id="cap-theorem">CAP Theorem<a hidden class="anchor" aria-hidden="true" href="#cap-theorem">#</a></h2>
<p>Consistency-Availability-Partition Tolerance (CAP) Theorem explains the trade-off between consistency, availability, and partition tolerance in distributed systems. The CAP theorem helps us think in a high-level trade-off to consider when there is network partition.</p>
<center>
    <img style="width: 100%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/13_cap.png" />
</center>
<figcaption class="img_footer">
    Fig. 10: CAP Theorem Illustration (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<p><strong>Consistency</strong> refers to the property of a system where all nodes have a consistent view of the data. It means all clients see the same data at the same time no matter which node they connect to.</p>
<p><strong>Availability</strong> refers to the ability of a system to respond to requests from users at all time.</p>
<p><strong>Partition Tolerance</strong> refers to the ability of a system to continue operating even if there is a network partition.</p>
<h3 id="network-partition">Network Partition<a hidden class="anchor" aria-hidden="true" href="#network-partition">#</a></h3>
<p>A network partition happens when nodes in a distributed system are unable to communicate with each other due to network failures. When this happen, a system must choose between consistency and availability.</p>
<ul>
<li>If the system prioritizes consistency, it may becomes unavailable until the partition is resolved.</li>
<li>If the system prioritizes availability, it may allow updates to the data. This could result in data inconsistencies until the partition is resolved.</li>
</ul>
<h3 id="banking-system-example">Banking System Example<a hidden class="anchor" aria-hidden="true" href="#banking-system-example">#</a></h3>
<p>For instance, let&rsquo;s say we have a tiny bank with 2 ATMs connected over a network. The ATMs support 3 operations: deposit, withdraw, and check balance. No matter what happens, the lance should never go below zero. There is no central database to keep the account balance, it is stored on both ATMs. When a customer uses an ATM, the balance is updated on both ATMs over the network. This ensures that the ATMs have a consistent view of the account balance.</p>
<p>If there is a network partiotion and the ATM are unable to communicate with each other, the system must choose between consistency and availability.</p>
<ul>
<li>If the bank prioritizes consistency, the ATM may refuse to process deposit or withdrawals until the partition is resolved. This ensures that the balance remains consistent, but the system is unavailable to customers.</li>
</ul>
<center>
    <img style="width: 100%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/13_bank_consistency.png" />
</center>
<figcaption class="img_footer">
    Fig. 11: Bank Consistency (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<ul>
<li>If the bank prioritizes availability, the bank may allow deposit or withdrawals to occur but the balance may be inconsistent until the partition is resolved. When there is a network partition, the customer could withdraw the entire balance from both ATMs. When the network is back online, the inconsistency is resolve and the balance is negative, which is not good</li>
</ul>
<center>
    <img style="width: 100%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/13_bank_availability.png" />
</center>
<figcaption class="img_footer">
    Fig. 12: Bank Availability (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h2 id="7-layers-of-osi-model">7 Layers of OSI Model<a hidden class="anchor" aria-hidden="true" href="#7-layers-of-osi-model">#</a></h2>
<p>The Open System Interconnect (OSI) model is a theoretical framework that provides one way of thinking about networking. It splits the network communication between two devices on a network into seven abstraction layers.</p>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/14_osi_layers.png" />
</center>
<figcaption class="img_footer">
    Fig. 13: Seven Layers of OSI Model (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="physical-layer">Physical Layer<a hidden class="anchor" aria-hidden="true" href="#physical-layer">#</a></h3>
<p>The physical layer is responsible for transmitting raw bits of data across a physical connection.</p>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/14_physical.png" />
</center>
<figcaption class="img_footer">
    Fig. 14: Physical Layer (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="data-link-layer">Data Link Layer<a hidden class="anchor" aria-hidden="true" href="#data-link-layer">#</a></h3>
<p>The data link layer takes the raw bits from the physical layer and organizes them into frames. It ensures that the frames are delivered to the correct destination. The Ethernet primarily lives in this layer.</p>
<center>
    <img style="width: 80%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/14_data_link.png" />
</center>
<figcaption class="img_footer">
    Fig. 15: Data Link Layer (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="network-layer">Network Layer<a hidden class="anchor" aria-hidden="true" href="#network-layer">#</a></h3>
<p>The network layer is responsible for routing data frames across different networks. The IP part of TCP/IP is a well-known example of this layer.</p>
<center>
    <img style="width: 80%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/14_network_layer.png" />
</center>
<figcaption class="img_footer">
    Fig. 16: Network Layer (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="transport-layer">Transport Layer<a hidden class="anchor" aria-hidden="true" href="#transport-layer">#</a></h3>
<p>The transport layer handles end-to-end communication between 2 nodes. This is the layer where the TCP and UDP protocols live.</p>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/14_transport.png" />
</center>
<figcaption class="img_footer">
    Fig. 17: Transport Layer (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<p>TCP provides reliable, end-to-end communication between devices. It does this by dividing the data into small, manageable segments and sending each segment individually. Each segment has asequence number attached to it. The receiving end uses the sequence numbers to reassemble the data in the correct order.</p>
<center>
    <img style="width: 80%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/14_tcp.png" />
</center>
<figcaption class="img_footer">
    Fig. 18: TCP in Transport Layer (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<p>TCP also provide error checking to make sure that the data was not corrupted during transmission.</p>
<p>UDP is a protocal that is similar to TCP but is simpler and faster. Unlike TCP, UDP does not provide the same level of error-checking and reliability. It simply send packets of data from one device to another. The receiving end is responsible for determining whether the packets were received correctly. If an error is detected, the receiving end simply discards the packet.</p>
<h3 id="session-presentation-application-layers">Session, Presentation, Application Layers<a hidden class="anchor" aria-hidden="true" href="#session-presentation-application-layers">#</a></h3>
<p>The analysis of these layers in OSI model is not useful in practice as the OSI is too fine-grained and does not reflect reality. Let&rsquo;s consider them as application protocols like HTTP.</p>
<h3 id="networking-workflow">Networking Workflow<a hidden class="anchor" aria-hidden="true" href="#networking-workflow">#</a></h3>
<center>
    <img style="width: 100%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/14_workflow.png" />
</center>
<figcaption class="img_footer">
    Fig. 19: OSI Workflow (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<p>Let&rsquo;s see how the data is move through the layer:</p>
<ul>
<li>
<ol>
<li>When a user sends an HTTP request to a webserver over the network, the HTTP header is added to the data at the application layer.</li>
</ol>
</li>
<li>
<ol start="2">
<li>A TCP header is added to the data. It encapsulated into TCP segments at the transport layer. The header contains the source port, destination port, and sequence number.</li>
</ol>
</li>
<li>
<ol start="3">
<li>The segments are then encapsulated with an IP header at the network layer. The IP header contains the source and destination IP addresses.</li>
</ol>
</li>
<li>
<ol start="4">
<li>A MAC header is added at the data link layer, with the source and destination MAC addresses. Here, the MAC addresses are the ones of routing devices, not the computer itself in reality.</li>
</ol>
</li>
<li>
<ol start="5">
<li>The encapsulated frames are sent over the network in raw bits in the physical layer.</li>
</ol>
</li>
<li>6-10. When the webserver receives the raw bits from the network, it reverses the process. The headers are removed layer-by-layer, and eventually, the webserver processes the HTTP request.</li>
</ul>
<h2 id="cdnhttpswwwyoutubecomwatchvri9np1lwzqwlistplcrmie5fdpsd0gvs500xeoewfystsmejfindex15"><a href="https://www.youtube.com/watch?v=RI9np1LWzqw&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=15">CDN</a><a hidden class="anchor" aria-hidden="true" href="#cdnhttpswwwyoutubecomwatchvri9np1lwzqwlistplcrmie5fdpsd0gvs500xeoewfystsmejfindex15">#</a></h2>
<p>Content delivery network (CDN) should be used whenever HTTP traffic is served. Fundamentally, a CDN brings content closer to the user. This improves the performance of a web service as perceived by the user. It is noted that performance is critical to user engagement and retentionn as a <em>0.1-second improvement</em> of mobile site speed increases conversion rates by 8.4% for retails sites and 10.1% for travel sites.</p>
<p>To bring the server closer to the users, CDN deploys servers at hundreds of locations all over the world. These server locations are called Point of Presence (PoP). A server inside the PoP is called edge server. Having many PoPs all over the world ensures that every user can reach a fast-edge server close to them.</p>
<h3 id="routings">Routings<a hidden class="anchor" aria-hidden="true" href="#routings">#</a></h3>
<p>Different CDNs, e.g. Amazon Cloudfront or Cloudflare, use different technologies to direct a user&rsquo;s request to the closest PoP. Two common ones are DNS-based routing and Anycast.</p>
<ul>
<li>With DNS-based routing, each PoP has its own IP address. When the user looks up the IP address for the CDN, DNS returns the IP address of the PoP closest to them.</li>
<li>With Anycast, all PoPs share the same IP address. When the request comes into the Anycast netowrk for that IP address, the network sends the request to the PoP that is closest to the requester.</li>
</ul>
<h3 id="edge-server--static-contents">Edge Server &amp; Static Contents<a hidden class="anchor" aria-hidden="true" href="#edge-server--static-contents">#</a></h3>
<p>Each edge server acts as a reverse proxy with a huge content cache. Static contents are cached on the edge server in this content cache. If a piece of content is in the cache, it could quickly returned to the user. Since the edge server only ask for a copy of the static content from the origin server if it is not in the cache. This greatly reduces the load and bandwidth requirements of the origin server cluster.</p>
<center>
    <img style="width: 80%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/15_cdn.png" />
</center>
<figcaption class="img_footer">
    Fig. 20: Edge Server and Static Contents (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<p>A modern CDN can also transform static content into more optimized formats.</p>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/15_static_contents_transformation.png" />
</center>
<figcaption class="img_footer">
    Fig. 21: Static Contents Optimization (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="performance">Performance<a hidden class="anchor" aria-hidden="true" href="#performance">#</a></h3>
<p>The edge server also serve an important role in the modern HTTP stack: All TLS connections terminate ath the edge server. TLS handshakes are expensive. The commonly used TLS versions like TLS 1.2 take several network round trips to establish. However, terminating the TLS connection at the edge will significantly reduce the latency for the user to establish an encrypted TCP connection. This is why modern sites send dynamic uncacheable HTTP content over the CDN (single-page website).</p>
<h3 id="security">Security<a hidden class="anchor" aria-hidden="true" href="#security">#</a></h3>
<p>All modern CDNs have huge network capacity at the edge. This is the key to provide effective DDoS protection against large-scale attacks by having the network with a capacity much larger than the attackers.</p>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/15_static_contents_transformation.png" />
</center>
<figcaption class="img_footer">
    Fig. 22: CDNs vs. DDoS (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="availability">Availability<a hidden class="anchor" aria-hidden="true" href="#availability">#</a></h3>
<p>The modern CDN improves availability as by nature, a CDN is higly distributed. By having copies of contents available in many PoPs, a CDN can withstand many more hardware failures than the origin servers.</p>
<h2 id="grpc">gRPC<a hidden class="anchor" aria-hidden="true" href="#grpc">#</a></h2>
<p>gRPC is an open-source remote procedure call framework created by Google in 2016. It&rsquo;s a rewritten software of Google&rsquo;s internal Remote Procedure Call (RPC).</p>
<p>RPC is a function call within a process to execute some code. A remote procedure call enables one machine to invoke some code on another machine  as if it is a local function call from a user&rsquo;s perspective.</p>
<p>gRPC is a popular implementation of RPC. Many organizations have adopted gRPC as the preferred RPC mechanism to connect a large number of microservices running within and across data centers.</p>
<h3 id="why-grpc-so-popular">Why gRPC so popular?<a hidden class="anchor" aria-hidden="true" href="#why-grpc-so-popular">#</a></h3>
<ul>
<li>gRPC has a large ecosystem for all languages. It&rsquo;s very easy to produce production ready and type-safe APIs that scale well. The core of this ecosystem is the use of Protocol Buffers as its data interchange format. Protocol Buffers is a language-agnostic nad platform-agnostic mechanism for encoding structured data. gRPC uses Protocol Buffers to encode and send data over the wire by default.
<ul>
<li>While gRPC could support other encoding formats like JSON, Protocol Buffers provide several advantages that make it the encoding format of choice for gRPC.</li>
<li>Protocol Buffers support strongly-typed schema definitions. The structure of the ata over the wire is defined in a proto file. Protocol Buffers provide broad tooling support to turn the schema defined in the proto file into data access classes for all popular programming languages.</li>
<li>A gRPC service is also defined in a proto file by specifying RPC method parameters and return types.</li>
<li>The same tooling is used to generate gRPC client and server code from the proto file. Developers use these generated classes in the client to make RPC calls and in the server to fulfill the RPC requests.</li>
<li>By supporting many programming languages, the client and server can independently choose the programming language and ecosystem best suited for their own particular use cases. This is not common for most other RPC frameworks.</li>
</ul>
</li>
<li>gRPC is also known for its high-performance out of the box with 2 factors.
<ul>
<li>First, Protocol Buffers is a very efficient binary encoding format. This is much faster than JSON.</li>
<li>Second, gRPC is built on top of HTTP/2 to provide a high-performance foundation at scale. The use of HTTP/2 brings many benefits (multiplexing, stream prioritization, binary protocol, server push). gRPC uses HTTP/2 streams which allows multiple streams of messages over a single long-lived TCP connection. This allows the gRPC framework to handle many concurrent RPC calls over a small number of TCP connections between clients and servers.</li>
</ul>
</li>
</ul>
<h3 id="workflow">Workflow<a hidden class="anchor" aria-hidden="true" href="#workflow">#</a></h3>
<center>
    <img style="width: 80%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/16_grpc.png" />
</center>
<figcaption class="img_footer">
    Fig. 23: gRPC Workflow Example (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<p>Let&rsquo;s walk through a flow from a gRPC client to a gRPC server.</p>
<ul>
<li>
<ol>
<li>When the Order Service make a gRPC call the the Payment Service, it invokes the client code generated by gRPC tooling at build time. This generated client code is called a <strong>client stub</strong>.</li>
</ol>
</li>
<li>
<ol start="2">
<li>gRPC encodes the data passed to the client stub into Protocol Buffers and sends it to the low-level transport layer.</li>
</ol>
</li>
<li>
<ol start="3">
<li>gRPC sends the data over the network as a stream of HTTP/2 data frames. Due to binary encoding and network optimization, gRPC is said to be 5 times fasters than JSON.</li>
</ol>
</li>
<li>4-6. The Payment Service receives the packets from the network, decodes them, and invokes the server application.</li>
<li>7-9. The result returned from the server application gets encoded into Protocol Buffers and sent to the transport layer.</li>
<li>10-13. The Order Service receives the packets, decodes them, and sends the result to the client application.</li>
</ul>
<h3 id="use-case">Use Case<a hidden class="anchor" aria-hidden="true" href="#use-case">#</a></h3>
<p>gRPC is known to be the inter-service communication mechanism of choice between microservices in the data centers. Its broad support for many programming languages allows services to choose their own language and developer ecosystems best suited for their own use cases.</p>
<h2 id="graphql">GraphQL<a hidden class="anchor" aria-hidden="true" href="#graphql">#</a></h2>
<p>GraphQL is a query language for API developed by Meta. It provides a schema of the data in the API and gives clients the power to ask for exactly what they need. GraphQL sits between the client and the backend services. It could aggregate multiple resource requests into a single query. It also supports mutations and subscriptions.</p>
<p>Mutations are GraphQL&rsquo;s way of applying data modifications to resources.</p>
<p>Subscriptions are GraphQL&rsquo;s way for clients to receive notifications on data modifications.</p>
<h3 id="graphql-vs-rest-similarity">GraphQL vs. REST: Similarity<a hidden class="anchor" aria-hidden="true" href="#graphql-vs-rest-similarity">#</a></h3>
<p>In practice, both GraphQL and REST send HTTP requests and receive HTTP responses.</p>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/17_graphql.png" />
</center>
<figcaption class="img_footer">
    Fig. 24: GraphQL vs REST (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<p>Let&rsquo;s look at a REST operation</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># rest</span>
</span></span><span class="line"><span class="cl">https://example.com/api/v3/products
</span></span><span class="line"><span class="cl">https://example.com/api/v3/user
</span></span></code></pre></div><p>REST centers around resources, and each resource is identified by an URL. To fetch a book from a bookstore API, it could look something like this</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;title&#34;</span>: <span class="s2">&#34;Harry Porter&#34;</span>,
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;authors&#34;</span>: <span class="o">[</span>
</span></span><span class="line"><span class="cl">        <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;J.K.Rowling&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>,
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    <span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>The end point will be <code>GET /book/123</code>.</p>
<p>Let&rsquo;s look at a REST operation</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># graphql query</span>
</span></span><span class="line"><span class="cl"><span class="nb">type</span> Query <span class="o">{</span>
</span></span><span class="line"><span class="cl">    book<span class="o">(</span>id: ID!<span class="o">)</span>: Book
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Here&rsquo;s what data transfer looks like for GraphQL</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nb">type</span> Book <span class="o">{</span>
</span></span><span class="line"><span class="cl">    id: ID
</span></span><span class="line"><span class="cl">    title: String 
</span></span><span class="line"><span class="cl">    authors: <span class="o">[</span>Author<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">type</span> Author <span class="o">{</span>
</span></span><span class="line"><span class="cl">    id: ID
</span></span><span class="line"><span class="cl">    name: String
</span></span><span class="line"><span class="cl">    books: <span class="o">[</span>Book<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>The end point will be <code>GET /graphql?query={ book(id: &quot;123&quot;) {title, authors {name}}}</code>.</p>
<p>As we can see, both REST and GraphQL make a request via an URL and both can return a JSON response in the same shape.</p>
<h3 id="graphql-vs-rest-difference">GraphQL vs. REST: Difference<a hidden class="anchor" aria-hidden="true" href="#graphql-vs-rest-difference">#</a></h3>
<p>With GraphQL, we specify the exact resources we want and also which fields we want. While in REST, the API implementer decided that authors are included as related resources (as example above). With GraphQL, the client decides what to include.</p>
<h3 id="pros--cons-of-graphql">Pros &amp; Cons of GraphQL<a hidden class="anchor" aria-hidden="true" href="#pros--cons-of-graphql">#</a></h3>
<p><strong>Pros</strong>:</p>
<ul>
<li>The main benefit of GraphQL is that it doesn&rsquo;t use URLs to specify the resources that are available in the API. Instead, it uses the GraphQL schema. This means that we can send a complex query that fetches additional data according to the
relationship defined in the schema.</li>
<li>Doing the same in REST is more complicated, as we have to do it client-side with multiple requests. This is a common problem resulting in N+1 queries.</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>For REST, we don&rsquo;t need special libraries to consume someone else&rsquo;s API. Requests can be sent using common tools like cURL or web browser.</li>
<li>In constrast, GraphQL requires heavier tooling support, both on client and server sides such as GraphQL, Apollo, <code>schema.graphql</code>, <code>codegen.yml</code>, <code>operation.graphql</code>. This cost in resources might not be worth it if the application is a simple CRUD APIs.</li>
<li>In addition, GraphQL is more difficult to cache. REST uses HTTP GET for fetching resources, and HTTP GET has a well-defined caching behavior that is leveraged by browsers, CDNs, proxies, and web servers.</li>
<li>In constrast, GraphQL has a single point of entry and uses HTTP POST by default. This prevents the full use of HTTP caching.</li>
<li>As GraphQL allows users to get the data they need, it is also a threat.</li>
</ul>
<h2 id="api-gateway">API Gateway<a hidden class="anchor" aria-hidden="true" href="#api-gateway">#</a></h2>
<p>An API gateway is a single point of entry to the clients of an application, it sits between the clients and a collection of backend services for the application. An API gateway provides several important functions:</p>
<ul>
<li>Authentication and Security Policy Enforcements.</li>
<li>Load Balancing and Circuit Breaking.</li>
<li>Protocol Translation and Service Discovery.</li>
<li>Monitoring, Logging, Analytics, and Billing.</li>
<li>Caching.</li>
</ul>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/18_api_gateway.png" />
</center>
<figcaption class="img_footer">
    Fig. 25: API Gateway (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<h3 id="workflow-1">Workflow<a hidden class="anchor" aria-hidden="true" href="#workflow-1">#</a></h3>
<ol>
<li>The client sends a request to the API gateway. The request is typically a HTTP-based. It could be REST, GraphQL, or higher-level abstractions.</li>
<li>The API gateway validates the HTTP request.</li>
<li>The API gateway checks the caller&rsquo;s IP address and other HTTP headers against its allow-list and deny-list. It could also perform basic rate limit checks against attributes such as IP address and HTTP headers. For example, it could reject requests from an IP address exceeding a certain rate.</li>
<li>The API gateway passes the request to an identity provider for authentication and authorization. The API gateway gets back from the provider with a scope of what the request is allowed to do.</li>
<li>A higher level rate-limit check is applied against the authenticated session. If it is over the lomit, the request is rejected at this point.
6-7. With the help of a service discovery component, the API gateway locates the appropriate backend service to handle the request by path matching.</li>
<li>The API gateway transform the requests into the appropriate protocol and sends the transformed request to the backend service. A protocol can be gRPC. When the response comes back from the backend service, the API gateway transforms the response back to the public-facing protocol and returns the response to the client.</li>
</ol>
<center>
    <img style="width: 50%" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/18_api_gateway_workflow.png" />
</center>
<figcaption class="img_footer">
    Fig. 26: API Gateway Workflow (Image source: 
    <a>ByteByteGo.com</a>).
</figcaption>
</br>
<p>API gateway should be deployed to multiple regions to improve availability.</p>
<h2 id="citation">Citation<a hidden class="anchor" aria-hidden="true" href="#citation">#</a></h2>
<p>Cited as:</p>
<blockquote>
    <summary>System Design Fundamentals Mega-Blog</summary>
    <summary>https://mnguyen0226.github.io/posts/system_design_concepts/post/</summary>
</blockquote>
<p>Or</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">@article<span class="o">{</span>nguyen2023sdmega,
</span></span><span class="line"><span class="cl">  <span class="nv">title</span>   <span class="o">=</span> <span class="s2">&#34;System Design Fundamentals Mega-Blog&#34;</span>,
</span></span><span class="line"><span class="cl">  <span class="nv">author</span>  <span class="o">=</span> <span class="s2">&#34;Nguyen, Minh&#34;</span>,
</span></span><span class="line"><span class="cl">  <span class="nv">journal</span> <span class="o">=</span> <span class="s2">&#34;mnguyen0226.github.io&#34;</span>,
</span></span><span class="line"><span class="cl">  <span class="nv">year</span>    <span class="o">=</span> <span class="s2">&#34;2023&#34;</span>,
</span></span><span class="line"><span class="cl">  <span class="nv">month</span>   <span class="o">=</span> <span class="s2">&#34;January&#34;</span>,
</span></span><span class="line"><span class="cl">  <span class="nv">url</span>     <span class="o">=</span> <span class="s2">&#34;https://mnguyen0226.github.io/posts/system_design_concepts/post/&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<p>[1] A. Xu, System Design Interview - An Insider’s Guide. Independently Published, 2020.
‌</p>
<p>[2] ByteByteGo, “10+ Key Memory &amp; Storage Systems: Crash Course System Design #5,” YouTube. Mar. 28, 2023. Accessed: Oct. 25, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=lX4CrbXMsNQ&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf">https://www.youtube.com/watch?v=lX4CrbXMsNQ&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf</a>
‌</p>
<p>[3] ByteByteGo, “Latency Numbers Programmer Should Know: Crash Course System Design #1,” YouTube. Oct. 04, 2022. Accessed: Oct. 31, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=FqR5vESuKe0&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=3">https://www.youtube.com/watch?v=FqR5vESuKe0&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=3</a>
‌</p>
<p>[4] ByteByteGo, “What Is REST API? Examples And How To Use It: Crash Course System Design #3,” YouTube. Aug. 24, 2022. Accessed: Oct. 31, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=-mN3VyJuCjM&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=4">https://www.youtube.com/watch?v=-mN3VyJuCjM&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=4</a>
‌</p>
<p>[5] ByteByteGo, “10 Key Data Structures We Use Every Day,” YouTube. May 01, 2023. Accessed: Oct. 31, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=ouipSd_5ivQ&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=5">https://www.youtube.com/watch?v=ouipSd_5ivQ&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=5</a>
‌</p>
<p>[6] ByteByteGo, “Cache Systems Every Developer Should Know,” YouTube. Apr. 04, 2023. Accessed: Oct. 31, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=dGAgxozNWFE&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=6">https://www.youtube.com/watch?v=dGAgxozNWFE&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=6</a>
‌</p>
<p>[7] ByteByteGo, “Top 5 Redis Use Cases,” YouTube. Feb. 16, 2023. Accessed: Oct. 31, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=a4yX7RUgTxI&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=10">https://www.youtube.com/watch?v=a4yX7RUgTxI&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=10</a>
‌</p>
<p>[8] ByteByteGo, “CI/CD In 5 Minutes | Is It Worth The Hassle: Crash Course System Design #2,” YouTube. Jan. 18, 2023. Accessed: Nov. 01, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=42UP1fxi2SY&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=11">https://www.youtube.com/watch?v=42UP1fxi2SY&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=11</a>
‌</p>
<p>[9] ByteByteGo, “Kubernetes Explained in 6 Minutes | k8s Architecture,” YouTube. Jan. 11, 2023. Accessed: Nov. 01, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=TlHvYWVUZyc&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=12">https://www.youtube.com/watch?v=TlHvYWVUZyc&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=12</a></p>
<p>[10] ByteByteGo, “CAP Theorem Simplified,” YouTube. Jan. 03, 2023. Accessed: Nov. 01, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=BHqjEjzAicA&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=13">https://www.youtube.com/watch?v=BHqjEjzAicA&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=13</a>
‌
‌</p>
<p>[11] ByteByteGo, “What is OSI Model | Real World Examples,” YouTube. Dec. 23, 2022. Accessed: Nov. 02, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=0y6FtKsg6J4&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=14">https://www.youtube.com/watch?v=0y6FtKsg6J4&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=14</a>
‌</p>
<p>[12] ByteByteGo, “What Is A CDN? How Does It Work?,” YouTube. Nov. 24, 2022. Accessed: Nov. 02, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=RI9np1LWzqw&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=15">https://www.youtube.com/watch?v=RI9np1LWzqw&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=15</a>
‌</p>
<p>[13] ByteByteGo, “What is RPC? gRPC Introduction.,” YouTube. Dec. 01, 2022. Accessed: Nov. 04, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=gnchfOojMk4&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=19&amp;ab_channel=ByteByteGo">https://www.youtube.com/watch?v=gnchfOojMk4&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=19&amp;ab_channel=ByteByteGo</a>
‌</p>
<p>[14] ByteByteGo, “What Is GraphQL? REST vs. GraphQL,” YouTube. Nov. 10, 2022. Accessed: Nov. 04, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=yWzKJPw_VzM&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=17&amp;ab_channel=ByteByteGo">https://www.youtube.com/watch?v=yWzKJPw_VzM&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=17&amp;ab_channel=ByteByteGo</a>
‌</p>
<p>[15] ByteByteGo, “What is API Gateway?,” YouTube. Nov. 01, 2022. Accessed: Nov. 07, 2023. [YouTube Video]. Available: <a href="https://www.youtube.com/watch?v=6ULyxuHKxg8&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=20">https://www.youtube.com/watch?v=6ULyxuHKxg8&amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf&amp;index=20</a>
‌</p>
<center>
    <img class="img_size" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/system_design_concepts/imgs/golden_bridge.png" />
</center>
<figcaption class="img_footer">
    Fig. 23: Golden Gate Bridge, San Francisco, U.S.A </br>(Image Source: 
    <a href="https://unsplash.com/photos/gZXx8lKAb7Y" class="img_footer">Maarten van den Heuvel @ Unsplash</a>).
</figcaption>
<!-- CSS Styling -->
<style>
.img_size {
  width: 100%;
}

.img_footer {
    color: #888888;
    text-align: center;
}
</style><blockquote>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mnguyen0226.github.io/tags/long-read/">long-read</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://mnguyen0226.github.io/posts/multitask_learning/post/">
    <span class="title">« Prev</span>
    <br>
    <span>Multi-Task Learning for Image Classification</span>
  </a>
  <a class="next" href="https://mnguyen0226.github.io/posts/java_fundamentals_4/post/">
    <span class="title">Next »</span>
    <br>
    <span>Java Fundamentals (Part 4)</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share System Design Fundamentals Mega-Blog on twitter"
        href="https://twitter.com/intent/tweet/?text=System%20Design%20Fundamentals%20Mega-Blog&amp;url=https%3a%2f%2fmnguyen0226.github.io%2fposts%2fsystem_design_concepts%2fpost%2f&amp;hashtags=long-read">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share System Design Fundamentals Mega-Blog on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmnguyen0226.github.io%2fposts%2fsystem_design_concepts%2fpost%2f&amp;title=System%20Design%20Fundamentals%20Mega-Blog&amp;summary=System%20Design%20Fundamentals%20Mega-Blog&amp;source=https%3a%2f%2fmnguyen0226.github.io%2fposts%2fsystem_design_concepts%2fpost%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share System Design Fundamentals Mega-Blog on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fmnguyen0226.github.io%2fposts%2fsystem_design_concepts%2fpost%2f&title=System%20Design%20Fundamentals%20Mega-Blog">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share System Design Fundamentals Mega-Blog on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmnguyen0226.github.io%2fposts%2fsystem_design_concepts%2fpost%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share System Design Fundamentals Mega-Blog on whatsapp"
        href="https://api.whatsapp.com/send?text=System%20Design%20Fundamentals%20Mega-Blog%20-%20https%3a%2f%2fmnguyen0226.github.io%2fposts%2fsystem_design_concepts%2fpost%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share System Design Fundamentals Mega-Blog on telegram"
        href="https://telegram.me/share/url?text=System%20Design%20Fundamentals%20Mega-Blog&amp;url=https%3a%2f%2fmnguyen0226.github.io%2fposts%2fsystem_design_concepts%2fpost%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://mnguyen0226.github.io/">Minh T. Nguyen</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
