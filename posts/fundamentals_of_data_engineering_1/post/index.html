<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Fundamentals of Data Engineering: Foundation and Building Blocks | Minh T. Nguyen</title>
<meta name="keywords" content="web development, long-read">
<meta name="description" content="[v.1.0] (01/05/2024): Post started!
1. Data Engineering Described What Is Data Engineering? A data engineer gets data, stores it, and prepares it for consumption by data scientists, analysts, and others.
Data engineering is the development, implementation, and maintenance of systems and processes that take in raw data and produce high-quality, consistent information that supports downstream use cases, such as analysis and machine learning. Data engineering is the intersection of security, data management, DataOps, data architecture, orchestration, and software engineering.">
<meta name="author" content="Minh T. Nguyen">
<link rel="canonical" href="https://mnguyen0226.github.io/posts/fundamentals_of_data_engineering_1/post/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mnguyen0226.github.io/favicon/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://mnguyen0226.github.io/favicon/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mnguyen0226.github.io/favicon/android-chrome-192x192.png">
<link rel="apple-touch-icon" href="https://mnguyen0226.github.io/favicon/android-chrome-192x192.png">
<link rel="mask-icon" href="https://mnguyen0226.github.io/favicon/android-chrome-192x192.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Fundamentals of Data Engineering: Foundation and Building Blocks" />
<meta property="og:description" content="[v.1.0] (01/05/2024): Post started!
1. Data Engineering Described What Is Data Engineering? A data engineer gets data, stores it, and prepares it for consumption by data scientists, analysts, and others.
Data engineering is the development, implementation, and maintenance of systems and processes that take in raw data and produce high-quality, consistent information that supports downstream use cases, such as analysis and machine learning. Data engineering is the intersection of security, data management, DataOps, data architecture, orchestration, and software engineering." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mnguyen0226.github.io/posts/fundamentals_of_data_engineering_1/post/" /><meta property="og:image" content="https://mnguyen0226.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-01-05T00:00:00+00:00" />
<meta property="og:see_also" content="https://mnguyen0226.github.io/posts/system_design_roadmap/post/" /><meta property="og:see_also" content="https://mnguyen0226.github.io/posts/profile_matching/post/" /><meta property="og:see_also" content="https://mnguyen0226.github.io/posts/system_design_concepts/post/" /><meta property="og:see_also" content="https://mnguyen0226.github.io/posts/web_dev_odin/post/" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://mnguyen0226.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="Fundamentals of Data Engineering: Foundation and Building Blocks"/>
<meta name="twitter:description" content="[v.1.0] (01/05/2024): Post started!
1. Data Engineering Described What Is Data Engineering? A data engineer gets data, stores it, and prepares it for consumption by data scientists, analysts, and others.
Data engineering is the development, implementation, and maintenance of systems and processes that take in raw data and produce high-quality, consistent information that supports downstream use cases, such as analysis and machine learning. Data engineering is the intersection of security, data management, DataOps, data architecture, orchestration, and software engineering."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://mnguyen0226.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Fundamentals of Data Engineering: Foundation and Building Blocks",
      "item": "https://mnguyen0226.github.io/posts/fundamentals_of_data_engineering_1/post/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Fundamentals of Data Engineering: Foundation and Building Blocks",
  "name": "Fundamentals of Data Engineering: Foundation and Building Blocks",
  "description": "[v.1.0] (01/05/2024): Post started!\n1. Data Engineering Described What Is Data Engineering? A data engineer gets data, stores it, and prepares it for consumption by data scientists, analysts, and others.\nData engineering is the development, implementation, and maintenance of systems and processes that take in raw data and produce high-quality, consistent information that supports downstream use cases, such as analysis and machine learning. Data engineering is the intersection of security, data management, DataOps, data architecture, orchestration, and software engineering.",
  "keywords": [
    "web development", "long-read"
  ],
  "articleBody": "[v.1.0] (01/05/2024): Post started!\n1. Data Engineering Described What Is Data Engineering? A data engineer gets data, stores it, and prepares it for consumption by data scientists, analysts, and others.\nData engineering is the development, implementation, and maintenance of systems and processes that take in raw data and produce high-quality, consistent information that supports downstream use cases, such as analysis and machine learning. Data engineering is the intersection of security, data management, DataOps, data architecture, orchestration, and software engineering. A data engineer manages the data engineering lifecycle, beginning with getting data from source systems and ending with serving data for use cases, such as analysis or machine learning.\nStage of data engineer lifecycle:\nGeneration Storage Ingestion Transformation Serving Fig. 1. Data Science Hierarchy of Needs 70%-80% o the time doing the bottom 3: gathering data, cleaning data, processing data. Data scientist aren’t typically trained to engineer production-grade data system.\nData from various sources \u003e Data engineering \u003e Data science and analytics\nData Engineering Skills and Activities Skillset of data engineering: security, data management, DataOps, data architecture, and software engineering.\nData engineer also care about: Cost, Agility, Scalibility, Simplicity, Reuse, Interoperability.\nData engineer typically does not directly build ML models, create reports or dashboards, perform data analysis, build KPI or develop software application.\nData Maturity \u0026 the Data Engineer:\nThe data maturity model has 3 stages: starting with data, scaling with data, and leading with data. Stage 1: Starting with data Here, data engineer is a generalist, do everything. Choose the right data architecture. Identify and audit data. Build a solid data foundationn for future data analyst and data scientist to generate reports and models that provide competitive values. Tips: Quick win create technical debts. Get out and talk to people. Avoid undifferentiate heavy lifetying. Don’t box yourself in with unncessary technical complexity. Use off-the-shelf, turnkey solutions wherever possible. Stage 2: Scaling with data Data engineer here is a specialist, focusing on data science life cycle. Tips: Establish formal data practices Create scalable and robust data architectures Adopt DevOps and DataOps practices Build systems that support ML. Continue to avoid undifferentiate heavy lifting and customize only when competitive advantage results. Tips: Any tech decisions should be driven by the value they will deliver to your customers. Main bottleneck or scaling is not technology by the data engineering team. Focus on solutions that are simple to deploy and manage to expand your team’s throughput. You will be tempted to frame yourself as technologist, a data genuis who deliver magical product. Shift your focus instead to pragmatic leadership and transition to next maturity stage. Make sure to communicate with other teams about the practical utility of data and teach the organization how to consume and leverage data. Stage 3: Leading with data The company is data-driven. The automated pipelines and system created by data engineers allow people in the team to self-service analytics and ML. Data engineer need to be more specialize Create automation for the seamless introduction and usage of new data. Focus on building custom tools and systems that leverage data as a competitive advantage. Focus on the “enterprisey” aspects of data, such as data management (including data governance and quality) and DataOps. Deploy tools that expose and disseminate data throughout the organization, including data catalogs, data lineage tools, and metadata management systems Collaborate efficiently with software engineers, ML engineers, analysts, and others. Create a community and environment where people can collaborate and speak openly, no matter theri role or position. Tips: Once organizations reach stage 3, they must constantly focus on maintenance and improvement or risk falling back to a lower stage. Technology distractions are a more significant danger here than in the other stages. There’s a temptation to pursue expensive hobby projects that don’t deliver value to the business. Utilize custom-built technology only where it provides a competitive advantage. The Background and Skills of Data Engineer\nData engineer must understand both data and technology. Data engineer must also understand the requirements of data consumers (data analysts and data scientists) and the broader implications o data across the org. Business Responsibilities\nKnow how to communicate with nontechnical and technical people. Pay close attention to organizational hierarchies, who reports to whom, how people interact. Observe! Understand how to scope and gather business and product requirements. Know what to build and ensure that your stakeholders agress with your assessments. Develop a sense of how data and technologuy decisions impact the business. Understand the cultural foundations of Agile, DevOps, and DataOps. Control cost. You will be successful when you can keep the cost low while providing outsized values. Know how to optimize for time to value, the total cost of ownership, and opportunity cost. Learn continuously. People who succeed in data are great at picking up new things while sharpening their fundamental knowledge.They’re also good at filtering, determining which new developments are most relevant to their work, which are still immature, and which are just fads. Stay abreast of the field and learn how to learn. Technical Responsibilities\nSQL: The most common interface for databases and data lakes. After briefly being sidelined by the need to write custom MapReduce code for big data processing, SQL (in various forms) has reemerged as the lingua franca of data. We believe that competent data engineers should be highly proficient in SQL Python: API, Pandas, NumPy, Airflow, Sklearn, Tensorflow, PyTorch, and PySpark. JVM (Java, Scala): Spark, Hive, Druid. Bash 2. The Data Engineering Lifecycle What Is the Data Engineering Lifecycle? Fig. 2. Components and undercurrents of the data engineering lifecycle We begin with the data engineering lifecycle by getting dat from source systems and storing it. Next we transform the data and then proceed to our central goal, serving data to analysts, data scientists, ML engineers, and others. In the middle stages, we store, ingest, and transform.\nGeneration: Source Systems\nA source system is the origin of data used in the data engineering lifecycle. For example, a source system coule be an IoT device, an application message queue, or a transactional database. Here, a data engineer consuumes data from a source system but doesn’t own or ccontrol the source system itself. Data engineer need to understand the way source systems work, the way they generate data, adn the frequency and velocity o data, and the variety of data they generate.\nEx 1: Application DB. Here, applications often consist of many small service/database pairs with microservices rather than a single monolith.\nEx 2: IoT swarms. Here, a fleet of devices (circles) sends data messages to a central collection system. IoT are sensors, smart devices,…\n[IMPORTANT] Evaluating source systems: key engineering considerations\nWhat are the essential characteristics o the data source? Is it an application? A swarm of IoT devices? How is ata persisted in the source system? Is data persisted long term, or is it temporary and quickly deleted\u003e At what rate is data generated? How many events per second? How many gigabytes per hour? What level of consistency can data engineers expect from the output data? If you are running data-quality checks against the output data, how often do data inconsistencies occurs - nulls where they aren’t expected, lousy formatting. How often do errors occur? Will the data contain duplicates? Will some data values arrive late, possibly much later than other messages produced simultaneously? What is the schema of the ingested data? Will data engineers need to join across several tables or even several systems to get a complete picture of the data? If schema changes (say, a new colum is added), how is this dealth with and communicated to downstream stakeholders? How frequently should data be pulled from the source system? For stateful systems (e.g., a database tracking customer account info), is data provided as periodic snapshots or update events from change data capture (CDC)? What is the logic for how changes are performed, and how are these tracked in the source database? Who / what is the data provider that will transmit the data for downstream consumption? Will reading from a data source impact its performance? Does the source system have upstream data dependencies? What are the characteristics of these upstream systems? Are data-quality checks in place to chekc for late or missing data? Storage\nEvaluating storage systems: Key engineering considerations. Here are questions to ask when choosing a storage system for a data warehouse, data lakehouse, database, or object storage: Is this storage solution compatible with the architectures’s required write and read speeds? Will storage create a bottleneck for downstream processes? Do you understand how this storage technology works? Are you utilizing the storage system optimally or committing unnatural acts? For instance, are you applying a high rate of random access updates in an object storage system? Will this storage system handle anticipated future scale? You should consider all capacity limits on the storage system: total available storage, read operation rate, write volume,… Will downstream users and processes be able to retrieve data in the required service-level agreement (SLA)? Are you capturing metadata about schema evolution, data flows, data lineage, and so forth? Metadata has significant impact on the utility of data. Metadata represents an investment in the future, dramatically enhancing discoverability and institutional knowledge to streamline future projects and architecture changes Is this a pure storage solution (sobject storage), or does it support complex query patterns (i.e. a cloud data warehouse)? Is the storage system schema-agnostic (object storage)? Flexible schema (Cassandra)? Enforced schema (cloud data warehouse)? How are you tracking master data, golden records data quality, and data lineage for data governance? How are you handling regulatory compliance and data sovereignty? For example, can uyou store your data in certain geographical locations but not others? Ingestion\nKey engineering considerations for the ingestion phase: When preparing to architect or build a system, here are some primary questions about the ingestion stage What are the use cases for the data I’m ingesting? Can I reuse this data rather than create multiple versions of the same dataset? Are the systems generating and ingesting this data reliably, and is the data available when I need it? What is the data destination after ingestion? How frequently will I need to access the data? In what volum will the data typpically arrive? What format is the data in? Can I downstream storage and transformation systems handle this format? Is the source data in good shape for immediate downstream use? If so, for how long, and what may cause it to be unusable? If the data is from a streaming source, does it need to be transformed before reaching its destination? Would an in-flight transformation be appropriate, where the data is transformed within a stream itself? Store\nKey considerations for batch vs stream ingestion If I ingest the data in real time, can downstream storage systems handle the rate of data flow? Do I need millisecond real-time data ingestion? Or would a micro-batch approach work, accumulating and ingesting data, say, every minute? What are my use cases for streaming ingestion? What specific benefits do I realize by implementing streaming? If I get data in real time, what actions can I take on that data that would be an improvement upon batch? Will my streaming-first approach cost more in terms of time, money, mainte‐ nance, downtime, and opportunity cost than simply doing batch? Are my streaming pipeline and system reliable and redundant if infrastructure fails? What tools are most appropriate for the use case? Should I use a managed service (Amazon Kinesis, Google Cloud Pub/Sub, Google Cloud Dataflow) or stand up my own instances of Kafka, Flink, Spark, Pulsar, etc.? If I do the latter, who will manage it? What are the costs and trade-offs? If I’m deploying an ML model, what benefits do I have with online predictions and possibly continuous training? Am I getting data from a live production instance? If so, what’s the impact of my ingestion process on this source system? Transformation\nKey considerations for the transformation phase What’s the cost and return on investment (ROI) of the transformation? What is the associated business value? Is the transformation as simple and self-isolated as possible? What business rules do the transformations support? Serving Data\nBusiness Intelligence: BI marshals collected data to describe a business’s past and current state. BI requires using business logic to process raw data. Operational Analytics: Operational analytics focuses on the fine-grained details of operations, promoting actions that a user of the reports can act upon immediately. Operational analytics could be a live view of inventory or real-time dashboarding of website or application health. Embedded Analytics: Businesses may be serving separate analytics and data to thousands or more customers. Each customer must see their data and only their data. An internal data-access error at a company would likely lead to a procedural review. A data leak between customers would be considered a massive breach of trust, leading to media attention and a significant loss of customers.\nMajor Undercurrents Across the Data Engineering Lifecycle Security\nGive users only the access they need to do their jobs today, nothing more. Knowledge of user and identiity access management (IAM) roles, policies, groups, network security, password policies, and encryption are good places to start. Data Management\nData governance engages people, processes, and technologies tio maximize data value across an organizationn while protecting data with appropriate securiyt controls. Discoverability: End users should have quick and reliable access to the data they need to do their job. They should know hwere the data comes from, how it relateds to other data, and what the data means Metadata is data about data and it underpins every section of the data engineering lifecycle. Data accounrability: means assigning an individual to govern a portion o data. The responsible person then coordinates the governance activities of other stakeholders. Data quality: is the optimization o data toward the desired state and orbits the question “What do you get compared with what you expected?”. Data modeling and design: is the process for converting data into a usable form. Data lineage: describes the recording of an audit trail of data through its lifecycle, tracking both the systems that process the data and the upstream data it depends on. Data integration and interoperability: is the process of integrating data across tools and processes. Data lifecycle management: First, data is increasingly stored in the cloud. This means we have pay-as-you-go storage costs instead of large up-front capital expenditures for an on-premises data lake. Second, privacy and data retention laws such as the GDPR and the CCPA require data engineers to actively manage data destruction to respect users’ “right to be forgotten.” Ethics and privacy: Data impacts people DataOps has 3 core technical elements: automation, monitoring and observability, and incident response.\nAutomation: allow data engineers to quickly deploy new product features and improvements to existing workflows. Observability and monitoring: monitoring, logging, alerting, and tracing. Incident response: using automation and observability capabilities to rapidly identify root causes of an incident and resove it as reliably and quickly as possible. [Important] Data Architecture\nA data engineer should first understand the needs of the business and gather requirements for new use case. Next, a data engineer needs to translate those requirements to design new ways to capture and serve data, balanced for cost and operational simplicity. This means knowing the trade-offs with design patterns, technologies, and tools in the source systems, ingestion, storage, transformation, and serving data. Orchestration\nOrchestration is the process of coordinating many jobs to run as quickly and efficiently as possible on the scheduled cadence. Apache Airflow is a schedulers, this is not accurate. A pure scheduler, is aware only of time; an orchestration engin builds in meta data on job dependencies, generally in form of DAG which can be run once or scheduled to run at a fixed interal of daily, weeekly, every hour, every five mins. Software Engineering\nCore data processing code: Whether in ingestion, transformation, or data serving, data engineers need to be highly proficient and productive in frameworks and languages such as Spark, SQL, or Beam; we reject the notion that SQL is not code. t’s also imperative that a data engineer understand proper code-testing methodologies, such as unit, regression, integration, end-to-end, and smoke. Development of OS frameworks. Streaming: Engineers must also write code to apply a variety of windowing methods. Windowing allows real-time systems to calculate valuable metrics such as trailing statistics. Engineers have many frameworks to choose from, including various function platforms (OpenFaaS, AWS Lambda, Google Cloud Func‐ tions) for handling individual events or dedicated stream processors (Spark, Beam, Flink, or Pulsar) for analyzing streams to support reporting and real-time actions. Infrastructure as code. Pipelines as code. General-purpose problem solving. 3. Designing Good Data Architecture Good data architecture provides seamless capabilities across every step of the data lifecycle and undercurrent. We will discuss about the components, batch patterns (data warehouses, data lakes), streaming patterns, and patterns that unify batch and streaming.\n[Important] What is Data Architecture? Successful data engineering is built upon rock-solid data architecture. We will review a few popular architecture approaches and frameworks.\nEnterprise Architecture Defined\nEnterprise architecture is the design of systems to support change in the enterprise, achieved by flexible and reversible decisions reached through careful evaluation of trade-off. Architects are not simply mapping out IT processes and vaguely looking toward a distant, utopian future. They actively solve business problems and create new opportunities. Technical solutions exist not for their own sake but in support of business goals. Architects identify problems in the current state (poor data quality, scalability limits, money-losing lines of business), define desired future states (agile data-quality improvement, scalable cloud data solutions, improved business processes), and realize initiatives through execution of small, concrete steps Data Architecture Defined\nData architecture is the design of systems to support the evolving data needs of an enterprise, achieved by flexible and reversible decisions reached through a careful evaluation of trade-offs. What business processes does the data serve? How does the organization manage data quality? What is the latency requirement from when the data is produced to when it becomes avaialble to query? How will you move 10TB of data every hour from a source database to your data lake. Data architecture = Operational + Technical Operational architecture describe what nees to be done. Technical architecture details how it will happen. “Good” Data Architecture\nGood data architecutre serves business requirements with a common, widely reusable set of building blocks while maintaining flexibility and making appropriate trade-off. Principles of Good Data Architecutre This is a 10000-foot view of good architecture, borrowed from AWS Well-Architected Framework andd Google Cloud’s Five Principles for Cloud-Native Architecture\nAWS Well-Architected Framework\nOperational excellence. Security. Reliability. Performance efficiency. Cost optimization. Sustainability. Google Cloud’s Five Principles for Cloud-Native Architecture\nDesign for automation. Be smart with state. Favor managed services. Practice defense in depth. Always be architecting. Additional principles:\nChoose common components wisely. Plan for failure. Architect for scalability. Architecture is leadership. Always be architecting. Build loosely coupled systems. Make reversible decisions. Prioritize security. Embrace FinOps. Principle 1: Choose Common Components Wisely\nCommon components can be anything that has broad applicability with an organization. Common components include object storage, version-control systems, observability, monitoring and orchestration systems, and processing engines. Principle 2: Plan for Failure\nAvailability: The percentage o time an IT service or component is in an operable state. Reliability: The system’s probability of meeting defined standards in performing its intended function during a specified intervals. Recovery time objective. Recovery point objective. Principle 3: Architect for Scalability\nScale up to handle significant quantities of data. Scale down to cut cost. Principle 4: Architecture Is Leadership\nData architects are responsible for technology decisions and architecture descriptions and disseminating these choices through effective leadership and tranining. An ideal data architect posses the technical skills of data enigneer but no longer practice data engineering day to day; they mentor curretn data engineers, make careful technology choice in consultation with their organization, and disseminate expertise through training and leadership. They train engineers in best practice and bring the company’s engineering resources together to pursue common goals in both technology and business. Principle 5: Always Be Architecting\nThe data architect maintains a target architecture and sequencing plans that change over time. The target architecture becomes a moving target, adjusted in response to business and technology changes internally and worldwide. Principle 6: Build Loosely Coupled Systems\nPutting data and services behind APIs enabled the loose coupling and eventually resulted in AWS as we know it now.\nFor software architecture, a loosely coupled system has the following properties:\nSystems are broken into many components. These systems interface with other services through abstraction layers, such as a messaging bus or an API. These abstraction layers hide and protect internal details of the service, such as a database backend or internal classes and method calls. As a consequence of property 2, internal changes to a system component don’t require changes in other parts. Details of code updates are hidden behind stable APIs. Each piece can evolve and improve separately. As a consequence of property 3, there is no waterfall, global release cycle for the whole system. Instead, each component is updated separately as changes and improvements are made. Organizational characteristics:\nMany small teams engineer a large, complex system. Each team is tasked with engineering, maintaining, and improving some system components. These teams publish the abstract details of their componentsd to other teams via API definitions, message schemas,… Teams need not concern themselves with other teams’ components; they simply use the published API or message specifications to call these components. They iterate their part to improve their performance and capabilities over time. They might also publish new capabilities as they are added or request new stuff from other teams. Again, the latter happens without teams needing to worry about the internal technical details of the requested features. Teams work together through loosely couple communication. As a consequence of 2, each team can rapidly evolve and improve its component independently of the work of other teams. Specifically, 3 implies that team can release updates to their components with minal downtime. Teams release continuosly during regular working hours to make code changes and test them. Principle 7: Make Reversible Decisions\nThe decoupling / modularization of tech across your data architecture - always strive to pick the best-of-breed solutions that work for today Principle 8: Prioritize Security\nEvery data engineer must assume responsibility for the security of the systems they build and maintain. We focus now on two main ideas: zero-trust security and the shared responsibility security model. These align closely to a cloud-native architecture. Principle 9: Embrace FinOps\nThe term “FinOps” typically refers to the emerging professional movement that advo‐ cates a collaborative working relationship between DevOps and Finance, resulting in an iterative, data-driven management of infrastructure spending (i.e., lowering the unit economics of cloud) while simultaneously increasing the cost efficiency and, ultimately, the profitability of the cloud environment. In the cloud era, most data systems are pay-as-you-go and readily scalable. Systems can run on a cost-per-query model, cost-per-processing-capacity model, or another variant of a pay-as-you-go model. Major Architecture Concepts Main goal of all architectures: to take data and transform it into something useful for downstream consumption. Domains and Services\nDomain is a real-world subject are for which are you architecting. Service is a set of functionality whose goal is to accomplish a task. Identify what should go in the domain. When determining what the domain should encompass and what services to include, the best advice is to simply go and talk with users and stakeholders, listen to what they’re saying, and build the services that will help them do their job. Avoid the classic trap of architecting in a vacuum. Distributed Systems, Scalability, and Designing for Failure\nScalability: Allows us to increase the capacity of a system to improve performance and handle the demand. Elasticity: The ability of a scalable system to scale dynamically; a highly elastic system can automatically scale up and down based on the current workload. Availability: The percentage of time an IT service or component is in an operable state. Reliability: The system’s probability of meeting defined standards in performing its intended function during a specified interval. Tight vs Loose Coupling: Tiers, Monoliths, and Microservices\nTightly coupled: Every part of a domain and service is vitally dependent upon every other domain and service. Loose coupling: you have decentralized domains and services that do not have strict dependence on each other. Microservices: architecture comprises separate, decentralized, and loosely coupled services Examples and Types of Data Architecture Data Warehouse\nA data warehouse is a central data hub used for reporting and analysis. Who’s Involved with Designing a Data Architecture? Data architecture isn’t designed in a vacuum. Bigger companies may still employ data architects, but those architects will need to be heavily in tune and current with the state of technology and data.\nIdeally, a data engineer will work alongside a dedicated data architect. However, if a company is small or low in its level of data maturity, a data engineer might work double duty as an architect. Because data architecture is an undercurrent of the data engineering lifecycle, a data engineer should understand “good” architecture and the various types of data architecture.\n4. Choosing Technologies Across the Data Engineer Life Cycle Team Size and Capabilities There is a continuum of simple to complex technologies, and a team’s size roughly determines the amount of bandwidth your team can dedicate to complex solutions.\nSpeed to Market In technology, speed to market wins. This means choosing the right technologies that help you deliver features and data faster while maintaining high-quality standards and security. It also means working in a tight feedback loop of launching, learning, iterating, and making improvements.\nDeliver value early and often.\nInteroperability When choosing a technology or system, you’ll need to ensure that it interacts and operates with other technologies. Interoperability describes how various technologies or systems connect, exchange information, and interact.\nCost Optimization and Business Value In a perfect world, you’d get to experiment with all the latest, coolest technologies without considering cost, time investment, or value added to the business. In reality, budgets and time are finite, and the cost is a major constraint for choosing the right data architectures and technologies.\nData engineers need to be pragmatic about flexibility. The data landscape is changing too quickly to invest in long-term hardware that inevitably goes stale, can’t easily scale, and potentially hampers a data engineer’s flexibility to try new things. Given the upside for flexibility and low initial costs, we urge data engineers to take an opex-first approach centered on the cloud and flexible, pay-as-you-go technologies.\nToday vs. Future: Immutable Vs. Transitory Technology In an exciting domain like data engineering, it’s all too easy to focus on a rapidly evolving future while ignoring the concrete needs of the present. The intention to build a better future is noble but often leads to overarchitecting and overengineering. Tooling chosen for the future may be stale and out-of-date when this future arrives; the future frequently looks little like what we envisioned years before.\nGiven the reasonable probability of failure for many data technologies, you need to consider how easy it is to transition from a chosen technology. What are the barriers to leaving? As mentioned previously in our discussion about opportunity cost, avoid “bear traps.” Go into a new technology with eyes wide open, knowing the project might get abandoned, the company may not be viable, or the technology simply isn’t a good fit any longer.\nLocation Companies now have numerous options when deciding where to run their technol‐ ogy stacks. A slow shift toward the cloud culminates in a veritable stampede of companies spinning up workloads on AWS, Azure, and Google Cloud Platform (GCP).\nBuild vs Buy Build versus buy is an age-old debate in technology. The argument for building is that you have end-to-end control over the solution and are not at the mercy of a vendor or open source community. The argument supporting buying comes down to resource constraints and expertise; do you have the expertise to build a better solution than something already available.\nMonolith Vs. Modular Monoliths versus modular systems is another longtime debate in the software archi‐ tecture space. Monolithic systems are self-contained, often performing multiple func‐ tions under a single system.\nServerless vs. Servers A big trend for cloud providers is serverless, allowing developers and data engineers to run applications without managing servers behind the scenes. Serverless provides a quick time to value for the right use cases. For other cases, it might not be a good fit.\nUndercurrents and Their Impacts on Choosing Technologies As seen in this chapter, a data engineer has a lot to consider when evaluating technol‐ ogies. Whatever technology you choose, be sure to understand how it supports the undercurrents of the data engineering lifecycle.\nCitation Cited as:\nFundamentals of Data Engineering: Foundation and Building Blocks https://mnguyen0226.github.io/posts/fundamentals_of_data_engineering_1/post/. Or\n@article{nguyen2023mtl, title = \"Fundamentals of Data Engineering: Foundation and Building Blocks\", author = \"Nguyen, Minh\", journal = \"mnguyen0226.github.io\", year = \"2024\", month = \"January\", url = \"https://mnguyen0226.github.io/posts/fundamentals_of_data_engineering_1/post/\" } References Fig. 3: Golden Gate Bridge, San Francisco, U.S.A (Image Source: Maarten van den Heuvel @ Unsplash). ",
  "wordCount" : "4863",
  "inLanguage": "en",
  "datePublished": "2024-01-05T00:00:00Z",
  "dateModified": "2024-01-05T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Minh T. Nguyen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mnguyen0226.github.io/posts/fundamentals_of_data_engineering_1/post/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Minh T. Nguyen",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mnguyen0226.github.io/favicon/android-chrome-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mnguyen0226.github.io/" accesskey="h" title="Minh T. Nguyen (Alt + H)">Minh T. Nguyen</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mnguyen0226.github.io/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://mnguyen0226.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://mnguyen0226.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://mnguyen0226.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://mnguyen0226.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://mnguyen0226.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mnguyen0226.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://mnguyen0226.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Fundamentals of Data Engineering: Foundation and Building Blocks
    </h1>
    <div class="post-meta"><span title='2024-01-05 00:00:00 +0000 UTC'>January 5, 2024</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;Minh T. Nguyen

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-data-engineering-described" aria-label="1. Data Engineering Described">1. Data Engineering Described</a><ul>
                        
                <li>
                    <a href="#what-is-data-engineering" aria-label="What Is Data Engineering?">What Is Data Engineering?</a></li>
                <li>
                    <a href="#data-engineering-skills-and-activities" aria-label="Data Engineering Skills and Activities">Data Engineering Skills and Activities</a></li></ul>
                </li>
                <li>
                    <a href="#2-the-data-engineering-lifecycle" aria-label="2. The Data Engineering Lifecycle">2. The Data Engineering Lifecycle</a><ul>
                        
                <li>
                    <a href="#what-is-the-data-engineering-lifecycle" aria-label="What Is the Data Engineering Lifecycle?">What Is the Data Engineering Lifecycle?</a></li>
                <li>
                    <a href="#major-undercurrents-across-the-data-engineering-lifecycle" aria-label="Major Undercurrents Across the Data Engineering Lifecycle">Major Undercurrents Across the Data Engineering Lifecycle</a></li></ul>
                </li>
                <li>
                    <a href="#3-designing-good-data-architecture" aria-label="3. Designing Good Data Architecture">3. Designing Good Data Architecture</a><ul>
                        
                <li>
                    <a href="#important-what-is-data-architecture" aria-label="[Important] What is Data Architecture?">[Important] What is Data Architecture?</a></li>
                <li>
                    <a href="#principles-of-good-data-architecutre" aria-label="Principles of Good Data Architecutre">Principles of Good Data Architecutre</a></li>
                <li>
                    <a href="#major-architecture-concepts" aria-label="Major Architecture Concepts">Major Architecture Concepts</a></li>
                <li>
                    <a href="#examples-and-types-of-data-architecture" aria-label="Examples and Types of Data Architecture">Examples and Types of Data Architecture</a></li>
                <li>
                    <a href="#whos-involved-with-designing-a-data-architecture" aria-label="Who&amp;rsquo;s Involved with Designing a Data Architecture?">Who&rsquo;s Involved with Designing a Data Architecture?</a></li></ul>
                </li>
                <li>
                    <a href="#4-choosing-technologies-across-the-data-engineer-life-cycle" aria-label="4. Choosing Technologies Across the Data Engineer Life Cycle">4. Choosing Technologies Across the Data Engineer Life Cycle</a><ul>
                        
                <li>
                    <a href="#team-size-and-capabilities" aria-label="Team Size and Capabilities">Team Size and Capabilities</a></li>
                <li>
                    <a href="#speed-to-market" aria-label="Speed to Market">Speed to Market</a></li>
                <li>
                    <a href="#interoperability" aria-label="Interoperability">Interoperability</a></li>
                <li>
                    <a href="#cost-optimization-and-business-value" aria-label="Cost Optimization and Business Value">Cost Optimization and Business Value</a></li>
                <li>
                    <a href="#today-vs-future-immutable-vs-transitory-technology" aria-label="Today vs. Future: Immutable Vs. Transitory Technology">Today vs. Future: Immutable Vs. Transitory Technology</a></li>
                <li>
                    <a href="#location" aria-label="Location">Location</a></li>
                <li>
                    <a href="#build-vs-buy" aria-label="Build vs Buy">Build vs Buy</a></li>
                <li>
                    <a href="#monolith-vs-modular" aria-label="Monolith Vs. Modular">Monolith Vs. Modular</a></li>
                <li>
                    <a href="#serverless-vs-servers" aria-label="Serverless vs. Servers">Serverless vs. Servers</a></li>
                <li>
                    <a href="#undercurrents-and-their-impacts-on-choosing-technologies" aria-label="Undercurrents and Their Impacts on Choosing Technologies">Undercurrents and Their Impacts on Choosing Technologies</a></li></ul>
                </li>
                <li>
                    <a href="#citation" aria-label="Citation">Citation</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p style="color: #286EE0"><strong>[v.1.0] (01/05/2024):</strong> Post started!</p>
<h2 id="1-data-engineering-described">1. Data Engineering Described<a hidden class="anchor" aria-hidden="true" href="#1-data-engineering-described">#</a></h2>
<h3 id="what-is-data-engineering">What Is Data Engineering?<a hidden class="anchor" aria-hidden="true" href="#what-is-data-engineering">#</a></h3>
<p>A data engineer gets data, stores it, and prepares it for consumption by data scientists, analysts, and others.</p>
<p>Data engineering is the development, implementation, and maintenance of systems and processes that take in raw data and produce high-quality, consistent information that supports downstream use cases, such as analysis and machine learning. Data engineering is the intersection of security, data management, DataOps, data architecture, orchestration, and software engineering. A data engineer manages the data engineering lifecycle, beginning with getting data from source systems and ending with serving data for use cases, such as analysis or machine learning.</p>
<p>Stage of data engineer lifecycle:</p>
<ul>
<li>Generation</li>
<li>Storage</li>
<li>Ingestion</li>
<li>Transformation</li>
<li>Serving</li>
</ul>
<center>
    <img class="img_size" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/fundamentals_of_data_engineering_1/imgs/data_science_needs.png" />
</center>
<figcaption class="img_footer">
    Fig. 1. Data Science Hierarchy of Needs </br>
</figcaption>
<p>70%-80% o the time doing the bottom 3: gathering data, cleaning data, processing data. Data scientist aren&rsquo;t typically trained to engineer production-grade data system.</p>
<p>Data from various sources &gt; Data engineering &gt; Data science and analytics</p>
<h3 id="data-engineering-skills-and-activities">Data Engineering Skills and Activities<a hidden class="anchor" aria-hidden="true" href="#data-engineering-skills-and-activities">#</a></h3>
<p>Skillset of data engineering: security, data management, DataOps, data architecture, and software engineering.</p>
<p>Data engineer also care about: Cost, Agility, Scalibility, Simplicity, Reuse, Interoperability.</p>
<p>Data engineer typically does not directly build ML models, create reports or dashboards, perform data analysis, build KPI or develop software application.</p>
<p><strong>Data Maturity &amp; the Data Engineer</strong>:</p>
<ul>
<li>The data maturity model has 3 stages: starting with data, scaling with data, and leading with data.</li>
<li><strong>Stage 1</strong>: Starting with data
<ul>
<li>Here, data engineer is a generalist, do everything.</li>
<li>Choose the right data architecture.</li>
<li>Identify and audit data.</li>
<li>Build a solid data foundationn for future data analyst and data scientist to generate reports and models that provide competitive values.</li>
<li>Tips:
<ul>
<li>Quick win create technical debts.</li>
<li>Get out and talk to people.</li>
<li>Avoid undifferentiate heavy lifetying. Don&rsquo;t box yourself in with unncessary technical complexity. Use off-the-shelf, turnkey solutions wherever possible.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Stage 2</strong>: Scaling with data
<ul>
<li>Data engineer here is a specialist, focusing on data science life cycle.</li>
<li>Tips:
<ul>
<li>Establish formal data practices</li>
<li>Create scalable and robust data architectures</li>
<li>Adopt DevOps and DataOps practices</li>
<li>Build systems that support ML.</li>
<li>Continue to avoid undifferentiate heavy lifting and customize only when competitive advantage results.</li>
</ul>
</li>
<li>Tips:
<ul>
<li>Any tech decisions should be driven by the value they will deliver to your customers.</li>
<li>Main bottleneck or scaling is not technology by the data engineering team. Focus on solutions that are simple to deploy and manage to expand your team&rsquo;s throughput.</li>
<li>You will be tempted to frame yourself as technologist, a data genuis who deliver magical product. Shift your focus instead to pragmatic leadership and transition to next maturity stage. Make sure to communicate with other teams about the practical utility of data and teach the organization how to consume and leverage data.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Stage 3</strong>: Leading with data
<ul>
<li>The company is data-driven. The automated pipelines and system created by data engineers allow people in the team to self-service analytics and ML.</li>
<li>Data engineer need to be more specialize
<ul>
<li>Create automation for the seamless introduction and usage of new data.</li>
<li>Focus on building custom tools and systems that leverage data as a competitive advantage.</li>
<li>Focus on the “enterprisey” aspects of data, such as data management (including data governance and quality) and DataOps.</li>
<li>Deploy tools that expose and disseminate data throughout the organization, including data catalogs, data lineage tools, and metadata management systems</li>
<li>Collaborate efficiently with software engineers, ML engineers, analysts, and others.</li>
<li>Create a community and environment where people can collaborate and speak openly, no matter theri role or position.</li>
</ul>
</li>
<li>Tips:
<ul>
<li>Once organizations reach stage 3, they must constantly focus on maintenance and improvement or risk falling back to a lower stage.</li>
<li>Technology distractions are a more significant danger here than in the other stages. There’s a temptation to pursue expensive hobby projects that don’t deliver value to the business. Utilize custom-built technology only where it provides a competitive advantage.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>The Background and Skills of Data Engineer</strong></p>
<ul>
<li>Data engineer must understand both data and technology. Data engineer must also understand the requirements of data consumers (data analysts and data scientists) and the broader implications o data across the org.</li>
</ul>
<p><strong>Business Responsibilities</strong></p>
<ul>
<li>Know how to communicate with nontechnical and technical people. Pay close attention to organizational hierarchies, who reports to whom, how people interact. Observe!</li>
<li>Understand how to scope and gather business and product requirements. Know what to build and ensure that your stakeholders agress with your assessments. Develop a sense of how data and technologuy decisions impact the business.</li>
<li>Understand the cultural foundations of Agile, DevOps, and DataOps.</li>
<li>Control cost. You will be successful when you can keep the cost low while providing outsized values. Know how to optimize for time to value, the total cost of ownership, and opportunity cost.</li>
<li>Learn continuously. People who succeed in data are great at picking up new things while sharpening their fundamental knowledge.They’re also good at filtering, determining which new developments are most relevant to their work, which are still immature, and which are just fads. Stay abreast of the field and learn how to learn.</li>
</ul>
<p><strong>Technical Responsibilities</strong></p>
<ul>
<li>SQL: The most common interface for databases and data lakes. After briefly being sidelined by the need to write custom MapReduce code for big data processing, SQL (in various forms) has reemerged as the lingua franca of data.
<ul>
<li>We believe that competent data engineers should be
highly proficient in SQL</li>
</ul>
</li>
<li>Python: API, Pandas, NumPy, Airflow, Sklearn, Tensorflow, PyTorch, and PySpark.</li>
<li>JVM (Java, Scala): Spark, Hive, Druid.</li>
<li>Bash</li>
</ul>
<h2 id="2-the-data-engineering-lifecycle">2. The Data Engineering Lifecycle<a hidden class="anchor" aria-hidden="true" href="#2-the-data-engineering-lifecycle">#</a></h2>
<h3 id="what-is-the-data-engineering-lifecycle">What Is the Data Engineering Lifecycle?<a hidden class="anchor" aria-hidden="true" href="#what-is-the-data-engineering-lifecycle">#</a></h3>
<center>
    <img class="img_size" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/fundamentals_of_data_engineering_1/imgs/del.png" />
</center>
<figcaption class="img_footer">
    Fig. 2. Components and undercurrents of the data engineering lifecycle </br>
</figcaption>
<p>We begin with the data engineering lifecycle by getting dat from source systems and storing it. Next we transform the data and then proceed to our central goal, serving data to analysts, data scientists, ML engineers, and others. In the middle stages, we store, ingest, and transform.</p>
<p><strong>Generation: Source Systems</strong></p>
<ul>
<li>
<p>A source system is the origin of data used in the data engineering lifecycle. For example, a source system coule be an IoT device, an application message queue, or a transactional database. Here, a data engineer consuumes data from a source system but doesn&rsquo;t own or ccontrol the source system itself. Data engineer need to understand the way source systems work, the way they generate data, adn the frequency and velocity o data, and the variety of data they generate.</p>
</li>
<li>
<p>Ex 1: Application DB. Here, applications often consist of many small service/database pairs with microservices rather than a single monolith.</p>
</li>
<li>
<p>Ex 2: IoT swarms. Here, a fleet of devices (circles) sends data messages to a central collection system. IoT are sensors, smart devices,&hellip;</p>
</li>
<li>
<p><strong>[IMPORTANT] Evaluating source systems: key engineering considerations</strong></p>
<ul>
<li>What are the essential characteristics o the data source? Is it an application? A swarm of IoT devices?</li>
<li>How is ata persisted in the source system? Is data persisted long term, or is it temporary and quickly deleted&gt;</li>
<li>At what rate is data generated? How many events per second? How many gigabytes per hour?</li>
<li>What level of consistency can data engineers expect from the output data? If you are running data-quality checks against the output data, how often do data inconsistencies occurs - nulls where they aren&rsquo;t expected, lousy formatting.</li>
<li>How often do errors occur?</li>
<li>Will the data contain duplicates?</li>
<li>Will some data values arrive late, possibly much later than other messages produced simultaneously?</li>
<li>What is the schema of the ingested data? Will data engineers need to join across several tables or even several systems to get a complete picture of the data?</li>
<li>If schema changes (say, a new colum is added), how is this dealth with and communicated to downstream stakeholders?</li>
<li>How frequently should data be pulled from the source system?</li>
<li>For stateful systems (e.g., a database tracking customer account info), is data provided as periodic snapshots or update events from change data capture (CDC)? What is the logic for how changes are performed, and how are these tracked in the source database?</li>
<li>Who / what is the data provider that will transmit the data for downstream consumption?</li>
<li>Will reading from a data source impact its performance?</li>
<li>Does the source system have upstream data dependencies? What are the characteristics of these upstream systems?</li>
<li>Are data-quality checks in place to chekc for late or missing data?</li>
</ul>
</li>
</ul>
<p><strong>Storage</strong></p>
<ul>
<li><strong>Evaluating storage systems: Key engineering considerations</strong>. Here are questions to ask when choosing a storage system for a data warehouse, data lakehouse, database, or object storage:
<ul>
<li>Is this storage solution compatible with the architectures&rsquo;s required write and read speeds?</li>
<li>Will storage create a bottleneck for downstream processes?</li>
<li>Do you understand how this storage technology works? Are you utilizing the storage system optimally or committing unnatural acts? For instance, are you applying a high rate of random access updates in an object storage system?</li>
<li>Will this storage system handle anticipated future scale? You should consider all capacity limits on the storage system: total available storage, read operation rate, write volume,&hellip;</li>
<li>Will downstream users and processes be able to retrieve data in the required service-level agreement (SLA)?</li>
<li>Are you capturing metadata about schema evolution, data flows, data lineage, and so forth? Metadata has significant impact on the utility of data. Metadata represents an investment in the future, dramatically enhancing discoverability and institutional knowledge to streamline future projects and architecture changes</li>
<li>Is this a pure storage solution (sobject storage), or does it support complex query patterns (i.e. a cloud data warehouse)?</li>
<li>Is the storage system schema-agnostic (object storage)? Flexible schema (Cassandra)? Enforced schema (cloud data warehouse)?</li>
<li>How are you tracking master data, golden records data quality, and data lineage for data governance?</li>
<li>How are you handling regulatory compliance and data sovereignty? For example, can uyou store your data in certain geographical locations but not others?</li>
</ul>
</li>
</ul>
<p><strong>Ingestion</strong></p>
<ul>
<li><strong>Key engineering considerations for the ingestion phase</strong>: When preparing to architect or build a system, here are some primary questions about the ingestion stage
<ul>
<li>What are the use cases for the data I&rsquo;m ingesting? Can I reuse this data rather than create multiple versions of the same dataset?</li>
<li>Are the systems generating and ingesting this data reliably, and is the data available when I need it?</li>
<li>What is the data destination after ingestion?</li>
<li>How frequently will I need to access the data?</li>
<li>In what volum will the data typpically arrive?</li>
<li>What format is the data in? Can I downstream storage and transformation systems handle this format?</li>
<li>Is the source data in good shape for immediate downstream use? If so, for how long, and what may cause it to be unusable?</li>
<li>If the data is from a streaming source, does it need to be transformed before reaching its destination? Would an in-flight transformation be appropriate, where the data is transformed within a stream itself?</li>
</ul>
</li>
</ul>
<p><strong>Store</strong></p>
<ul>
<li><strong>Key considerations for batch vs stream ingestion</strong>
<ul>
<li>If I ingest the data in real time, can downstream storage systems handle the rate of data flow?</li>
<li>Do I need millisecond real-time data ingestion? Or would a micro-batch
approach work, accumulating and ingesting data, say, every minute?</li>
<li>What are my use cases for streaming ingestion? What specific benefits do I
realize by implementing streaming? If I get data in real time, what actions can I take on that data that would be an improvement upon batch?</li>
<li>Will my streaming-first approach cost more in terms of time, money, mainte‐
nance, downtime, and opportunity cost than simply doing batch?</li>
<li>Are my streaming pipeline and system reliable and redundant if infrastructure fails?</li>
<li>What tools are most appropriate for the use case? Should I use a managed service (Amazon Kinesis, Google Cloud Pub/Sub, Google Cloud Dataflow) or stand up my own instances of Kafka, Flink, Spark, Pulsar, etc.? If I do the latter, who will manage it? What are the costs and trade-offs?</li>
<li>If I’m deploying an ML model, what benefits do I have with online predictions and possibly continuous training?</li>
<li>Am I getting data from a live production instance? If so, what’s the impact of my ingestion process on this source system?</li>
</ul>
</li>
</ul>
<p><strong>Transformation</strong></p>
<ul>
<li><strong>Key considerations for the transformation phase</strong>
<ul>
<li>What’s the cost and return on investment (ROI) of the transformation? What is the associated business value?</li>
<li>Is the transformation as simple and self-isolated as possible?</li>
<li>What business rules do the transformations support?</li>
</ul>
</li>
</ul>
<p><strong>Serving Data</strong></p>
<ul>
<li>Business Intelligence: BI marshals collected data to describe a business’s past and current state. BI requires using business logic to process raw data.</li>
<li>Operational Analytics: Operational analytics focuses on the fine-grained details of operations, promoting actions that a user of the reports can act upon immediately. Operational analytics could be a live view of inventory or real-time dashboarding of website or application health.</li>
</ul>
<p><strong>Embedded Analytics</strong>: Businesses may be serving separate analytics and data to thousands or more customers. Each customer must see their data and only their data. An internal data-access error at a company would likely lead to a procedural review. A data leak between customers would be considered a massive breach of trust, leading to media attention and a significant loss of customers.</p>
<h3 id="major-undercurrents-across-the-data-engineering-lifecycle">Major Undercurrents Across the Data Engineering Lifecycle<a hidden class="anchor" aria-hidden="true" href="#major-undercurrents-across-the-data-engineering-lifecycle">#</a></h3>
<p><strong>Security</strong></p>
<ul>
<li>Give users only the access they need to do their jobs today, nothing more.</li>
<li>Knowledge of user and identiity access management (IAM) roles, policies, groups, network security, password policies, and encryption are good places to start.</li>
</ul>
<p><strong>Data Management</strong></p>
<ul>
<li>Data governance engages people, processes, and technologies tio maximize data value across an organizationn while protecting data with appropriate securiyt controls.</li>
<li>Discoverability: End users should have quick and reliable access to the data they need to do their job. They should know hwere the data comes from, how it relateds to other data, and what the data means</li>
<li>Metadata is data about data and it underpins every section of the data engineering lifecycle.</li>
<li>Data accounrability: means assigning an individual to govern a portion o data. The responsible person then coordinates the governance activities of other stakeholders.</li>
<li>Data quality: is the optimization o data toward the desired state and orbits the question &ldquo;What do you get compared with what you expected?&rdquo;.</li>
<li>Data modeling and design: is the process for converting data into a usable form.</li>
<li>Data lineage: describes the recording of an audit trail of data through its lifecycle, tracking both the systems that process the data and the upstream data it depends on.</li>
<li>Data integration and interoperability: is the process of integrating data across tools and processes.</li>
<li>Data lifecycle management: First, data is increasingly stored in the cloud. This means we have pay-as-you-go storage costs instead of large up-front capital expenditures for an on-premises data lake. Second, privacy and data retention laws such as the GDPR and the CCPA require data engineers to actively manage data destruction to respect users’ “right to be forgotten.”</li>
<li>Ethics and privacy: Data impacts people</li>
</ul>
<p><strong>DataOps</strong> has 3 core technical elements: automation, monitoring and observability, and incident response.</p>
<ul>
<li>Automation: allow data engineers to quickly deploy new product features and improvements to existing workflows.</li>
<li>Observability and monitoring: monitoring, logging, alerting, and tracing.</li>
<li>Incident response: using automation and observability capabilities to rapidly identify root causes of an incident and resove it as reliably and quickly as possible.</li>
</ul>
<p><strong>[Important] Data Architecture</strong></p>
<ul>
<li>A data engineer should first understand the needs of the business and gather requirements for new use case.</li>
<li>Next, a data engineer needs to translate those requirements to design new ways to capture and serve data, balanced for cost and operational simplicity. This means knowing the trade-offs with design patterns, technologies, and tools in the source systems, ingestion, storage, transformation, and serving data.</li>
</ul>
<p><strong>Orchestration</strong></p>
<ul>
<li>Orchestration is the process of coordinating many jobs to run as quickly and efficiently as possible on the scheduled cadence. Apache Airflow is a schedulers, this is not accurate. A pure scheduler, is aware only of time; an orchestration engin builds in meta data on job dependencies, generally in form of DAG which can be run once or scheduled to run at a fixed interal of daily, weeekly, every hour, every five mins.</li>
</ul>
<p><strong>Software Engineering</strong></p>
<ul>
<li>Core data processing code: Whether in ingestion, transformation, or data serving, data engineers need to be highly proficient and productive in frameworks and languages such as Spark, SQL, or Beam; we reject the notion that SQL is not code. t’s also imperative that a data engineer understand proper code-testing methodologies, such as unit, regression, integration, end-to-end, and smoke.</li>
<li>Development of OS frameworks.</li>
<li>Streaming: Engineers must also write code to apply a variety of windowing methods. Windowing allows real-time systems to calculate valuable metrics such as trailing statistics. Engineers have many frameworks to choose from, including various function platforms (OpenFaaS, AWS Lambda, Google Cloud Func‐
tions) for handling individual events or dedicated stream processors (Spark, Beam, Flink, or Pulsar) for analyzing streams to support reporting and real-time actions.</li>
<li>Infrastructure as code.</li>
<li>Pipelines as code.</li>
<li>General-purpose problem solving.</li>
</ul>
<h2 id="3-designing-good-data-architecture">3. Designing Good Data Architecture<a hidden class="anchor" aria-hidden="true" href="#3-designing-good-data-architecture">#</a></h2>
<p>Good data architecture provides seamless capabilities across every step of the data lifecycle and undercurrent. We will discuss about the components, batch patterns (data warehouses, data lakes), streaming patterns, and patterns that unify batch and streaming.</p>
<h3 id="important-what-is-data-architecture">[Important] What is Data Architecture?<a hidden class="anchor" aria-hidden="true" href="#important-what-is-data-architecture">#</a></h3>
<p>Successful data engineering is built upon rock-solid data architecture. We will review a few popular architecture approaches and frameworks.</p>
<p><strong>Enterprise Architecture Defined</strong></p>
<ul>
<li>Enterprise architecture is the design of systems to support change in the enterprise, achieved by flexible and reversible decisions reached through careful evaluation of trade-off.</li>
<li>Architects are not simply mapping out IT processes and vaguely looking toward a distant, utopian future. They actively solve business problems and create new opportunities. <strong>Technical solutions exist not for their own sake but in support of business goals.</strong> Architects identify problems in the current state (poor data quality, scalability limits, money-losing lines of business), define desired future states (agile data-quality improvement, scalable cloud data solutions, improved business processes), and realize initiatives through execution of small, concrete steps</li>
</ul>
<p><strong>Data Architecture Defined</strong></p>
<ul>
<li>Data architecture is the design of systems to support the evolving data needs of an enterprise, achieved by flexible and reversible decisions reached through a careful evaluation of trade-offs.
<ul>
<li>What business processes does the data serve?</li>
<li>How does the organization manage data quality?</li>
<li>What is the latency requirement from when the data is produced to when it becomes avaialble to query?</li>
<li>How will you move 10TB of data every hour from a source database to your data lake.</li>
</ul>
</li>
<li>Data architecture = Operational + Technical
<ul>
<li>Operational architecture describe what nees to be done.</li>
<li>Technical architecture details how it will happen.</li>
</ul>
</li>
</ul>
<p><strong>&ldquo;Good&rdquo; Data Architecture</strong></p>
<ul>
<li>Good data architecutre serves business requirements with a common, widely reusable set of building blocks while maintaining flexibility and making appropriate trade-off.</li>
</ul>
<h3 id="principles-of-good-data-architecutre">Principles of Good Data Architecutre<a hidden class="anchor" aria-hidden="true" href="#principles-of-good-data-architecutre">#</a></h3>
<p>This is a 10000-foot view of good architecture, borrowed from AWS Well-Architected Framework andd Google Cloud&rsquo;s Five Principles for Cloud-Native Architecture</p>
<p><a href="https://docs.aws.amazon.com/wellarchitected/latest/framework/welcome.html">AWS Well-Architected Framework</a></p>
<ul>
<li>Operational excellence.</li>
<li>Security.</li>
<li>Reliability.</li>
<li>Performance efficiency.</li>
<li>Cost optimization.</li>
<li>Sustainability.</li>
</ul>
<p><a href="https://cloud.google.com/blog/products/application-development/5-principles-for-cloud-native-architecture-what-it-is-and-how-to-master-it">Google Cloud&rsquo;s Five Principles for Cloud-Native Architecture</a></p>
<ul>
<li>Design for automation.</li>
<li>Be smart with state.</li>
<li>Favor managed services.</li>
<li>Practice defense in depth.</li>
<li>Always be architecting.</li>
</ul>
<p>Additional principles:</p>
<ul>
<li>Choose common components wisely.</li>
<li>Plan for failure.</li>
<li>Architect for scalability.</li>
<li>Architecture is leadership.</li>
<li>Always be architecting.</li>
<li>Build loosely coupled systems.</li>
<li>Make reversible decisions.</li>
<li>Prioritize security.</li>
<li>Embrace FinOps.</li>
</ul>
<p><strong>Principle 1: Choose Common Components Wisely</strong></p>
<ul>
<li>Common components can be anything that has broad applicability with an organization. Common components include object storage, version-control systems, observability, monitoring and orchestration systems, and processing engines.</li>
</ul>
<p><strong>Principle 2: Plan for Failure</strong></p>
<ul>
<li>Availability: The percentage o time an IT service or component is in an operable state.</li>
<li>Reliability: The system&rsquo;s probability of meeting defined standards in performing its intended function during a specified intervals.</li>
<li>Recovery time objective.</li>
<li>Recovery point objective.</li>
</ul>
<p><strong>Principle 3: Architect for Scalability</strong></p>
<ul>
<li>Scale up to handle significant quantities of data.</li>
<li>Scale down to cut cost.</li>
</ul>
<p><strong>Principle 4: Architecture Is Leadership</strong></p>
<ul>
<li>Data architects are responsible for technology decisions and architecture descriptions and disseminating these choices through effective leadership and tranining.</li>
<li>An ideal data architect posses the technical skills of data enigneer but no longer practice data engineering day to day; they mentor curretn data engineers, make careful technology choice in consultation with their organization, and disseminate expertise through training and leadership. They train engineers in best practice and bring the company&rsquo;s engineering resources together to pursue common goals in both technology and business.</li>
</ul>
<p><strong>Principle 5: Always Be Architecting</strong></p>
<ul>
<li>The data architect maintains a target architecture and sequencing plans that change over time. The target architecture becomes a moving target, adjusted in response to business and technology changes internally and worldwide.</li>
</ul>
<p><strong>Principle 6: Build Loosely Coupled Systems</strong></p>
<ul>
<li>
<p>Putting data and services behind APIs enabled the loose coupling and eventually resulted in AWS as we know it now.</p>
</li>
<li>
<p>For software architecture, a loosely coupled system has the following properties:</p>
<ul>
<li>
<ol>
<li>Systems are broken into many components.</li>
</ol>
</li>
<li>
<ol start="2">
<li>These systems interface with other services through abstraction layers, such as a messaging bus or an API. These abstraction layers hide and protect internal details of the service, such as a database backend or internal classes and method calls.</li>
</ol>
</li>
<li>
<ol start="3">
<li>As a consequence of property 2, internal changes to a system component don&rsquo;t require changes in other parts. Details of code updates are hidden behind stable APIs. Each piece can evolve and improve separately.</li>
</ol>
</li>
<li>
<ol start="4">
<li>As a consequence of property 3, there is no waterfall, global release cycle for the whole system. Instead, each component is updated separately as changes and improvements are made.</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Organizational characteristics:</p>
<ul>
<li>
<ol>
<li>Many small teams engineer a large, complex system. Each team is tasked with engineering, maintaining, and improving some system components.</li>
</ol>
</li>
<li>
<ol start="2">
<li>These teams publish the abstract details of their componentsd to other teams via API definitions, message schemas,&hellip; Teams need not concern themselves with other teams&rsquo; components; they simply use the published API or message specifications to call these components. They iterate their part to improve their performance and capabilities over time. They might also publish new capabilities as they are added or request new stuff from other teams. Again, the latter happens without teams needing to worry about the internal technical details of the requested features. Teams work together through loosely couple communication.</li>
</ol>
</li>
<li>
<ol start="3">
<li>As a consequence of 2, each team can rapidly evolve and improve its component independently of the work of other teams.</li>
</ol>
</li>
<li>
<ol start="4">
<li>Specifically, 3 implies that team can release updates to their components with minal downtime. Teams release continuosly during regular working hours to make code changes and test them.</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>Principle 7: Make Reversible Decisions</strong></p>
<ul>
<li>The decoupling / modularization of tech across your data architecture - always strive to pick the best-of-breed solutions that work for today</li>
</ul>
<p><strong>Principle 8: Prioritize Security</strong></p>
<ul>
<li>Every data engineer must assume responsibility for the security of the systems
they build and maintain. We focus now on two main ideas: zero-trust security
and the shared responsibility security model. These align closely to a cloud-native
architecture.</li>
</ul>
<p><strong>Principle 9: Embrace FinOps</strong></p>
<ul>
<li>The term “FinOps” typically refers to the emerging professional movement that advo‐
cates a collaborative working relationship between DevOps and Finance, resulting in an iterative, data-driven management of infrastructure spending (i.e., lowering the unit economics of cloud) while simultaneously increasing the cost efficiency and, ultimately, the profitability of the cloud environment.</li>
<li>In the cloud era, most data systems are pay-as-you-go and readily scalable. Systems
can run on a cost-per-query model, cost-per-processing-capacity model, or another
variant of a pay-as-you-go model.</li>
</ul>
<h3 id="major-architecture-concepts">Major Architecture Concepts<a hidden class="anchor" aria-hidden="true" href="#major-architecture-concepts">#</a></h3>
<ul>
<li>Main goal of all architectures: to take data and transform it into something useful for downstream consumption.</li>
</ul>
<p><strong>Domains and Services</strong></p>
<ul>
<li>Domain is a real-world subject are for which are you architecting.</li>
<li>Service is a set of functionality whose goal is to accomplish a task.</li>
<li>Identify what should go in the domain. When determining what the domain should encompass and what services to include, the best advice is to simply go and talk with users and stakeholders, listen to what they’re saying, and build the services that will help them do their job. Avoid the classic trap of architecting in a vacuum.</li>
</ul>
<p><strong>Distributed Systems, Scalability, and Designing for Failure</strong></p>
<ul>
<li>Scalability: Allows us to increase the capacity of a system to improve performance and
handle the demand.</li>
<li>Elasticity: The ability of a scalable system to scale dynamically; a highly elastic system can
automatically scale up and down based on the current workload.</li>
<li>Availability: The percentage of time an IT service or component is in an operable state.</li>
<li>Reliability: The system’s probability of meeting defined standards in performing its intended
function during a specified interval.</li>
</ul>
<p><strong>Tight vs Loose Coupling: Tiers, Monoliths, and Microservices</strong></p>
<ul>
<li>Tightly coupled: Every part of a domain and service is vitally dependent upon every other
domain and service.</li>
<li>Loose coupling: you have decentralized domains and services that do not have strict dependence on each other.</li>
<li>Microservices: architecture comprises separate, decentralized, and loosely coupled services</li>
</ul>
<h3 id="examples-and-types-of-data-architecture">Examples and Types of Data Architecture<a hidden class="anchor" aria-hidden="true" href="#examples-and-types-of-data-architecture">#</a></h3>
<p><strong>Data Warehouse</strong></p>
<ul>
<li>A data warehouse is a central data hub used for reporting and analysis.</li>
</ul>
<h3 id="whos-involved-with-designing-a-data-architecture">Who&rsquo;s Involved with Designing a Data Architecture?<a hidden class="anchor" aria-hidden="true" href="#whos-involved-with-designing-a-data-architecture">#</a></h3>
<p>Data architecture isn’t designed in a vacuum. Bigger companies may still employ data
architects, but those architects will need to be heavily in tune and current with the
state of technology and data.</p>
<p>Ideally, a data engineer will work alongside a dedicated data architect. However, if
a company is small or low in its level of data maturity, a data engineer might work
double duty as an architect. Because data architecture is an undercurrent of the data
engineering lifecycle, a data engineer should understand “good” architecture and the
various types of data architecture.</p>
<h2 id="4-choosing-technologies-across-the-data-engineer-life-cycle">4. Choosing Technologies Across the Data Engineer Life Cycle<a hidden class="anchor" aria-hidden="true" href="#4-choosing-technologies-across-the-data-engineer-life-cycle">#</a></h2>
<h3 id="team-size-and-capabilities">Team Size and Capabilities<a hidden class="anchor" aria-hidden="true" href="#team-size-and-capabilities">#</a></h3>
<p>There is a continuum of simple to complex technologies, and a team’s size roughly
determines the amount of bandwidth your team can dedicate to complex solutions.</p>
<h3 id="speed-to-market">Speed to Market<a hidden class="anchor" aria-hidden="true" href="#speed-to-market">#</a></h3>
<p>In technology, speed to market wins. This means choosing the right technologies that
help you deliver features and data faster while maintaining high-quality standards
and security. It also means working in a tight feedback loop of launching, learning,
iterating, and making improvements.</p>
<p>Deliver value early and often.</p>
<h3 id="interoperability">Interoperability<a hidden class="anchor" aria-hidden="true" href="#interoperability">#</a></h3>
<p>When choosing a technology or
system, you’ll need to ensure that it interacts and operates with other technologies.
Interoperability describes how various technologies or systems connect, exchange
information, and interact.</p>
<h3 id="cost-optimization-and-business-value">Cost Optimization and Business Value<a hidden class="anchor" aria-hidden="true" href="#cost-optimization-and-business-value">#</a></h3>
<p>In a perfect world, you’d get to experiment with all the latest, coolest technologies
without considering cost, time investment, or value added to the business. In reality,
budgets and time are finite, and the cost is a major constraint for choosing the
right data architectures and technologies.</p>
<p>Data engineers need to be pragmatic about flexibility. The data landscape is changing
too quickly to invest in long-term hardware that inevitably goes stale, can’t easily
scale, and potentially hampers a data engineer’s flexibility to try new things. Given the
upside for flexibility and low initial costs, we urge data engineers to take an opex-first
approach centered on the cloud and flexible, pay-as-you-go technologies.</p>
<h3 id="today-vs-future-immutable-vs-transitory-technology">Today vs. Future: Immutable Vs. Transitory Technology<a hidden class="anchor" aria-hidden="true" href="#today-vs-future-immutable-vs-transitory-technology">#</a></h3>
<p>In an exciting domain like data engineering, it’s all too easy to focus on a rapidly
evolving future while ignoring the concrete needs of the present. The intention to
build a better future is noble but often leads to overarchitecting and overengineering.
Tooling chosen for the future may be stale and out-of-date when this future arrives;
the future frequently looks little like what we envisioned years before.</p>
<p>Given the reasonable probability of failure for many data technologies, you need to
consider how easy it is to transition from a chosen technology. What are the barriers
to leaving? As mentioned previously in our discussion about opportunity cost, avoid “bear traps.” Go into a new technology with eyes wide open, knowing the project might get abandoned, the company may not be viable, or the technology simply isn’t a good fit any longer.</p>
<h3 id="location">Location<a hidden class="anchor" aria-hidden="true" href="#location">#</a></h3>
<p>Companies now have numerous options when deciding where to run their technol‐
ogy stacks. A slow shift toward the cloud culminates in a veritable stampede of
companies spinning up workloads on AWS, Azure, and Google Cloud Platform
(GCP).</p>
<h3 id="build-vs-buy">Build vs Buy<a hidden class="anchor" aria-hidden="true" href="#build-vs-buy">#</a></h3>
<p>Build versus buy is an age-old debate in technology. The argument for building is that you have end-to-end control over the solution and are not at the mercy of a vendor or open source community. The argument supporting buying comes down to resource constraints and expertise; do you have the expertise to build a better solution than something already available.</p>
<h3 id="monolith-vs-modular">Monolith Vs. Modular<a hidden class="anchor" aria-hidden="true" href="#monolith-vs-modular">#</a></h3>
<p>Monoliths versus modular systems is another longtime debate in the software archi‐
tecture space. Monolithic systems are self-contained, often performing multiple func‐
tions under a single system.</p>
<h3 id="serverless-vs-servers">Serverless vs. Servers<a hidden class="anchor" aria-hidden="true" href="#serverless-vs-servers">#</a></h3>
<p>A big trend for cloud providers is serverless, allowing developers and data engineers
to run applications without managing servers behind the scenes. Serverless provides a
quick time to value for the right use cases. For other cases, it might not be a good fit.</p>
<h3 id="undercurrents-and-their-impacts-on-choosing-technologies">Undercurrents and Their Impacts on Choosing Technologies<a hidden class="anchor" aria-hidden="true" href="#undercurrents-and-their-impacts-on-choosing-technologies">#</a></h3>
<p>As seen in this chapter, a data engineer has a lot to consider when evaluating technol‐
ogies. Whatever technology you choose, be sure to understand how it supports the
undercurrents of the data engineering lifecycle.</p>
<h2 id="citation">Citation<a hidden class="anchor" aria-hidden="true" href="#citation">#</a></h2>
<p>Cited as:</p>
<blockquote>
    <summary>Fundamentals of Data Engineering: Foundation and Building Blocks</summary>
    <summary>https://mnguyen0226.github.io/posts/fundamentals_of_data_engineering_1/post/.</summary>
</blockquote>
<p>Or</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">@article<span class="o">{</span>nguyen2023mtl,
</span></span><span class="line"><span class="cl">  <span class="nv">title</span>   <span class="o">=</span> <span class="s2">&#34;Fundamentals of Data Engineering: Foundation and Building Blocks&#34;</span>,
</span></span><span class="line"><span class="cl">  <span class="nv">author</span>  <span class="o">=</span> <span class="s2">&#34;Nguyen, Minh&#34;</span>,
</span></span><span class="line"><span class="cl">  <span class="nv">journal</span> <span class="o">=</span> <span class="s2">&#34;mnguyen0226.github.io&#34;</span>,
</span></span><span class="line"><span class="cl">  <span class="nv">year</span>    <span class="o">=</span> <span class="s2">&#34;2024&#34;</span>,
</span></span><span class="line"><span class="cl">  <span class="nv">month</span>   <span class="o">=</span> <span class="s2">&#34;January&#34;</span>,
</span></span><span class="line"><span class="cl">  <span class="nv">url</span>     <span class="o">=</span> <span class="s2">&#34;https://mnguyen0226.github.io/posts/fundamentals_of_data_engineering_1/post/&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<center>
    <img class="img_size" src="https://raw.githubusercontent.com/mnguyen0226/mnguyen0226.github.io/main/content/posts/fundamentals_of_data_engineering_1/imgs/golden_bridge.png" />
</center>
<figcaption class="img_footer">
    Fig. 3: Golden Gate Bridge, San Francisco, U.S.A </br>(Image Source: 
    <a href="https://unsplash.com/photos/gZXx8lKAb7Y" class="img_footer">Maarten van den Heuvel @ Unsplash</a>).
</figcaption>
<!-- CSS Styling -->
<style>
.img_size {
  width: 100%;
}

.img_footer {
    color: #888888;
    text-align: center;
}
</style><blockquote>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mnguyen0226.github.io/tags/web-development/">web development</a></li>
      <li><a href="https://mnguyen0226.github.io/tags/long-read/">long-read</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://mnguyen0226.github.io/posts/system_design_roadmap/post/">
    <span class="title">Next »</span>
    <br>
    <span>System Design Roadmap</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Fundamentals of Data Engineering: Foundation and Building Blocks on twitter"
        href="https://twitter.com/intent/tweet/?text=Fundamentals%20of%20Data%20Engineering%3a%20Foundation%20and%20Building%20Blocks&amp;url=https%3a%2f%2fmnguyen0226.github.io%2fposts%2ffundamentals_of_data_engineering_1%2fpost%2f&amp;hashtags=webdevelopment%2clong-read">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Fundamentals of Data Engineering: Foundation and Building Blocks on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmnguyen0226.github.io%2fposts%2ffundamentals_of_data_engineering_1%2fpost%2f&amp;title=Fundamentals%20of%20Data%20Engineering%3a%20Foundation%20and%20Building%20Blocks&amp;summary=Fundamentals%20of%20Data%20Engineering%3a%20Foundation%20and%20Building%20Blocks&amp;source=https%3a%2f%2fmnguyen0226.github.io%2fposts%2ffundamentals_of_data_engineering_1%2fpost%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Fundamentals of Data Engineering: Foundation and Building Blocks on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fmnguyen0226.github.io%2fposts%2ffundamentals_of_data_engineering_1%2fpost%2f&title=Fundamentals%20of%20Data%20Engineering%3a%20Foundation%20and%20Building%20Blocks">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Fundamentals of Data Engineering: Foundation and Building Blocks on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmnguyen0226.github.io%2fposts%2ffundamentals_of_data_engineering_1%2fpost%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Fundamentals of Data Engineering: Foundation and Building Blocks on whatsapp"
        href="https://api.whatsapp.com/send?text=Fundamentals%20of%20Data%20Engineering%3a%20Foundation%20and%20Building%20Blocks%20-%20https%3a%2f%2fmnguyen0226.github.io%2fposts%2ffundamentals_of_data_engineering_1%2fpost%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Fundamentals of Data Engineering: Foundation and Building Blocks on telegram"
        href="https://telegram.me/share/url?text=Fundamentals%20of%20Data%20Engineering%3a%20Foundation%20and%20Building%20Blocks&amp;url=https%3a%2f%2fmnguyen0226.github.io%2fposts%2ffundamentals_of_data_engineering_1%2fpost%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://mnguyen0226.github.io/">Minh T. Nguyen</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
