[{"content":"[v.1.0] (10/18/2023): Post started!\nPrinciples of Public-Key Cryptosystems Public-Key Cryptosystems About:\nRadically different approach [Diffie-Hellman76, RSA78]. Sender, receiver do not share secret key. Public encryption key known to all. Private decryption key known only to receiver. A\tpublic-key\tencryption\tscheme\thas\tsix\tingredients:\nPlaintext: The readable message or data that is input into the encryption algorithm. Encryption Algorithm: Performs various transformations on the plaintext to produce ciphertext. Public Key: Used specifically for the encryption process. This key can be shared openly. Private Key: Used for either encryption or decryption. This key remains confidential. Ciphertext: The scrambled version of the original message, produced as output from the encryption process. Decryption Algorithm: Takes in the ciphertext and the appropriate key (either public or private) to reproduce the original plaintext. Terminology Related to Asymmetric Encryption Asymmetric Keys: Two related keys, a public key and a private key that are used to perform complementary operations, such as encryption and decryption or signature generation and signature verification. Public Key Certificate: A digital document issued and digitally signed by the private key of a Certification Authority that binds the name of a subscriber to a public key. The certificate indicates that the subscriber identified in the certificate has sole control and access to the corresponding private key. Public Key (Asymmetric) Cryptographic Algorithm: A cryptographic algorithm that uses two related keys, a public key and a private key. The two keys have the property that deriving the private key from the public key is computationally infeasible. Public Key Infrastructure (PKI): A set of policies, processes, server platforms, software and workstations used for the purpose of administering certificates and public-private key pairs, including the ability to issue, maintain, and revoke public key certificates. Misconceptions\tConcerning\tPublic-Key\tEncryption Public-key\tencryption\tis\tmore\tsecure\tfrom\tcryptanalysis\tthan\tsymmetric\tencryption. Public-key\tencryption\tis\ta\tgeneral-purpose\ttechnique\tthat\thas\tmade\tsymmetric encryption\tobsolete. There\tis\ta\tfeeling\tthat\tkey\tdistribution\tis\ttrivial\twhen\tusing\tpublic-key\tencryption,\tcompared\tto\tthe\tcumbersome\thandshaking\tinvolved\twith\tkey\tdistribution\tcenters\tfor\tsymmetric\tencryption. Principles\tof\tPublic-Key\tCryptosystems The\tconcept\tof\tpublic-key\tcryptography\tevolved\tfrom\tan\tattempt\tto\tattack\ttwo\tof\tthe\tmost\tdifficult\tproblems\tassociated\twith\tsymmetric\tencryption:\nKey\tdistribution: How\tto\thave\tsecure\tcommunications\tin\tgeneral\twithout\thaving\tto trust\ta\tKDC\twith\tyour\tkey. Digital\tsignatures: How\tto\tverify\tthat\ta\tmessage\tcomes\tintact\tfrom\tthe\tclaimed\tsender Whitfield\tDiffie\tand\tMartin\tHellman\tfrom\tStanford\tUniversity\tachieved\ta\tbreakthrough\tin\t1976\tby\tcoming\tup\twith\ta\tmethod\tthat\taddressed\tkey\tdistribution\tproblem\tand\twas\tradically\tdifferent\tfrom\tall\tprevious\tapproaches\tto\tcryptography.\nConventional vs Public-Key Encryption Conventional Encryption\nNeeded to Work:\nThe same algorithm with the same key is used for encryption and decryption. The sender and receiver must share the algorithm and the key. Needed for Security:\nThe key must be kept secret. It must be impossible or at least impractical to decipher a message if the key is kept secret. Knowledge of the algorithm plus samples of ciphertext must be insufficient to determine the key. Public-Key Encryption\nNeeded to Work: One algorithm is used for encryption and a related algorithm for decryption with a pair of keys, one for encryption and one for decryption. The sender and receiver must each have one of the matched pair of keys (not the same one). Needed for Security: One of the two keys must be kept secret. It must be impossible or at least impractical to decipher a message if one of the keys is kept secret. Knowledge of the algorithm plus one of the keys plus samples of ciphertext must be insufficient to determine the other key. Applications for Public-Key Cryptosystems Public-key\tcryptosystems\tcan\tbe\tclassified\tinto\tthree\tcategories:\nEncryption/decryption: The\tsender\tencrypts\ta\tmessage\twith\tthe\trecipient’s\tpublic\tkey. Digital signature: the\tsender\t“signs”\ta\tmessage\tDigital\tsignature\twith\tits\tprivate\tkey. Key exchange: Two sides cooperate to exchange a session key. Some\talgorithms\tare\tsuitable\tfor\tall\tthree\tapplications,\twhereas\tothers\tcan\tbe\tused\tonly\tfor\tone\tor\ttwo.\nFig. 1: Applications for Public-Key Cryptosystems. Requirements for Public-Key Cryptography Conditions\tthat\tthese\talgorithms\tmust\tfulfill:\nIt\tis\tcomputationally\teasy\tfor\ta\tparty\tB\tto\tgenerate\ta\tpair\t(publickey\tPUb, private\tkey\tPRb). It\tis\tcomputationally\teasy\tfor\ta\tsender\tA,\tknowing\tthe\tpublic\tkey\tand\tthe\tmessage\tto\tbe\tencrypted,\tto\tgenerate\tthe\tcorresponding\tciphertext. It\tis\tcomputationally\teasy\tfor\tthe\treceiver\tB\tto\tdecrypt\tthe\tresulting\tciphertext\tusing\tthe\tprivate\tkey\tto\trecover\tthe\toriginal\tmessage. It\tis\tcomputationally\tinfeasible\tfor\tan\tadversary,\tknowing\tthe\tpublic\tkey,\tto\tdetermine\tthe\tprivate\tkey. It\tis\tcomputationally\tinfeasible\tfor\tan\tadversary,\tknowing\tthe\tpublic\tkey\tand\ta\tciphertext,\tto\trecover\tthe\toriginal\tmessage. The\ttwo\tkeys\tcan\tbe\tapplied\tin\teither\torder. Need a trap-door one-way function\nA one-way function is one that maps a domain into a range such that every function value has a unique inverse, with the condition that the calculation of the function is easy, whereas the calculation of the inverse is infeasible Y = f(X) easy X = f^(-1)(Y) infeasible A trap-door one-way function is a family of invertible functions f_k, such that:\nY = f_k(X) easy, if k and X are known X = f_k^(-1)(Y) easy, if k and Y are known X = f_k^(-1)(Y) infeasible, if Y known but k not known A practical public-key scheme depends on a suitable trap-door one-way function\nPublic-Key Cryptanalysis A\tpublic-key\tencryption\tscheme\tis\tvulnerable\tto\ta\tbrute-force\tattack\nCountermeasure:\tuse\tlarge\tkeys. Key\tsize\tmust\tbe\tsmall\tenough\tfor\tpractical\tencryption\tand\tdecryption. Key\tsizes\tthat\thave\tbeen\tproposed\tresult\tin\tencryption/decryption\tspeeds\tthat\tare\ttoo\tslow\tfor\tgeneral-purpose\tuse. Public-key\tencryption\tis\tcurrently\tconfined\tto\tkey\tmanagement\tand\tsignature\tapplications. Another\tform\tof\tattack\tis\tto\tfind\tsome\tway\tto\tcompute\tthe\tprivate\tkey\tgiven\tthe\tpublic\tkey. To\tdate\tit\thas\tnot\tbeen\tmathematically\tproven\tthat\tthis\tform\tof\tattack\tis\tinfeasible\tfor\ta\tparticular\tpublic-key\talgorithm.\nFinally,\tthere\tis\ta\tprobable-message\tattack\tThis\tattack\tcan\tbe\tthwarted\tby\tappending\tsome\trandom\tbits\tto\tbits\tto\tthe\tmessages.\nThe RSA Algorithm Rivest-Shamir-Adleman\t(RSA)\tAlgorithm Developed\tin\t1977\tat\tMIT\tby\tRon\tRivest,\tAdi\tShamir\t\u0026amp;\tLen\tAdleman. Most\twidely\tused\tgeneral-purpose\tapproach\tto\tpublic-key\tencryption.\tIs\ta\tcipher\tin\twhich\tthe\tplaintext\tand\tciphertext are\tintegers\tbetween\t0\tand\tn\t–\t1\tfor\tsome\tn. A\ttypical\tsize\tfor\tn\tis\t1024\tbits,\tor\t309\tdecimal\tdigits\nRSA\tmakes\tuse\tof\tan\texpression\twith\texponentials. Plaintext\tis\tencrypted\tin\tblocks\twith\teach\tblock\thaving\ta\tbinary\tvalue\tless\tthan\tsome\tnumber\tn.\tEncryption\tand\tdecryption\tare\tof\tthe\tfollowing\tform,\tfor\tsome\tplaintext\tblock\tM\tand\tciphertext block\tC:\nC\t=\tM^e mod\tn M\t=\tC^d\tmod\tn\t=\t(M^e)^d\tmod\tn\t=\tM^(ed)\tmod\tn Both\tsender\tand\treceiver\tmust\tknow\tthe\tvalue\tof\tn. The\tsender\tknows\tthe\tvalue\tof\te,\tand\tonly\tthe\treceiver\tknows\tthe\tvalue\tof\td. This\tis\ta\tpublic-key\tencryption\talgorithm\twith\ta\tpublic\tkey\tof\tPU={e,n}\tand\ta\tprivate\tkey\tof\tPR={d,n}.\nRSA:\tCreating\tpublic/private\tkey\tpair choose\ttwo\tlarge\tprime\tnumbers\tp,\tq. compute\tn\t=\tpq,\tz\t=\t(p-1)(q-1) choose\te\t(with\te \u0026lt; n)\tthat\thas\tno\tcommon\tfactors\twith\tz\t(e,\tz are\t“relatively\tprime”). choose\td\tsuch\tthat\ted-1\tis\texactly\tdivisible\tby\tz. (in\tother\twords:\ted\tmod\tz\t=\t1\t). public\tkey\tis\t(n,e).\tprivate\tkey\tis\t(n,d). RSA:\tencryption,\tdecryption given\t(n,e)\tand\t(n,d)\tas\tcomputed\tabove to\tencrypt\tmessage\tm\t(\u0026lt; n),\tcompute\tc\t=\tm^e mod n to\tdecrypt\treceived\tbit\tpattern,\tc,\tcompute\tm\t=\tc^d\tmod\tn m =\t(m^e mod n)^d\tmod n Why\tis\tRSA\tsecure? Suppose\tyou\tknow\tBob’s\tpublic\tkey\t(n,e).\tHow\thard\tis\tit\tto\tdetermine\td? Essentially\tneed\tto\tfind\tfactors\tof\tn\twithout\tknowing\tthe\ttwo\tfactors\tp\tand\tq.\nFact:\tfactoring\ta\tbig\tnumber\tis\thard. Algorithm\tRequirements For\tthis\talgorithm\tto\tbe\tsatisfactory\tfor\tpublickey\tencryption,\tthe\tfollowing requirements\tmust\tbe\tmet:\nIt\tis\tpossible\tto\tfind\tvalues\tof\te,\td,\tn\tsuch\tthat\tMed\tmod\tn\t=\tM\tfor\tall\tM\t\u0026lt;\tn. It\tis\trelatively\teasy\tto\tcalculate\tMe mod\tn\tand\tCd\tmod\tn\tfor\tall\tvalues\tof\tM\t\u0026lt;\tn. It\tis\tinfeasible\tto\tdetermine\td\tgiven\te\tand\tn. Exponentiation\tin\tModular\tArithmetic Both\tencryption\tand\tdecryption\tin\tRSA\tinvolve\traising\tan\tinteger\tto\tan\tinteger\tpower,\tmod\tn. Can\tmake\tuse\tof\ta\tproperty\tof\tmodular\tarithmetic:\t[(a\tmod\tn)\tx\t(b\tmod\tn)]\tmod\tn\t=(a\tx\tb)\tmod\tn. With\tRSA\tyou\tare\tdealing\twith\tpotentially\tlarge\texponents\tso\tefficiency\tof exponentiation\tis\ta\tconsideration. Efficient\tOperation\tUsing\tthe\tPublic\tKey To\tspeed\tup\tthe\toperation\tof\tthe\tRSA\talgorithm\tusing\tthe\tpublic\tkey,\ta\tspecific\tchoice\tof\te\tis\tusually\tmade.\nThe\tmost\tcommon\tchoice\tis\t65537\t(2^16\t+\t1)\nTwo\tother\tpopular\tchoices\tare\te=3\tand\te=17. Each\tof\tthese\tchoices\thas\tonly\ttwo\t1\tbits,\tso\tthe\tnumber\tof\tmultiplications\trequired\tto\tperform\texponentiation\tis\tminimized. With\ta\tvery\tsmall\tpublic\tkey,\tsuch\tas\te\t=\t3,\tRSA\tbecomes\tvulnerable\tto\ta\tsimple\tattack. Efficient\tOperation\tUsing\tthe\tPrivate\tKey Decryption\tuses\texponentiation\tto\tpower\td. A\tsmall\tvalue\tof\td\tis\tvulnerable\tto\ta\tbrute-force\tattack\tand\tto\tother\tforms\tof\tcryptanalysis. Can\tuse\tthe\tChinese\tRemainder\tTheorem\t(CRT)\tto\tspeed\tup\tcomputation. The\tquantities\td\tmod\t(p\t–\t1)\tand\td\tmod\t(q\t–\t1)\tcan\tbe\tprecalculated. End\tresult\tis\tthat\tthe\tcalculation\tis\tapproximately\tfour\ttimes\tas\tfast\tas\tevaluating\tM\t=\tCd mod\tn\tdirectly. Key\tGeneration Before\tthe\tapplication\tof\tthe\tpublic-key\tcryptosystem\teach\tparticipant\tmust\tgenerate\ta\tpair\tof\tkeys:\nDetermine\ttwo\tprime\tnumbers\tp\tand\tq. Select\teither\te\tor\td\tand\tcalculate\tthe\tother. Because\tthe\tvalue\tof\tn\t=\tpq will\tbe\tknown\tto\tany\tpotential\tadversary,\tprimes must\tbe\tchosen\tfrom\ta\tsufficiently\tlarge\tset. The\tmethod\tused\tfor\tfinding\tlarge\tprimes\tmust\tbe\treasonably\tefficient.\nProcedure\tfor\tPicking\ta\tPrime\tNumber Pick\tan\todd\tinteger\tn\tat\trandom Pick\tan\tinteger\ta\t\u0026lt;\tn\tat\trandom Perform\tthe\tprobabilistic\tprimality\ttest\twith\ta\tas\ta\tparameter.\tIf\tn\tfails\tthe\ttest,\treject\tthe\tvalue\tn\tand\tgo\tto\tstep\t1 If\tn\thas\tpassed\ta\tsufficient\tnumber\tof\ttests,\taccept\tn;\totherwise,\tgo\tto\tstep\t2 Breaking\tan\tencryption\tscheme Cipher-text\tonly\tattack:\tTrudy\thas\tciphertext\tshe\tcan\tanalyze. Two\tapproaches:\tbrute\tforce:\tsearch\tthrough\tall\tkeys; statistical\tanalysis. Known-plaintext\tattack:\tTrudy\thas\tplaintext\tcorresponding\tto\tciphertext. e.g.,\tin\tmonoalphabetic\tcipher,\tTrudy\tdetermines\tpairings\tfor\ta,l,i,c,e,b,o, Chosen-plaintext\tattack:\tTrudy\tcan\tget\tciphertext\tfor\tchosen\tplaintext. The Security of RSA Five possible approaches to attacking RSA are:\nChosen ciphertext attacks\nThis type of attack exploits properties of the RSA algorithm. Brute force\nInvolves trying all possible private keys. Mathematical attacks\nThere are several approaches, all equivalent in effort to factoring the product of two primes. Hardware fault-based attack\nThis involves inducing hardware faults in the processor that is generating digital signatures. Timing attacks\nThese depend on the running time of the decryption algorithm. Factoring\tProblem We\tcan\tidentify\tthree\tapproaches\tto\tattacking\tRSA\tmathematically:\nFactor\tn\tinto\tits\ttwo\tprime\tfactors.\tThis\tenables\tcalculation\tof\tø(n)\t=\t(p\t–\t1)\tx\t(q\t–\t1),\twhich\tin\tturn\tenables\tdetermination\tof\td\t=\te-1\t(mod\tø(n)) Determine\tø(n)\tdirectly\twithout\tfirst\tdetermining\tp\tand\tq.\tAgain,\tthis\tenables\tdetermination\tof\td\t=\te-1 (mod\tø(n)) Determine\td\tdirectly\twithout\tfirst\tdetermining\tø(n) Timing\tAttacks Paul\tKocher,\ta\tcryptographic\tconsultant,\tdemonstrated\tthat\ta\tsnooper\tcan\tdetermine\ta\tprivate\tkey\tby\tkeeping\ttrack\tof\thow\tlong\ta\tcomputer\ttakes\tto\tdecipher\tmessages\nAre\tapplicable\tnot\tjust\tto\tRSA\tbut\tto\tother\tpublickey\tcryptography\tsystems\nAre\talarming\tfor\ttwo\treasons: It\tcomes\tfrom\ta\tcompletely\tunexpected\tdirection. It\tis\ta\tciphertext-only\tattack\nCountermeasures Constant exponentiation time: Ensure that all exponentiations take the same amount of time before returning a result; this is a simple fix but does degrade performance. Random delay: Better performance could be achieved by adding a random delay to the exponentiation algorithm to confuse the timing attack. Blinding: Multiply the ciphertext by a random number before performing exponentiation; this process prevents the attacker from knowing what ciphertext bits are being processed inside the computer and therefore prevents the bit-by-bit analysis essential to the timing attack. Fault-Based\tAttack An\tattack\ton\ta\tprocessor\tthat\tis\tgenerating\tRSA\tdigital\tsignatures. Induces\tfaults\tin\tthe\tsignature\tcomputation\tby\treducing\tthe\tpower\tto\tthe\tprocessor. The\tfaults\tcause\tthe\tsoftware\tto\tproduce\tinvalid\tsignatures\twhich\tcan\tthen\tbe\tanalyzed\tby\tthe\tattacker\tto\trecover\tthe\tprivate\tkey.\nThe\tattack\talgorithm\tinvolves\tinducing\tsingle-bit\terrors\tand\tobserving\tthe\tresults.\nWhile\tworthy\tof\tconsideration,\tthis\tattack\tdoes\tnot\tappear\tto\tbe\ta\tserious\tthreat\tto\tRSA. It\trequires\tthat\tthe\tattacker\thave\tphysical\taccess\tto\tthe\ttarget\tmachine\tand\tis\table\tto\tdirectly\tcontrol\tthe\tinput\tpower\tto\tthe\tprocessor.\nChosen\tCiphertext\tAttack\t(CCA) The\tadversary\tchooses\ta\tnumber\tof\tciphertexts\tand\tis\tthen\tgiven\tthe\tcorresponding\tplaintexts,\tdecrypted\twith\tthe\ttarget’s\tprivate\tkey. Thus\tthe\tadversary\tcould\tselect\ta\tplaintext,\tencrypt\tit\twith\tthe\ttarget’s\tpublic\tkey,\tand\tthen\tbe\table\tto\tget\tthe\tplaintext\tback\tby\thaving\tit\tdecrypted\twith\tthe\tprivate\tkey.\tThe\tadversary\texploits\tproperties\tof\tRSA\tand\tselects\tblocks\tof\tdata\tthat,\twhen\tprocessed\tusing\tthe\ttarget’s\tprivate\tkey,\tyield\tinformation\tneeded\tfor\tcryptanalysis.\nTo\tcounter\tsuch\tattacks,\tRSA\tSecurity\tInc.\trecommends\tmodifying\tthe\tplaintext\tusing\ta\tprocedure\tknown\tas\toptimal\tasymmetric\tencryption\tpadding\t(OAEP).\nCitation Cited as:\nPublic-Key Cryptography and RSA https://mnguyen0226.github.io/posts/info_security_2/post/ Or\n@article{nguyen2023mtl, title = \u0026#34;Public-Key Cryptography and RSA\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;October\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/info_security_9/post/\u0026#34; } References [1] Pearson, https://www.pearson.com/en-us/subject-catalog/p/Stallings-Pearson-e-Text-for-Cryptography-and-Network-Security-Principles-and-Practice-Access-Card-8th-Edition/P200000003477 (accessed Oct. 18, 2023).\nFig. 2: Indiana, U.S.A (Image Source: Hannah Hutson @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/info_security_9/post/","summary":"[v.1.0] (10/18/2023): Post started!\nPrinciples of Public-Key Cryptosystems Public-Key Cryptosystems About:\nRadically different approach [Diffie-Hellman76, RSA78]. Sender, receiver do not share secret key. Public encryption key known to all. Private decryption key known only to receiver. A\tpublic-key\tencryption\tscheme\thas\tsix\tingredients:\nPlaintext: The readable message or data that is input into the encryption algorithm. Encryption Algorithm: Performs various transformations on the plaintext to produce ciphertext. Public Key: Used specifically for the encryption process.","title":"Public-Key Cryptography and RSA"},{"content":"[v.1.0] (10/09/2023): Post started!\nPrinciples of Pseudorandom Number Generation Random Number A\tnumber\tof\tnetwork\tsecurity\talgorithms\tand\tprotocols based\ton\tcryptography\tmake\tuse\tof\trandom\tbinary\tnumbers:\nKey\tdistribution\tand\treciprocal\tauthentication\tschemes. Session\tkey\tgeneration. Generation\tof\tkeys\tfor\tthe\tRSA\tpublic-key\tencryption\talgorithm.. Generation\tof\ta\tbit\tstream\tfor\tsymmetric\tstream\tencryption. There\tare\ttwo\tdistinct\trequirements\tfor\ta\tsequence\tof\trandom\tnumbers: Randomness\tand Unpredictability.\nRandomness The\tgeneration\tof\ta\tsequence\tof\tallegedly\trandom\tnumbers\tbeing\trandom\tin\tsome\twell-defined\tstatistical\tsense\thas\tbeen\ta\tconcern.\nUniform\tdistribution: The\tfrequency\tof\toccurrence\tof\tones\tand\tzeros\tshould be\tapproximately\tequal. Independence: No\tone\tsubsequence\tin\tthe\tsequence\tcan\tbe\tinferred from\tthe\tothers Unpredictability The\trequirement\tis\tnot\tjust\tthat\tthe\tsequence\tof\tnumbers\tbe\tstatistically\trandom,\tbut\tthat\tthe\tsuccessive\tmembers\tof\tthe\tsequence\tare\tunpredictable.\nWith\t“true”\trandom\tsequences\teach\tnumber\tis\tstatistically\tindependent\tof\tother\tnumbers\tin\tthe\tsequence\tand\ttherefore\tunpredictable.\nTrue\trandom\tnumbers\thave\ttheir\tlimitations,\tsuch\tas\tinefficiency,\tso\tit\tis\tmore common\tto\timplement\talgorithms\tthat\tgenerate\tsequences\tof\tnumbers\tthat\tappear\tto\tbe\trandom. Care\tmust\tbe\ttaken\tthat\tan\topponent\tnot\tbe\table\tto\tpredict\tfuture\telements\tof\tthe\tsequence\ton\tthe\tbasis\tof\tearlier\telements. Pseudorandom Number Cryptographic\tapplications\ttypically\tmake\tuse\tof\talgorithmic\ttechniques\tfor\trandom\tnumber\tgeneration. These\talgorithms\tare\tdeterministic\tand\ttherefore\tproduce\tsequences\tof\tnumbers\tthat\tare\tnot\tstatistically\trandom. If\tthe\talgorithm\tis\tgood,\tthe\tresulting\tsequences\twill\tpass\tmany\ttests\tof\trandomness\tand\tare\treferred\tto\tas\tpseudorandom\tnumbers.\nFig. 1: Random and Pseudorandom Number Generators. True\tRandom\tNumber\tGenerator\t(TRNG) Takes\tas\tinput\ta\tsource\tthat\tis\teffectively\trandom.\nThe\tsource\tis\treferred\tto\tas\tan\tentropy\tsource\tand\tis\tdrawn\tfrom\tthe\tphysical\tenvironment\tof\tthe\tcomputer.\nIncludes\tthings\tsuch\tas\tkeystroke\ttiming\tpatterns,\tdisk\telectrical\tactivity,\tmouse\tmovements,\tand\tinstantaneous\tvalues\tof\tthe\tsystem\tclock. The\tsource,\tor\tcombination\tof\tsources,\tserve\tas\tinput\tto\tan\talgorithm\tthat\tproduces\trandom\tbinary\toutput. The\tTRNG\tmay\tsimply\tinvolve\tconversion\tof\tan\tanalog\tsource\tto\ta\tbinary\toutput.\nThe\tTRNG\tmay\tinvolve\tadditional\tprocessing\tto\tovercome\tany\tbias\tin\tthe\tsource.\nPseudorandom\tNumber\tGenerator\t(PRNG) Takes\tas\tinput\ta\tfixed\tvalue,\tcalled the\tseed,\tand\tproduces\ta\tsequence\tof\toutput\tbits\tusing\ta\tdeterministic\talgorithm. Quite\toften\tthe\tseed\tis generated\tby\ta\tTRNG.\nThe\toutput\tbit\tstream\tis\tdetermined\tsolely\tby\tthe\tinput\tvalue\tor\tvalues,\tso\tan\tadversary\twho\tknows\tthe\talgorithm\tand\tthe\tseed\tcan\treproduce\tthe\tentire\tbit\tstream.\nOther\tthan\tthe\tnumber\tof\tbits produced\tthere\tis\tno\tdifference\tbetween\ta\tPRNG\tand\ta\tPRF.\nTwo different forms of PRNG:\nPseudorandom\tnumber\tgenerator: An\talgorithm\tthat\tis\tused\tto\tproduce\tan\topen-ended\tsequence\tof\tbits. Input\tto\ta\tsymmetric\tstream\tcipher\tis\ta\tcommon\tapplication\tfor\tan\topen-ended\tsequence\tof\tbits. Pseudorandom\tfunction\t(PRF): Used\tto\tproduce\ta\tpseudorandom\tstring\tof\tbits\tof\tsome\tfixed\tlength. Examples\tare\tsymmetric\tencryption\tkeys\tand\tnonces. PRNG\tRequirements The\tbasic\trequirement\twhen\ta\tPRNG\tor\tPRF\tis\tused\tfor\ta\tcryptographic\tapplication\tis\tthat\tan\tadversary\twho\tdoes\tnot\tknow\tthe\tseed\tis\tunable\tto\tdetermine\tthe\tpseudorandom\tstring.\nThe\trequirement\tfor\tsecrecy\tof\tthe\toutput\tof\ta\tPRNG\tor\tPRF\tleads\tto\tspecific\trequirements\tin\tthe\tareas\tof:\nRandomness. Unpredictability. Characteristics\tof\tthe\tseed. Randomness The\tgenerated\tbit\tstream\tneeds\tto\tappear\trandom\teven\tthough\tit\tis\tdeterministic.\nThere\tis\tno\tsingle\ttest\tthat\tcan\tdetermine\tif\ta\tPRNG\tgenerates\tnumbers\tthat\thave\tthe\tcharacteristic\tof\trandomness.\tIf\tthe\tPRNG\texhibits\trandomness\ton\tthe\tbasis\tof\tmultiple\ttests,\tthen\tit\tcan\tbe\tassumed\tto\tsatisfy\tthe\trandomness requirement.\nNIST\tSP\t800-22\tspecifies\tthat\tthe\ttests\tshould\tseek\tto\testablish\tthree\tcharacteristics:\nUniformity. Scalability. Consistency. Randomness\tTests:\nFrequency\ttest: The\tmost\tbasic\ttest\tand\tmust\tbe\tincluded\tin\tany\ttest\tsuite. Purpose\tis\tto\tdetermine\twhether\tthe\tnumber\tof\tones and\tzeros\tin\ta\tsequence\tis\tapproximately\tthe same\tas\twould\tbe\texpected\tfor\ta\ttruly\trandom\tsequence. Runs\ttest: Focus\tof\tthis\ttest\tis\tthe\ttotal\tnumber\tof\truns\tin\tthe\tsequence, where\ta\trun\tis\tan\tuninterrupted\tsequence\tof\tidentical\tbits\tbounded\tbefore\tand\tafter\twith\ta\tbit\tof\tthe\topposite\tvalue. Purpose\tis\tto\tdetermine\twhether the\tnumber\tof\truns\tof\tones\tand\tzeros\tof\tvarious\tlengths\tis\tas\texpected\tfor\ta\trandom\tsequence. Maurer’s\tuniversal\tstatistical\ttest: Focus\tis\tthe\tnumber\tof\tbits\tbetween matching\tpatterns. Purpose\tis\tto\tdetect\twhether\tor\tnot\tthe\tsequence\tcan\tbe\tsignificantly\tcompressed\twithout\tloss\tof\tinformation. A\tsignificantly compressible\tsequence\tis\tconsidered\tto\tbe\tnon-random. Unpredictability A\tstream\tof\tpseudorandom\tnumbers\tshould\texhibit\ttwo\tforms\tof\tunpredictability:\nForward\tunpredictability: If\tthe\tseed\tis\tunknown,\tthe\tnext\toutput\tbit\tin\tthe\tsequence\tshould\tbe\tunpredictable\tin\tspite\tof\tany\tknowledge\tof\tprevious\tbits\tin\tthe sequence. Backward\tunpredictability: It\tshould\tnot\tbe\tfeasible\tto\tdetermine\tthe\tseed\tfrom\tknowledge\tof\tany\tgenerated\tvalues.\tNo\tcorrelation\tbetween\ta\tseed\tand\tany\tvalue\tgenerated\tfrom\tthat\tseed\tshould\tbe\tevident. Each\telement\tof\tthe\tsequence\tshould\tappear\tto\tbe\tthe\toutcome\tof\tan\tindependent\trandom\tevent\twhose\tprobability\tis\t1/2. The\tsame\tset\tof\ttests\tfor\trandomness\talso\tprovides\ta\ttest\tof\tunpredictability.\tA\trandom\tsequence\twill\thave\tno\tcorrelation\twith\ta\tfixed\tvalue\t(the\tseed).\nSeed\tRequirements The\tseed\tthat\tserves\tas\tinput\tto\tthe\tPRNG\tmust\tbe\tsecure\tand\tunpredictable. The\tseed\titself\tmust\tbe\ta\trandom\tor\tpseudorandom\tnumber. Typically\tthe\tseed\tis\tgenerated\tby\tTRNG.\nFig. 2: Generation of Seed Input to PRNG. Algorithm\tDesign Algorithms\tfall\tinto\ttwo\tcategories:\nPurpose-built\talgorithms: Algorithms\tdesigned\tspecifically\tand\tsolely\tfor\tthe\tpurpose\tof\tgenerating\tpseudorandom\tbit\tstreams. Algorithms\tbased\ton\texisting\tcryptographic\talgorithms: Have\tthe\teffect\tof\trandomizing\tinput\tdata. Three\tbroad\tcategories\tof\tcryptographic\talgorithms\tare\tcommonly\tused\tto\tcreate\tPRNGs:\nSymmetric\tblock\tciphers. Hash\tfunctions. Message\tauthentication\tcodes. Pseudorandom Number Generators Linear Congruential Generator An algorithm first proposed by Lehmer that is parameterized with four numbers:\nm: the modulus Condition: m \u0026gt; 0 a: the multiplier Condition: 0 \u0026lt; a \u0026lt; m c: the increment Condition: 0 ≤ c \u0026lt; m X₀: the starting value, or seed Condition: 0 ≤ X₀ \u0026lt; m The sequence of random numbers {Xₙ} is obtained via the following iterative equation:\nXₙ₊₁ = (aXₙ + c) mod m. If m, a, c, and X₀ are integers, this technique will produce a sequence of integers with each integer in the range 0 ≤ Xₙ \u0026lt; m.\nThe selection of values for a, c, and m is critical in developing a good random number generator:\nGenerates a full-period. Generated sequence should appear random. Efficient implementation with 32-bit arithmetic. Blum Blum Shub (BBS) Generator Has perhaps the strongest public proof of its cryptographic strength of any purpose-built algorithm.\nReferred to as a cryptographically secure pseudorandom bit generator (CSPRBG):\nA CSPRBG is defined as one that passes the next-bit-test if there is not a polynomial-time algorithm that, on input of the first k bits of an output sequence, can predict the (k + 1)st bit with probability significantly greater than 0.5. BBS\tGenerator: The\tsecurity\tof\tBBS\tis\tbased\ton\tthe\tdifficulty\tof\tfactoring\tn.\nChoose two\tlarge\tprime\tnumbers\tp\tand\tq: p\t≡\tq\t≡\t3\t(mod\t4). Let\tn\t=\tp\t×\tq. Choose\ta\trandom\tnumber\ts,\tsuch\tthat\ts\tis\trelatively\tprime\tto\tn. Fig. 3: Blum Blum Shub Block Diagram. Pseudorandom Number Generation Using a Block Cipher Two\tapproaches\tthat\tuse\ta\tblock\tcipher\tto\tbuild\ta\tPNRG\thave\tgained\twidespread acceptance:\nCTR\tmode: Recommended\tin\tNIST\tSP\t800-90,\tANSI\tstandard\tX.82,\tand\tRFC\t4086. OFB\tmode: Recommended\tin\tX9.82\tand\tRFC\t4086. Stream\tCipher\tDesign\tConsiderations The\tencryption\tsequence\tshould\thave\ta\tlarge\tperiod: A\tpseudorandom\tnumber\tgenerator\tuses\ta\tfunction\tthat\tproduces\ta\tdeterministic\tstream\tof\tbits\tthat\teventually repeats; the\tlonger\tthe\tperiod\tof\trepeat\tthe\tmore\tdifficult\tit\twill\tbe\tto\tdo cryptanalysis.\nThe\tkeystream\tshould\tapproximate\tthe\tproperties\tof\ta\ttrue\trandom\tnumber\tstream\tas\tclose\tas\tpossible:\tThere\tshould\tbe\tan\tapproximately\tequal\tnumber\tof\t1s\tand\t0s. If\tthe\tkeystream\tis\ttreated\tas\ta\tstream\tof\tbytes,\tthen\tall\tof\tthe\t256\tpossible\tbyte\tvalues\tshould\tappear\tapproximately\tequally\toften.\nA\tkey\tlength\tof\tat\tleast\t128\tbits\tis\tdesirable: The\toutput\tof\tthe\tpseudorandom\tnumber\tgenerator\tis\tconditioned\ton\tthe\tvalue\tof\tthe\tinput\tkey. The\tsame considerations\tthat\tapply\tto\tblock\tciphers\tare\tvalid.\nWith\ta\tproperly\tdesigned\tpseudorandom\tnumber\tgenerator\ta\tstream\tcipher\tcan\tbe\tas\tsecure\tas\ta\tblock\tcipher\tof\tcomparable\tkey\tlength: A\tpotential\tadvantage\tis\tthat\tstream\tciphers\tthat\tdo\tnot\tuse\tblock\tciphers\tas\ta\tbuilding\tblock\tare\ttypically\tfaster\tand\tuse\tfar\tless code\tthan\tblock\tciphers.\nRC4 Designed\tin\t1987\tby\tRon\tRivest\tfor\tRSA\tSecurity. Variable\tkey\tsize\tstream\tcipher\twith\tbyte-oriented\toperations. Based\ton\tthe\tuse\tof\ta\trandom\tpermutation. Eight\tto\tsixteen\tmachine\toperations\tare\trequired\tper\toutput\tbyte\tand\tthe\tcipher\tcan\tbe\texpected\tto\trun\tvery\tquickly\tin\tsoftware. RC4\tis\tused\tin\tthe\tWiFi\tProtected\tAccess\t(WPA)\tprotocol\tthat\tare\tpart\tof\tthe\tIEEE\t802.11\twireless\tLAN\tstandard.\tIt\tis\toptional\tfor\tuse\tin\tSecure\tShell\t(SSH)\tand\tKerberos. RC4\twas\tkept\tas\ta\ttrade\tsecret\tby\tRSA\tSecurity\tuntil\tSeptember\t1994\twhen the\tRC4\talgorithm\twas\tanonymously\tposted\ton\tthe\tInternet\ton\tthe\tCypherpunks\tanonymous\tremailers\tlist.\nStrength\tof\tRC4 A fundamental vulnerability was revealed in the RC4 key scheduling algorithm that reduces the amount of effort to discover the key. Recent cryptanalysis results exploit biases in the RC4 keystream to recover repeatedly encrypted plaintexts. As a result of the discovered weaknesses the IETF issued RFC 7465 prohibiting the use of RC4 in TLS. In its latest TLS guidelines, NIST also prohibited the use of RC4 for government use. Stream Ciphers Using Feedback Shift Registers With\tthe\tincreasing\tuse\tof\thighly\tconstrained\tdevices\tthere\thas\tbeen\tincreasing\tinterest\tin\tdeveloping\tnew\tstream\tciphers\tthat\ttake\tup\tminimal\tmemory,\tare\thighly\tefficient,\tand\thave\tminimal\tpower\tconsumption\trequirements. Most\tof\tthe\trecently\tdeveloped\tstream\tciphers\tare\tbased\ton\tthe\tuse\tof\tfeedback\tshift\tregisters\t(FSRs).\nFSRs\texhibit\tthe\tdesired\tperformance\tbehavior,\tare\twell-suited\tto\tcompact\thardware\timplementation,\tand\tthere\tare\twell-developed\ttheoretical\tresults\ton\tthe\tstatistical properties\tof\tthe\tbit\tsequences\tthey\tproduce.\nAn\tFSR\tconsists\tof\ta\tsequence\tof\t1-bit\tmemory\tcells. Each\tcell\thas\tan\toutput\tline,\twhich\tindicates\tthe\tvalue\tcurrently\tstored,\tand\tan\tinput\tline. At\tdiscrete\ttime\tinstants,\tknown\tas\tclock\ttimes,\tthe\tvalue\tin\teach\tstorage\tdevice\tis\treplaced\tby\tthe\tvalue\tindicated\tby\tits\tinput\tline. The\teffect\tis\tas\tfollows:\tThe\trightmost\t(least\tsignificant)\tbit\tis\tshifted\tout\tas the\toutput\tbit\tfor\tthis\tclock\tcycle;\tthe\tother\tbits\tare\tshifted\tone\tbit\tposition\tto\tthe\tright;\tthe\tnew\tleftmost\t(most\tsignificant)\tbit\tis\tcalculated\tas\ta\tfunction\tof\tthe\tother\tbits\tin\tthe\tFSR. Grain-128a Grain\tis\ta\tfamily\tof\thardware-efficient\tstream\tciphers. Grain\twas\taccepted\tas\tpart\tof\tthe\teSTREAM\teffort\tto\tapprove\ta\tnumber\tof\tnew\tstream\tciphers. The\teSTREAM\tspecification,\tcalled\tGrain\tv1,\tdefines\ttwo\tstream\tciphers,\tone\twith\tan\t80-bit\tkey\tand\ta\t64-bit\tinitialization\tvector\t(IV),\tand\tone\twith\ta\t128-bit\tkey\tand\t80-bit\tIV.\tGrain\thas\tsince\tbeen\trevised\tand\texpanded\tto\tinclude\tauthentication,\treferred\tto\tas\tGrain-128a. The\teSTREAM\tfinal\treport\tstates\tthat\tGrain\thas\tpushed\tthe\tstate\tof\tthe\tart\tin\tterms\tof\tcompact\timplementation.\nGrain-128a\tconsists\tof\ttwo\tshift\tregisters,\tone\twith\tlinear\tfeedback\tand\tthe\tsecond\twith\tnonlinear\tfeedback,\tand\ta\tfilter\tfunction. The\tregisters\tare\tcouple\tby\tvery\tlightweight,\tbut\tjudiciously\tchosen\tBoolean\tfunctions. The\tLFSR\tguarantees\ta\tminimum\tperiod\tfor\tthe\tkeystream,\tand\tit\talso\tprovides\tbalance\tin\tthe\toutput.\tThe\tNFSR,\ttogether\twith\ta\tnonlinear\tfilter,\tintroduces\tnonlinearity\tto\tthe\tcipher. The\tinput\tto\tthe\tNFSR\tis\tmasked\twith\tthe\toutput\tof\tthe\tLFSR\tso\tthat\tthe\tstate\tof\tthe\tNFSR\tis\tbalanced.\nTrue Random Number Generators Entropy\tSources A\ttrue\trandom\tnumber\tgenerator\t(TRNG)\tuses\ta\tnondeterministic\tsource\tto\tproduce\trandomness. Most\toperate\tby\tmeasuring\tunpredictable\tnatural\tprocesses\tsuch\tas\tpulse\tdetectors\tof\tionizing\tradiation\tevents,\tgas\tdischarge\ttubes,\tand\tleaky\tcapacitors. Intel\thas\tdeveloped\ta\tcommercially\tavailable\tchip\tthat\tsamples\tthermal\tnoise\tby\tamplifying\tthe\tvoltage\tmeasured\tacross\tundriven\tresistors.\nLavaRnd\tis\tan\topen\tsource\tproject\tfor\tcreating\ttruly\trandom\tnumbers\tusing\tinexpensive\tcameras,\topen\tsource\tcode,\tand\tinexpensive\thardware. The\tsystem\tuses\ta\tsaturated\tCCD\tin\ta\tlight-tight\tcan\tas\ta\tchaotic\tsource\tto\tproduce\tthe\tseed;\tsoftware\tprocesses\tthe\tresult\tinto\ttruly\trandom\tnumbers\tin\ta\tvariety\tof\tformats.\nPossible\tSources\tof\tRandomness RFC 4086 lists the following possible sources of randomness that can be used on a computer to generate true random sequences:\nSound/Video Input: The input from a sound digitizer with no source plugged in or from a camera with the lens cap on is essentially thermal noise. If the system has enough gain to detect anything, such input can provide reasonable high-quality random bits. Disk Drives Have small random fluctuations in their rotational speed due to chaotic air turbulence. The addition of low-level disk seek-time instrumentation produces a series of measurements that contain this randomness. Note: There is also an online service (random.org) which can deliver random sequences securely over the Internet.\nFig. 4: Comparison\tof\tPRNGs\tand\tTRNGs. Conditioning A TRNG may produce an output that is biased in some way (such as having more ones than zeros or vice versa)\nBiased: NIST SP 800-90B defines a random process as biased with respect to an assumed discrete set of potential outcomes if some of those outcomes have a greater probability of occurring than do others\nEntropy rate:\nNIST 800-90B defines entropy rate as the rate at which a digitized noise source provides entropy. Is a measure of the randomness or unpredictability of a bit string. Will be a value between 0 (no entropy) and 1 (full entropy). Conditioning algorithms/deskewing algorithms: Methods of modifying a bit stream to further randomize the bits.\nTypical conditioning methods: is done by using a cryptographic algorithm to scramble the random bits so as to eliminate bias and increase entropy. The two most common approaches are the use of a hash function or a symmetric block cipher.\nHash\tFunction A hash function produces an n-bit output from an input of arbitrary length\nA simple way to use a hash function for conditioning is as follows:\nBlocks of m input bits, with m ≥ n, are passed through the hash function and the n output bits are used as random bits To generate a stream of random bits, successive input blocks pass through the hash function to produce successive hashed output blocks Health\tTests\ton\tthe\tNoise\tSource The\tnature\tof\tthe\thealth\ttesting\tof\tthe\tnoise\tsource depends\tstrongly\ton\tthe\ttechnology\tused\tto\tproduce\tnoise.\nIn\tgeneral,\tthe\tassumption\tcan\tbe\tmade\tthat\tthe\tdigitized\toutput\tof\tthe\tnoise\tsource\twill\texhibit\tsome\tbias. Thus,\ttraditional\tstatistical\ttests\tare\tnot\tuseful\tfor\tmonitoring\tthe\tnoise\tsource,\tbecause\tthe\tnoise\tsource\tis\tlikely\tto\talways\tfail. The\ttests\ton\tthe\tnoise\tsource\tneed\tto\tbe\ttailored\tto\tthe\texpected\tstatistical\tbehavior\tof\tthe\tcorrectly\toperating\tnoise\tsource. The\tgoal\tis\tnot\tto\tdetermine\tif\tthe\tsource\tis\tunbiased,\tbut\tif\tit\tis\toperating\tas\texpected.\nSP 800-90B specifies that continuous tests be done on digitized samples obtained from the noise source.\nThe purpose is to test for variability and to determine if the noise source is producing at the expected entropy rate. SP 800-90B mandates the use of two tests:\nRepetition Count Test Designed to quickly detect a catastrophic failure that causes the noise source to become “stuck” on a single output value for a long time. Involves looking for consecutive identical samples. Adaptive Proportion Test Designed to detect a large loss of entropy, such as might occur as a result of some physical failure or environmental change affecting the noise source. The test continuously measures the local frequency of occurrence of some sample value in a sequence of noise source samples to determine if the sample occurs too frequently. SP 800-90B specifies that health tests should also be applied to the output of the conditioning component, but does not indicate which tests to use. The purpose of the health tests on the conditioning component is to assure that the output behaves as a true random bit stream. It is reasonable to use the tests for randomness defined in SP 800-22.\nIntel Digital Random Number Generator TRNGs have traditionally been used only for key generation and other applications where only a small number of random bits were required. This is because TRNGs have generally been inefficient with a low bit rate of random bit production.\nThe first commercially available TRNG that achieves bit production rates comparable with that of PRNGs is the Intel digital random number generator offered on new multicore chips since May 2012. It is implemented entirely in hardware. The entire DRNG is on the same multicore chip as the processors.\nCitation Cited as:\nRandom Bit Generation and Stream Ciphers https://mnguyen0226.github.io/posts/info_security_8/post/ Or\n@article{nguyen2023rbgsc, title = \u0026#34;Random Bit Generation and Stream Ciphers\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;October\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/info_security_8/post/\u0026#34; } References [1] Pearson, https://www.pearson.com/en-us/subject-catalog/p/Stallings-Pearson-e-Text-for-Cryptography-and-Network-Security-Principles-and-Practice-Access-Card-8th-Edition/P200000003477 (accessed Oct. 09, 2023).\nFig. 5: Cloud gate, Chicago, Illinois, U.S.A.(Image Source: Antonio Gabola @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/info_security_8/post/","summary":"[v.1.0] (10/09/2023): Post started!\nPrinciples of Pseudorandom Number Generation Random Number A\tnumber\tof\tnetwork\tsecurity\talgorithms\tand\tprotocols based\ton\tcryptography\tmake\tuse\tof\trandom\tbinary\tnumbers:\nKey\tdistribution\tand\treciprocal\tauthentication\tschemes. Session\tkey\tgeneration. Generation\tof\tkeys\tfor\tthe\tRSA\tpublic-key\tencryption\talgorithm.. Generation\tof\ta\tbit\tstream\tfor\tsymmetric\tstream\tencryption. There\tare\ttwo\tdistinct\trequirements\tfor\ta\tsequence\tof\trandom\tnumbers: Randomness\tand Unpredictability.\nRandomness The\tgeneration\tof\ta\tsequence\tof\tallegedly\trandom\tnumbers\tbeing\trandom\tin\tsome\twell-defined\tstatistical\tsense\thas\tbeen\ta\tconcern.","title":"Random Bit Generation and Stream Ciphers"},{"content":"[v.1.0] (10/02/2023): Post started!\nMultiple Encryption and Triple DES Meet-in-the-Middle\tAttack The\tuse\tof\tdouble\tData Encryption Standard (DES) results\tin\ta\tmapping\tthat\tis\tnot\tequivalent\tto\ta\tsingle\tDES\tencryption.\nThe\tmeet-in-the-middle\tattack\talgorithm\twill\tattack\tthis\tscheme\tand\tdoes\tnot\tdepend\ton\tany\tparticular\tproperty\tof\tDES\tbut\twill\twork\tagainst\tany block\tencryption\tcipher.\nTriple\tDES\twith\tThree\tKeys Many\tresearchers\tnow\tfeel\tthat\tthree-key\t3DES\tis\tthe\tpreferred\talternative. A\tnumber\tof\tInternet-based\tapplications\thave\tadopted\tthree-key\t3DES\tincluding\tPGP\tand\tS/MIME.\nElectronic Codebook Modes\tof\tOperation A\ttechnique\tfor\tenhancing\tthe\teffect\tof\ta\tcryptographic\talgorithm\tor\tadapting\tthe\talgorithm\tfor\tan\tapplication.\nTo\tapply\ta\tblock\tcipher\tin\ta\tvariety\tof\tapplications,\tfive\tmodes\tof\toperation\thave\tbeen\tdefined\tby\tNIST.\nThe\tfive\tmodes\tare\tintended\tto\tcover\ta\twide\tvariety\tof\tapplications\tof\tencryption\tfor\twhich\ta\tblock\tcipher\tcould\tbe\tused. These\tmodes\tare\tintended\tfor\tuse\twith\tany\tsymmetric\tblock\tcipher,\tincluding\ttriple\tDES\tand\tAES. Fig. 1: Block Cipher Modes of Operation. Advantages\tand\tLimitations\tof\tECB Repetitions\tin\tmessage\tmay\tshow\tin\tciphertext:\nif\taligned\twith\tmessage\tblock. particularly\twith\tdata\tsuch\tgraphics/images. or\twith\tmessages\tthat\tchange\tvery\tlittle,\twhich\tbecome\ta\tcode-book\tanalysis\tproblem. Weakness\tdue\tto\tencrypted\tmessage\tblocks\tbeing\tindependent.\nMain\tuse\tis\tsending\ta\tfew\tblocks\tof\tdata.\nCriteria\tand\tproperties\tfor\tevaluating\tand\tconstructing\tblock\tcipher\tmodes\tof\toperation\tthat\tare\tsuperior\tto\tECB:\nOverhead. Error\trecovery. Error\tpropagation. Diffusion. Security. Advantages\tand\tLimitations\tof\tCBC Each\tciphertext\tblock\tdepends\ton\tall\tprevious\tmessage\tblocks. Thus\ta\tchange\tin\tthe\tmessage\tblock\taffects\tall\tthe\tfollowing\tciphertext\tblocks\tas\twell\tas\tthe\toriginal\tblock. Need\tInitial\tValue\t(IV)\tknown\tto\tsender\t\u0026amp;\treceiver. Either\tIV\tmust\tbe\ta\tfixed\tvalue\tor\tit\tmust\tbe\tsent\tencrypted\tin\tECB\tmode\tbefore\trest\tof\tmessage. At\tend\tof\tmessage,\thandle\tpossible\tlast\tshort\tblock by\tpadding\twith\tknown\tnon-data\tvalue\t(e.g.,\tnulls).\nAdvantages of\tCTR Hardware\tefficiency. Software\tefficiency. Preprocessing. Random\taccess. Provable\tsecurity. Simplicity. XTS-AES Mode for Block-Oriented Storage Devices Approved\tas\tan\tadditional\tblock\tcipher\tmode\tof\toperation\tby\tNIST\tin\t2010.\nMode\tis\talso\tan\tIEEE\tStandard,\tIEEE\tStd 1619-2007.\nStandard\tdescribes\ta\tmethod\tof\tencryption\tfor\tdata\tstored\tin\tsector-based\tdevices\twhere\tthe\tthreat\tmodel\tincludes\tpossible\taccess\tto\tstored\tdata\tby\tthe\tadversary. Has\treceived\twidespread\tindustry\tsupport. Tweakable\tBlock\tCiphers XTS-AES\tmode\tis\tbased\ton\tthe\tconcept\tof\ta\ttweakable\tblock\tcipher.\nTweak\tneed\tnot\tbe\tkept\tsecret: purpose\tis\tto\tprovide\tvariability\nStorage\tEncryption\tRequirements The\trequirements\tfor\tencrypting\tstored\tdata,\talso\treferred\tto\tas\t“data at\trest”,\tdiffer\tsomewhat\tfrom\tthose\tfor\ttransmitted\tdata.\nThe\tP1619\tstandard\twas\tdesigned\tto\thave\tthe\tfollowing\tcharacteristics:\nThe\tciphertext\tis\tfreely\tavailable\tfor\tan\tattacker. The\tdata\tlayout\tis\tnot\tchanged\ton\tthe\tstorage\tmedium\tand\tin\ttransit. Data\tare\taccessed\tin\tfixed\tsized\tblocks,\tindependently\tfrom\teach\tother. Encryption\tis\tperformed\tin\t16-byte\tblocks,\tindependently\tfrom\teach\tother. There\tare\tno\tother\tmetadata\tused,\texcept\tthe\tlocation\tof\tthe\tdata\tblocks within\tthe\twhole\tdata\tset. The\tsame\tplaintext\tis\tencrypted\tto\tdifferent\tciphertexts\tat\tdifferent locations,\tbut\talways\tto\tthe\tsame\tciphertext\twhen\twritten\tto\tthe\tsame location\tagain. A\tstandard\tconformant\tdevice\tcan\tbe\tconstructed\tfor\tdecryption\tof\tdata encrypted\tby\tanother\tstandard\tconformant\tdevice. Citation Cited as:\nBlock Cipher Operation https://mnguyen0226.github.io/posts/info_security_7/post/ Or\n@article{nguyen2023bco, title = \u0026#34;Block Cipher Operation\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;October\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/info_security_7/post/\u0026#34; } References [1] Pearson, https://www.pearson.com/en-us/subject-catalog/p/Stallings-Pearson-e-Text-for-Cryptography-and-Network-Security-Principles-and-Practice-Access-Card-8th-Edition/P200000003477 (accessed Oct. 02, 2023).\nFig. 2: Boise, Idaho, U.S.A (Image Source: Alden Skeie @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/info_security_7/post/","summary":"[v.1.0] (10/02/2023): Post started!\nMultiple Encryption and Triple DES Meet-in-the-Middle\tAttack The\tuse\tof\tdouble\tData Encryption Standard (DES) results\tin\ta\tmapping\tthat\tis\tnot\tequivalent\tto\ta\tsingle\tDES\tencryption.\nThe\tmeet-in-the-middle\tattack\talgorithm\twill\tattack\tthis\tscheme\tand\tdoes\tnot\tdepend\ton\tany\tparticular\tproperty\tof\tDES\tbut\twill\twork\tagainst\tany block\tencryption\tcipher.\nTriple\tDES\twith\tThree\tKeys Many\tresearchers\tnow\tfeel\tthat\tthree-key\t3DES\tis\tthe\tpreferred\talternative.","title":"Block Cipher Operation"},{"content":"[v.1.0] (10/2/2023): Post started (On-going)!\nLinked Lists In the previous post, we learnt that List can be implemented in ArrayLists or LinkedLists and they both behave in the same way. So why choose one over the other?\nAlthough the functional behaviours of ArrayLists and LinkedLists are the same, their performance behaviours are different. If we need to access or update a value, ArrayLists is a to-go choice, but if we anticipate to insert or delete value in the middle of the array, we should choose LinkedLists.\nFig. 1: LinkedList vs ArrayList. Let\u0026rsquo;s look at the example of List implemented using ArrayList\n/** * A dynamic array implementation of the List interface. * * @param \u0026lt;E\u0026gt; the type of elements in this list */ public class ArrayList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt; { private E[] elements; private int size; private int capacity; /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList(){ size = 0; capacity = 10; elements = (E[]) new Object[capacity]; } /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list */ public void add(E e){ if(size == capacity){ ensureCapacity(); } elements[size++] = e; } /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position * @throws IndexOutOfBoundsException if the index is out of range */ public E get(int index){ if(index \u0026lt; 0 || index \u0026gt;= size){ throw new IndexOutOfBoundsException(); } return elements[index]; } /** * Removes the element at the specified position in this list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException if the index is out of range */ public E remove(int index){ if(index \u0026lt; 0 || index \u0026gt;= size){ throw new IndexOutOfBoundsException(); } E removedElement = elements[index]; for(int i=index; i\u0026lt;size-1; i++){ elements[i] = elements[i+1]; } size--; return removedElement; } /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size(){ return size; } /** * Increases the capacity of the array if necessary to ensure that it can hold at least the number of elements specified by the minimum capacity argument. */ private void ensureCapacity(){ int newCapacity = capacity * 2; E[] newElements = (E[]) new Object[newCapacity]; for(int i=0; i\u0026lt;size; i++){ newElements[i] = elements[i]; } elements = newElements; capacity = newCapacity; } } Let\u0026rsquo;s look at the example of List implemented using LinkedList\n/** * A doubly-linked list implementation. * * @param \u0026lt;E\u0026gt; the type of elements in this list */ public class LinkedList\u0026lt;E\u0026gt;{ private static class Node\u0026lt;E\u0026gt; { E element; Node\u0026lt;E\u0026gt; next; Node\u0026lt;E\u0026gt; previous; Node(E element, Node\u0026lt;E\u0026gt; next, Node\u0026lt;E\u0026gt; previous){ this.element = element; this.next = next; this.previous = previous; } } private Node\u0026lt;E\u0026gt; header; private int size = 0; /** * Constructs an empty list. */ public LinkedList(){ header = new Node\u0026lt;E\u0026gt;(null, null, null); header.next = header; header.previous = header; } /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list */ public void add(E e){ Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(e, header, header.previous); header.previous.next = newNode; header.previous = newNode; size++; } /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position * @throws IndexOutOfBoundsException if the index is out of range */ public E get(int index){ if(index \u0026lt; 0 || index \u0026gt;= size){ throw new IndexOutOfBoundsException(); } Node\u0026lt;E\u0026gt; current = header.next; for(int i=0; i\u0026lt;index; i++){ current = current.next; } return current.element; } /** * Removes the element at the specified position in this list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException if the index is out of range */ public E remove(int index){ if(index \u0026lt; 0 || index \u0026gt;= size){ throw new IndexOutOfBoundsException(); } Node\u0026lt;E\u0026gt; current = header.next; for(int i=0; i\u0026lt;index; i++){ current = current.next; } current.previous.next = current.next; current.next.previous = current.previous; size--; return current.element; } /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size(){ return size; } } Citation Cited as:\nNguyen, Minh. (October 2023). Java Fundamentals (Part 4) https://mnguyen0226.github.io/posts/java_fundamentals_4/post/ Or\n@article{nguyen2023java4, title = \u0026#34;Java Fundamentals (Part 4)\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;October\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/java_fundamentals_4/post/\u0026#34; } References [1] P. Deitel, Java: How To Program, Early Objects: Pearson, 2017\n[2] Horstmann, Cay S. Big Java: Early Objects. John Wiley \u0026amp; Sons, 2020.\nFig. 2: Pinnacle Mountain State Park, Big Rock Township, Arkansas, U.S.A (Image Source: Joshua J. Cotten @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/java_fundamentals_4/post/","summary":"[v.1.0] (10/2/2023): Post started (On-going)!\nLinked Lists In the previous post, we learnt that List can be implemented in ArrayLists or LinkedLists and they both behave in the same way. So why choose one over the other?\nAlthough the functional behaviours of ArrayLists and LinkedLists are the same, their performance behaviours are different. If we need to access or update a value, ArrayLists is a to-go choice, but if we anticipate to insert or delete value in the middle of the array, we should choose LinkedLists.","title":"Java Fundamentals (Part 4)"},{"content":"[v.1.0] (09/27/2023): Post started!\nAdvanced Encryption Standard (AES) Background A clear replacement for DES was needed as DES have demonstrated exhaustive key search attacks. We can definitely use Triple-DES; however, it is slow with small blocks. In 1997, US NIST issued call for cipher in which 15 candidates accepted in June 1998 and 5 were shortlisted in August 1999. Rijndael was selected as the AES in October 2000 and issues as FIPS PUB 107 standard in November 2001.\nAES Requiremnets Secret\tkey\tsymmetric\tblock\tcipher. 128-bit\tdata,\t128/192/256-bit\tkeys. Stronger\t\u0026amp;\tfaster\tthan\tTriple-DES. Active\tlife\tof\t20-30\tyears\t(+\tarchival\tuse). Provide\tfull\tspecification\t\u0026amp;\tdesign\tdetails. Both\tC\t\u0026amp;\tJava\timplementations. NIST\thave\treleased\tall\tsubmissions\t\u0026amp;\tunclassified\tanalyses. AES Evaluation Criteria General\tsecurity. Software\t\u0026amp;\thardware\timplementation\tease. Implementation\tattacks: Timing\tattacks\tand\tPower\tanalysis. Flexibility\t(in\ten/decrypt,\tkeying,\tother\tfactors) The AES Cipher - Rijndael The cipher was designed\tby\tRijmen-Daemen\tin\tBelgium. It has\t128/192/256\tbit\tkeys,\t128\tbit\tdata. It is an\titerative\trather\tthan\tfeistel\tcipher. AES treats data in 4 groups of 4 bytes, and operates an entire block in every round.\nAES cipher was designed to be resistant against known attacks, to have speed/code compactness on many CPUs, and to be simple.\nAES processes\tdata\tas\t4\tgroups\tof\t4\tbytes\t(state). The\tkey\tis\texpanded\tinto\t44/52/60\t(32-bit)\twords.\nAES has\t10/12/14\trounds\tin\twhich\tstate\tundergoes:\nbyte\tsubstitution\t(one\tS-box\tused\ton\tevery\tbyte). shift\trows\t(simple\tpermutation). mix\tcolumns\t(subs\tusing\tmatrix\tmultiply\tof\tgroups). add\tround\tkey\t(XOR\tstate\twith\ta\tportion\tof\texpanded\tkey). AES has all\toperations\tcan\tbe\tcombined\tinto\tXOR\tand\ttable\tlookups\t-\thence\tvery\tfast\t\u0026amp;\tefficient.\nFinite Field Arithmetic In the AES, all\toperations are\tperformed\ton\t8-bit\tbytes. The\tarithmetic\toperations\tof\taddition,\tmultiplication,\tand\tdivision\tare\tperformed\tover\tthe\tfinite\tfield\tGF(2^8). A\tfield\tis\ta\tset\tin\twhich\twe\tcan\tdo\taddition,\tsubtraction, multiplication,\tand\tdivision\twithout\tleaving\tthe\tset. Division\tis\tdefined\twith\tthe\tfollowing\trule:\ta\t/b\t=\ta\t(b^-1). An\texample\tof\ta\tfinite\tfield\t(one\twith\ta\tfinite\tnumber\tof elements)\tis\tthe\tset\tZ_p\tconsisting\tof\tall\tthe\tintegers {0,\t1,\t.\t.\t.\t.\t,\tp\t-\t1},\twhere\tp\tis\ta\tprime\tnumber\tand\tin\twhich\tarithmetic\tis\tcarried\tout\tmodulo\tp.\nIf one of the operations used in the algorithm is division, then we need to work in arithmetic defined over a field. Division requires that each nonzero element have a multiplicative inverse.\nFor convenience and for implementation efficiency we would like to work with integers that fit exactly into a given number of bits with no wasted bit patterns. Integers in the range 0 through 2^n - 1, which fit into an n-bit word.\nThe set of such integers, Z_n, using modular arithmetic, is not a field. For example, the integer 2 has no multiplicative inverse in Z_n. That is, there is no integer b, such that 2b mod 2^n = 1.\nA finite field containing 2^n elements is referred to as GF(2^n). Every polynomial in GF(2^n) can be represented by an n-bit number.\nAES Structure Processes\tthe\tentire\tdata\tblock\tas\ta\tsingle\tmatrix\tduring\teach\tround\tusing\tsubstitutions\tand\tpermutation.\nThe\tkey\tthat\tis\tprovided\tas\tinput\tis\texpanded\tinto\tan\tarray\tof\tforty-four\t32-bit\twords,\tw[i].\nFour Stages Substitute\tbytes\t–\tuses\tan\tS-box\tto\tperform\ta\tbyte-by-byte\tsubstitution\tof\tthe\tblock. ShiftRows\t–\ta\tsimple\tpermutation. MixColumns\t–\ta\tsubstitution\tthat\tmakes\tuse\tof\tarithmetic\tover\tGF(2^8). AddRoundKey\t–\ta\tsimple\tbitwise\tXOR\tof\tthe\tcurrent\tblock\twith\ta\tportion\tof\tthe\texpanded\tkey. The\tcipher\tbegins\tand\tends\twith\tan\tAddRoundKey\tstage. Can\tview\tthe\tcipher\tas\talternating\toperations\tof\tXOR\tencryption\t(AddRoundKey)\tof\ta\tblock,\tfollowed\tby\tscrambling\tof\tthe\tblock\t(the\tother\tthree\tstages),\tfollowed\tby\tXOR\tencryption,\tand\tso\ton. Each\tstage\tis\teasily\treversible. The\tdecryption\talgorithm\tmakes\tuse\tof\tthe\texpanded\tkey\tin\treverse\torder,\thowever\tthe\tdecryption\talgorithm\tis\tnot\tidentical\tto\tthe\tencryption\talgorithm. State\tis\tthe\tsame\tfor\tboth\tencryption\tand\tdecryption. Final\tround\tof\tboth\tencryption\tand\tdecryption\tconsists\tof\tonly\tthree\tstages.\nAES Transformation Functions Byte\tSubstitution A simple\tsubstitution\tof\teach\tbyte; uses\tone\ttable\tof\t16x16\tbytes\tcontaining\ta\tpermutation\tof\tall\t256\t8-bit\tvalues.\nEach\tbyte\tof\tstate\tis\treplaced\tby\tbyte\tin row\t(left\t4-bits)\t\u0026amp;\tcolumn\t(right\t4-bits)\te.g.,\tbyte\t{95}\tis\treplaced\tby\trow\t9\tcol\t5\tbyte\twhich\tis\tthe\tvalue\t{2A}.\nS-box\tis\tconstructed\tusing\ta\tdefined\ttransformation\tof\tthe\tvalues\tin\tGF(2^8) designed\tto\tbe\tresistant\tto\tall\tknown\tattacks.\nS-Box\tRationale:\nThe\tS-box\tis\tdesigned\tto\tbe\tresistant\tto\tknown\tcryptanalytic\tattacks. The\tRijndael\tdevelopers\tsought\ta\tdesign\tthat\thas\ta\tlow\tcorrelation\tbetween\tinput\tbits\tand\toutput\tbits\tand\tthe\tproperty\tthat\tthe\toutput\tis\tnot\ta\tlinear\tmathematical\tfunction\tof\tthe\tinput. The\tnonlinearity\tis\tdue\tto\tthe\tuse\tof\tthe\tmultiplicative\tinverse. Shift\tRows A\tcircular\tbyte\tshift\tin\teach\teach:\n1st\trow\tis\tunchanged. 2nd\trow\tdoes\t1\tbyte\tcircular\tshift\tto\tleft. 3rd\trow\tdoes\t2\tbyte\tcircular\tshift\tto\tleft. 4th\trow\tdoes\t3\tbyte\tcircular\tshift\tto\tleft. Decrypt\tdoes\tshifts\tto\tright.\nShift\tRow\tRationale:\nMore\tsubstantial\tthan\tit\tmay\tfirst\tappear The\tState,\tas\twell\tas\tthe\tcipher\tinput\tand\toutput,\tis\ttreated\tas\tan\tarray\tof\tfour\t4-byte\tcolumns. On\tencryption,\tthe\tfirst\t4\tbytes\tof\tthe\tplaintext\tare\tcopied\tto\tthe\tfirst\tcolumn\tof\tState,\tand\tso\ton. The\tround\tkey\tis\tapplied\tto\tState\tcolumn\tby\tcolumn. Thus,\ta\trow\tshift\tmoves\tan\tindividual\tbyte\tfrom\tone\tcolumn\tto\tanother,\twhich\tis\ta\tlinear\tdistance\tof\ta multiple\tof\t4\tbytes. Transformation\tensures\tthat\tthe\t4\tbytes\tof\tone\tcolumn\tare\tspread\tout\tto\tfour\tdifferent\tcolumns. Mix\tColumns Each\tcolumn\tis\tprocessed\tseparately. Each\tbyte\tis\treplaced\tby\ta\tvalue\tdependent\ton\tall\t4\tbytes\tin\tthe\tcolume, effectively\ta\tmatrix\tmultiplication\tin\tGF(2^8) using\tprime\tpoly\tm(x)=x^8+x^4+x^3+x+1.\nMix\tColumns\tRationale:\nCoefficients\tof\ta\tmatrix\tbased\ton\ta\tlinear\tcode\twith\tmaximal\tdistance\tbetween\tcode\twords\tensures\ta\tgood\tmixing\tamong\tthe\tbytes\tof\teach\tcolumn. The\tmix\tcolumn\ttransformation\tcombined\twith\tthe\tshift\trow\ttransformation\tensures\tthat\tafter\ta\tfew\trounds\tall\toutput\tbits\tdepend\ton\tall\tinput\tbits. AddRoundKey The\t128\tbits\tof\tState\tare\tbitwise\tXORed\twith\tthe\t128\tbits\tof\tthe\tround\tkey.\nOperation\tis\tviewed\tas\ta columnwise\toperation\tbetween\tthe\t4\tbytes\tof\ta\tState\tcolumn\tand\tone\tword\tof\tthe\tround\tkey. Can\talso\tbe\tviewed\tas\ta\tbyte-level\toperation.\nAddRoundKey Rationale:\nIs\tas\tsimple\tas\tpossible\tand\taffects\tevery\tbit\tof\tState. The\tcomplexity\tof\tthe\tround\tkey\texpansion\tplus\tthe\tcomplexity\tof\tthe\tother\tstages\tof\tAES\tensure\tsecurity. AES Key Expansion Takes\tas\tinput\ta\tfour-word\t(16\tbyte)\tkey\tand\tproduces\ta\tlinear\tarray\tof\t44\twords\t(176)\tbytes. This\tis\tsufficient\tto\tprovide\ta\tfour-word\tround\tkey\tfor\tthe\tinitial\tAddRoundKey\tstage\tand\teach\tof\tthe\t10\trounds\tof\tthe\tcipher.\nKey\tis\tcopied\tinto\tthe\tfirst\tfour\twords\tof\tthe\texpanded\tkey. The\tremainder\tof\tthe\texpanded\tkey\tis\tfilled\tin\tfour\twords\tat\ta\ttime.\nEach\tadded\tword\tw[i]\tdepends\ton\tthe\timmediately\tpreceding\tword,\tw[i\t–\t1],\tand\tthe\tword\tfour\tpositions\tback,\tw[i\t–\t4].\tIn\tthree\tout\tof\tfour\tcases\ta\tsimple\tXOR\tis\tused. For\ta\tword\twhose\tposition\tin\tthe\tw\tarray\tis\ta\tmultiple\tof\t4`,\ta more\tcomplex\tfunction\tis\tused.\nKey\tExpansion\tRationale\nThe\tRijndael\tdevelopers\tdesigned\tthe\texpansion\tkey\talgorithm\tto\tbe\tresistant\tto\tknown\tcryptanalytic\tattacks. Inclusion\tof\ta\trounddependent\tround constant eliminates\tthe\tsymmetry\tbetween\tthe\tways\tin\twhich\tround\tkeys are\tgenerated\tin\tdifferent\trounds. The\tspecific\tcriteria\tthat\twere\tused\tare: Knowledge\tof\ta\tpart\tof\tthe\tcipher\tkey\tor round\tkey\tdoes\tnot\tenable\tcalculation of\tmany\tother\tround-key\tbits. An\tinvertible\ttransformation. Speed\ton\ta\twide\trange\tof\tprocessors. Usage\tof\tround\tconstants\tto\teliminate\tsymmetries. Diffusion\tof\tcipher\tkey\tdifferences\tinto\tthe\tround\tkeys. Enough\tnonlinearity\tto\tprohibit\tthe\tfull\tdetermination\tof\tround\tkey\tdifferences from\tcipher\tkey\tdifferences\tonly. Simplicity\tof\tdescription. AES Implementation AES\tdecryption\tcipher\tis\tnot\tidentical\tto\tthe encryption\tcipher\nThe\tsequence\tof\ttransformations\tdiffers\talthough\tthe\tform\tof\tthe key\tschedules\tis\tthe\tsame. Has\tthe\tdisadvantage\tthat\ttwo\tseparate\tsoftware\tor\tfirmware\tmodules\tare\tneeded\tfor\tapplications\tthat\trequire\tboth\tencryption\tand\tdecryption. Two\tseparate\tchanges\tare\tneeded\tto\tbring\tthe\tdecryption\tstructure\tin\tline\twith\tthe\tencryption\tstructure. The\tfirst\ttwo\tstages\tof\tthe\tdecryption\tround\tneed\tto\tbe\tinterchanged. The\tsecond\ttwo\tstages\tof\tthe\tdecryption\tround\tneed\tto\tbe interchanged.\nInterchanging\tInvShiftRows\tand\tInvSubBytes InvShiftRows\taffects\tthe\tsequence\tof\tbytes\tin\tState\tbut\tdoes\tnot\talter\tbyte\tcontents\tand\tdoes\tnot\tdepend\ton\tbyte\tcontents\tto\tperform\tits\ttransformation.\nInvSubBytes\taffects\tthe\tcontents\tof\tbytes\tin\tState\tbut\tdoes\tnot\talter\tbyte\tsequence\tand\tdoes\tnot\tdepend\ton\tbyte\tsequence\tto\tperform\tits\ttransformation.\nThus,\tthese\ttwo\toperations\tcommute\tand\tcan\tbe\tinterchanged.\nInterchanging\tAddRoundKey\tand\tInvMixColumns The\ttransformations\tAddRoundKey and\tInvMixColumns do\tnot\talter\tthe\tsequence\tof bytes\tin\tState.\nIf\twe\tview\tthe\tkey\tas\ta\tsequence\tof\twords,\tthen\tboth\tAddRoundKey and\tInvMixColumns operate\ton\tState\tone\tcolumn\tat\ta time.\nThese\ttwo\toperations\tare\tlinear\twith\trespect\tto\tthe\tcolumn\tinput.\nImplementation\tAspects AES\tcan\tbe\timplemented\tvery\tefficiently\ton\tan\t8-bit\tprocessor. AddRoundKey\tis\ta\tbytewise\tXOR\toperation. ShiftRows\tis\ta\tsimple\tbyte-shifting\toperation. SubBytes\toperates\tat\tthe\tbyte\tlevel\tand\tonly\trequires\ta\ttable\tof\t256\tbytes.\tMixColumns\trequires\tmatrix\tmultiplication\tin\tthe\tfield\tGF(28),\twhich\tmeans\tthat\tall\toperations\tare\tcarried\tout\ton\tbytes.\nCan\tefficiently\timplement\ton\ta\t32-bit\tprocessor:\nRedefine\tsteps\tto\tuse\t32-bit\twords. Can\tprecompute\t4\ttables\tof\t256-words. Then\teach\tcolumn\tin\teach\tround\tcan\tbe\tcomputed\tusing\t4\ttable\tlookups\t+\t4\tXORs. At\ta\tcost\tof\t4Kb\tto\tstore\ttables. Designers\tbelieve\tthis\tvery\tefficient\timplementation\twas\ta\tkey\tfactor\tin\tits\tselection\tas\tthe\tAES\tcipher.\nCitation Cited as:\nAdvanced Encryption Standard https://mnguyen0226.github.io/posts/info_security_6/post/ Or\n@article{nguyen2023aes, title = \u0026#34;Advanced Encryption Standard\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;September\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/info_security_6/post/\u0026#34; } References [1] Pearson, https://www.pearson.com/en-us/subject-catalog/p/Stallings-Pearson-e-Text-for-Cryptography-and-Network-Security-Principles-and-Practice-Access-Card-8th-Edition/P200000003477 (accessed Sept. 27, 2023).\nFig. 1: Northern Beach, Hawaii, U.S.A (Image Source: Luke McKeown @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/info_security_6/post/","summary":"[v.1.0] (09/27/2023): Post started!\nAdvanced Encryption Standard (AES) Background A clear replacement for DES was needed as DES have demonstrated exhaustive key search attacks. We can definitely use Triple-DES; however, it is slow with small blocks. In 1997, US NIST issued call for cipher in which 15 candidates accepted in June 1998 and 5 were shortlisted in August 1999. Rijndael was selected as the AES in October 2000 and issues as FIPS PUB 107 standard in November 2001.","title":"Advanced Encryption Standard"},{"content":"[v.1.0] (09/25/2023): Post published!\nTest-Driven Development Types Of Tests In software development, there are different ways to test softwares:\nBeta testing: Provides a finished or near-finished application to a group of users and sees what problems they come up with. Performance testing: Uses profiling tools to measure if we are getting acceptable response time. Is this application running as fast as it should be or it need to be? Stress testing: A type of performance testing. We want to know how well the application runs under heavy loads. Integration testing: Test one app\u0026rsquo;s integration-ability to another app. Unit Testing: Tests individual components to ensure they work as intended. Functional Testing: Confirms the application operates according to specifications and requirements. System Testing: Tests a fully integrated system for adherence to specified requirements. Regression Testing: Verifies that recent changes don\u0026rsquo;t adversely affect existing functionalities. Acceptance Testing: Determines if the software meets specified requirements. User Acceptance Testing (UAT) is a focused subset where end-users assess real-world application scenarios. Security Testing: Evaluates the software\u0026rsquo;s defense against threats, pinpointing potential vulnerabilities. Compatibility Testing: Checks if the software functions across different devices, browsers, and operating systems. Usability Testing: Assesses the software\u0026rsquo;s user-friendliness and gathers user feedback. Exploratory Testing: Unscheduled testing where testers actively explore and concurrently design and conduct tests. Smoke Testing: Initial testing to detect major failures and ascertain the software\u0026rsquo;s stability for more detailed testing. Sanity Testing: Examines specific functions affected by recent changes, a kind of focused regression testing. Monkey Testing: Random testing without knowledge of system internals, functionalities, or data. Alpha Testing: In-house testing done before releasing the software to a select external audience. etc\u0026hellip; Here, we focus on testing individual units of our code! We test our code as we write it, and we write code to automate the testing of our code.\nFig. 1: Paradox of (test) choices. Which tests to select to capture bugs? TDD In A Nutshell TDD is about writing the test prior to writing the application logic.\nCounter-intuitive? Having the need to pass 1 test gives us clarity on what is needed to be done.\nSteps:\nWrite a test. Watch the test fail. Write application logic - as simple as possible. Pass the test. Refactor, removing duplication Fig. 2: Unit-test (Image Source: monkeyuser.com). Questions \u0026amp; Answers Question 1: \u0026ldquo;Does TDD work for everything?\u0026rdquo;\nNo. There are problems that having TDD by itself does not guarantee the code is perfect, such as problems related to multi-threading, security, or user interfaces. Unit-testing does not replace other testing methods. Question 2: \u0026ldquo;Am I supposed to write all my tests first?\u0026rdquo;\nNo. It\u0026rsquo;s an iterative process where you write the test, expect to fail, develop the method, then move on to write the next test. Unit Testing Frameworks There are some unit-testing frameworks, such as: JUnit (Java), NUnit (.NET), PyUnit (Python), CppUnit (C++) or OCUnit (Objective-C). Although there are different frameworks, they all have the same idea.\nJUnit For Unit Testing \u0026amp; Test-Driven Development Unit tests are ultimately the best way to capture class-level and method-level requirements. Once the tests match the requirements, code can be developed to pass the tests. Unit tests aren\u0026rsquo;t the only kinds of tests; many other kinds are generally required as well\nJUnit is by far the most common way to formally write unit tests for Java code. There are many advantages to the formal approach of JUnit:\nFully integrated into all major Java IDEs to create and run tests without external tools. A robust library supports easily writing tests, to encourage quantity and quality of tests. Tests can be run – and evaluated – automatically. Coverage can be tracked, to ensure that every line of source code has been tested. Let\u0026rsquo;s look at the example. Note that the test is written prior to the code.\nimport org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { @Test public void testAddition() { Calculator calculator = new Calculator(); int result = calculator.add(5, 3); assertEquals(8, result); } } public class Calculator { public int add(int a, int b) { return a + b; } } JUnit provides several assertion methods to make it easy to specify expected behavior.\nQuestions \u0026amp; Answers Question 1: \u0026ldquo;Do I test getters and setters?\u0026rdquo;\nDepends. Test only if they could meaningfully break. Question 2: \u0026ldquo;Do I test private methods\u0026rdquo;\nGenerally, no. Typically, just make a test for a public method that proves the private method works. Question 3: \u0026ldquo;Can I combine multiple test classes?\u0026rdquo;\nYes, it is called \u0026ldquo;Test Suites\u0026rdquo;. Question 4: \u0026ldquo;How do I control the order of tests?\u0026rdquo;\nNo. Controlling order suggests dependencies - avoid at all costs. Unit tests are not intended to test the application - only the individual units of code, in isolation. Citation Cited as:\nNguyen, Minh. (September 2023). Java Fundamentals (Part 3) https://mnguyen0226.github.io/posts/java_fundamentals_3/post/ Or\n@article{nguyen2023java3, title = \u0026#34;Java Fundamentals (Part 3)\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;September\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/java_fundamentals_3/post/\u0026#34; } References [1] P. Deitel, Java: How To Program, Early Objects: Pearson, 2017\n[2] Horstmann, Cay S. Big Java: Early Objects. John Wiley \u0026amp; Sons, 2020.\n[3] S. Allardice, Test-Driven Developement: LinkedIn Learning, 2013.\nFig. 3: Orange Beach, Alabama, U.S.A (Image Source: Steven Van Elk @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/java_fundamentals_3/post/","summary":"[v.1.0] (09/25/2023): Post published!\nTest-Driven Development Types Of Tests In software development, there are different ways to test softwares:\nBeta testing: Provides a finished or near-finished application to a group of users and sees what problems they come up with. Performance testing: Uses profiling tools to measure if we are getting acceptable response time. Is this application running as fast as it should be or it need to be? Stress testing: A type of performance testing.","title":"Java Fundamentals (Part 3)"},{"content":"[v.1.0] (09/22/2023): Post started!\nGroups A set of elements with a binary operation denoted by “•” that associates to each ordered pair (a,b) of elements in G an element (a • b) in G, such that the following axioms are obeyed:\n(A1) Closure: If a and b belong to G, then a • b is also in G. (A2) Associative: a • (b • c) = (a • b) • c for all a, b, c in G. (A3) Identity element: There is an element e in G such that a • e = e • a = a for all a in G. (A4) Inverse element: For each a in G, there is an element a^1 in G such that a•a^1 = a^1 • a = e. (A5) Commutative (Abelian Group): a • b = b • a for all a, b in G. Cyclic Group Exponentiation is defined within a group as a repeated application of the group operator, so that a^3 = a•a•a.\nWe define a^0 = e as the identity element, and a^-n = (a^1)^n, where a^1 is the inverse element of within the group.\nA group G is cyclic if every element of is a power a^k (k is an integer) of a fixed element a∈G.\nThe element a is said to generate the group G or to be a generator of G.\nA cyclic group is always abelian and may be finite or infinite.\nRings A ring R is a set with two operations: addition and multiplication.\nR is an abelian group with respect to addition, meaning it satisfies properties like closure under addition, the existence of an identity element, and the existence of additive inverses.\nRings must also satisfy closure under multiplication, associativity of multiplication, and distributive properties of multiplication over addition.\nIf multiplication in a ring is commutative, the ring is said to be commutative.\nAn integral domain is a special kind of commutative ring that has a multiplicative identity and no zero divisors.\nFields A field F is like a ring but has additional properties.\nEvery non-zero element in a field has a multiplicative inverse.\nFields allow for addition, subtraction, multiplication, and division without leaving the set.\nFields have familiar examples like the rational numbers, real numbers, and complex numbers. Notably, the set of all integers is not a field because not every integer (except zero) has a multiplicative inverse.\nFields can be identifies into multiple types:\nFields with an infinite number of elements. Finite fields. GF(p) - Finite fields with p elements. GF(p^n) - Finite fields with p^n elements. Relationships Between Groups, Rings, and Fields Fig. 1: Groups, Rings, and Fields. Fig. 2: Properties of Groups, Rings, and Fields. Finite Fields of the Form GF(p) Finite\tfields\tplay\ta\tcrucial\trole\tin\tmany\tcryptographic\talgorithms. It\tcan\tbe\tshown\tthat\tthe\torder\tof\ta\tfinite\tfield\tmust\tbe\ta\tpower\tof\ta\tprime\tp^n,\twhere\tn\tis\ta\tpositive\tinteger.\nThe\tfinite\tfield\tof\torder\tp^n is\tgenerally\twritten\tGF(p^n).\nGF\tstands\tfor\tGalois\tfield,\tin\thonor\tof\tthe\tmathematician\twho\tfirst\tstudied\tfinite\tfields.\nGF(p) is defined with the following properties:\nGF(p) consists of p elements. The binary operations + and * are defined over the set. The operations of addition, subtraction, multiplication, and division can be performed without leaving the set. Each element of the set other than 0 has a multiplicative inverse. We show that the elements of GF(p) are the integers 0, 1, ..., p - 1 and that the arithmetic operations are addition and multiplication mod p. Polynomial Arithmetic Polynomial Arithmetic with Coefficients in Z_p Division in different sets or structures can yield different results. For instance, when considering the division of 5 by 3:\nIn the field of rational numbers, the result is simply the fraction 5/3. In the field Z_7, which is the integers modulo 7, the division is expressed as 5/3 = (5 x 3^-1) mod 7, resulting in a value of 4. In the ring of integers, the division produces a quotient and a remainder. In this case, 5/3 yields a quotient of 1 and a remainder of 2. Polynomial Division A polynomial f(x) can be represented as a product of two other polynomials a(x) and g(x) plus a remainder r(x). In other words: f(x) = a(x) g(x) + r(x), where r(x) is the remainder.\nIf there\u0026rsquo;s no remainder (i.e., r(x) = 0), then g(x) divides f(x) completely. This can be written as g(x) | f(x).\nIf a polynomial f(x) cannot be expressed as a product of two other polynomials of lower degree over a certain field F, then f(x) is irreducible or prime over that field.\nPolynomial GCD A polynomial c(x) is the greatest common divisor (GCD) of a(x) and b(x) if:\nc(x) divides both a(x) and b(x). Any divisor of a(x) and b(x) is also a divisor of c(x). Another way to define the GCD is that it\u0026rsquo;s the polynomial of the highest degree that divides both a(x) and b(x).\nThe Euclidean algorithm can be extended to find the GCD of two polynomials, especially when their coefficients belong to a field.\nFinite Fields of the Form GF2^n Computational Considerations Since coefficients are 0 or 1, they can represent any such polynomial as a bit string.\nAddition becomes XOR of these bit strings.\nMultiplication is shift and XOR; cf long-hand multiplication.\nModulo reduction is done by repeatedly substituting the highest power with the remainder of the irreducible polynomial (also shift and XOR).\nUsing a Generator A generator g of a finite field F of order q (contains q elements) is an element whose first q-1 powers generate all the nonzero elements of F.\nThe elements of F consist of 0, g^0, g^1, ... , g^{q-2}. Consider a field F defined by a polynomial f(x).\nAn element b contained in F is called a root of the polynomial if f(b) = 0. Finally, it can be shown that a root g of an irreducible polynomial is a generator of the finite field defined on that polynomial.\nCitation Cited as:\nFinite Fields https://mnguyen0226.github.io/posts/info_security_5/post/. Or\n@article{nguyen2023ff, title = \u0026#34;Finite Fields\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;September\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/info_security_5/post/\u0026#34; } References [1] Pearson, https://www.pearson.com/en-us/subject-catalog/p/Stallings-Pearson-e-Text-for-Cryptography-and-Network-Security-Principles-and-Practice-Access-Card-8th-Edition/P200000003477 (accessed Sept. 22, 2023).\nFig. 3: Golden Gate Bridge, San Francisco, U.S.A (Image Source: Abigail Ducote @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/info_security_5/post/","summary":"[v.1.0] (09/22/2023): Post started!\nGroups A set of elements with a binary operation denoted by “•” that associates to each ordered pair (a,b) of elements in G an element (a • b) in G, such that the following axioms are obeyed:\n(A1) Closure: If a and b belong to G, then a • b is also in G. (A2) Associative: a • (b • c) = (a • b) • c for all a, b, c in G.","title":"Finite Fields"},{"content":"[v.1.0] (09/18/2023): Post started!\nTraditional Block Cipher Structure Stream Cipher Primary Function: Stream Cipher encrypts a digital data stream one bit or one byte at a time.\nExamples of Stream Ciphers: Autokeyed Vigenère cipher, Vernam cipher.\nIdeal Use-case: In the perfect situation, a one-time pad version of the Vernam cipher would be utilized. In this scenario, the keystream length matches that of the plaintext bit stream.\nSecurity Consideration: If the cryptographic keystream is entirely random, the cipher becomes impenetrable unless one obtains the keystream. To facilitate secure communication, the keystream must be shared with both users in advance using a safe and distinct channel. However, this setup can pose substantial logistical challenges, particularly when dealing with vast amounts of intended data traffic.\nPractical Implications: The bit-stream generator should be devised using an algorithmic approach. This ensures that every involved user can reproduce the cryptographic bit stream. Predicting future parts of the bit stream based on its preceding segments should be computationally challenging.\nUser Collaboration: Both users only need to have access to the bit-stream generating method. This allows each individual to independently produce the necessary keystream.\nBlock Cipher Functionality of Block Cipher: A block of plaintext is processed as a unit and is converted into a ciphertext block of identical size.\nCommon Block Sizes: The typical block sizes used in block ciphers are 64 bits or 128 bits.\nKey Sharing: Similar to the process in a stream cipher, both users involved share a symmetric encryption key.\nPrevalence in Networks: Block ciphers dominate in network-based applications that utilize symmetric cryptographic methods.\nFeistel\tCipher Feistel proposed the use of a cipher that alternates substitutions and permutations.\nSubstitutions: Each plaintext element or group of elements is uniquely replaced by a corresponding ciphertext element or group of elements.\nPermutation: No elements are added or deleted or replaced in the sequence, rather the order in which the elements appear in the sequence is changed. It\u0026rsquo;s a practical application of a proposal by Claude Shannon to develop a product cipher that alternates substitution and permutation functions. It\u0026rsquo;s the structure used by many significant symmetric block ciphers currently in use.\nFeistel Cipher Structure partitions the input block into two halves.\nProcesses through multiple rounds. Performs a substitution on the left data half. This is based on the round function of the right half \u0026amp; subkey. Then has a permutation swapping the halves. Feistel Cipher implements Shannon’s substitution-permutation (S-P) network concept.\nDiffusion and Confusion was introduced by Claude Shannon to counter cryptanalysis techniques based on statistical analysis.\nDiffusion: The plaintext\u0026rsquo;s statistical structure is spread into the long-range statistics of the ciphertext. Achieved by ensuring each plaintext digit impacts the value of many ciphertext digits. Confusion: The aim is to make the relationship between the statistics of the ciphertext and the value of the encryption key as intricate as possible. Even if an attacker can somewhat understand the ciphertext\u0026rsquo;s statistics, the method by which the key generated the ciphertext is so complicated that deducing the key becomes challenging. Feistel Cipher Design Features:\nBlock size: Bigger block sizes yield more security but might decrease encryption/decryption speeds for a particular algorithm. Key size: A more significant key size offers higher security but can reduce encryption/decryption speeds. Number of rounds: The Feistel cipher\u0026rsquo;s core idea is that one round provides inadequate security, but multiple rounds enhance security. Subkey generation algorithm: A more complex algorithm should result in increased difficulty for cryptanalysis. Round function F: Higher complexity typically indicates a higher resistance to cryptanalysis. Fast software encryption/decryption: In numerous scenarios, encryption is integrated into apps or utility functions in such a way that it prevents a hardware implementation; thus, the algorithm\u0026rsquo;s execution speed becomes a concern. Ease of analysis: If an algorithm can be succinctly and clearly described, it becomes simpler to identify its cryptographic vulnerabilities and thus determine its strength with higher confidence. Data Encryption Standard (DES) DES was issued\tin\t1977\tby\tthe\tNational\tBureau\tof\tStandards\t(now\tNIST)\tas\tFederal\tInformation\tProcessing\tStandard\t46. It was\tthe\tmost\twidely\tused\tencryption\tscheme\tuntil\tthe\tintroduction\tof\tthe\tAdvanced\tEncryption\tStandard (AES)\tin\t2001.\nThe algorithm\titself\tis\treferred\tto\tas\tthe\tData\tEncryption\tAlgorithm\t(DEA):\nData\tare\tencrypted\tin\t64-bit\tblocks\tusing\ta\t56-bit\tkey. The\talgorithm\ttransforms\t64-bit\tinput\tin\ta\tseries\tof\tsteps\tinto\ta\t64-bit\toutput. The\tsame\tsteps,\twith\tthe\tsame\tkey,\tare\tused\tto\treverse\tthe\tencryption. DES\tRound\tStructure DES round structure uses two 32-bit L \u0026amp; R halves.\nAs for any Feistel cipher can describe as:\nL_i = R_(i-1) R_i = L_(i-1) xor F(R_(i-1), K) It takes 32-bit R half and 48-bit subkey and:\nExpands R to 48-bits using perm E. Adds to subkey. Passes through 8 S-boxes to get 32-bit result. Finally permutes this using 32-bit perm P. DES\tKey\tSchedule DES key schedule forms\tsubkeys\tused\tin\teach\tround.\nIt consists\tof:\ninitial\tpermutation\tof\tthe\tkey\t(PC1)\twhich\tselects\t56-bits\tin\ttwo\t28-bit\thalves. 16\tstages\tconsisting\tof: rotating\teach\thalf\tseparately\teither\t1\tor\t2\tplaces depending\ton\tthe\tkey\trotation\tschedule\tK. permuting\tthem\tby\tPC2\tfor\tuse\tin\tfunction\tf. selecting\t24-bits\tfrom\teach\thalf. DES\tDecryption DES decrypt\tmust\tunwind\tsteps\tof\tdata\tcomputation, using\tsubkeys\tin\treverse\torder\t(SK16\t…\tSK1). Note\tthat\tIP\tundoes\tfinal\tFP\tstep\tof\tencryption.\n1st\tround\twith\tSK16\tundoes\t16th\tencrypt\tround. …. 16th\tround\twith\tSK1\tundoes\t1st\tencrypt\tround. Then\tfinal\tFP\tundoes\tinitial\tpermutation\tIP, thus\trecovering\toriginal\tdata\tvalue.\nAvalanche\tEffect The avalanche effect is the key\tdesirable\tproperty\tof\tencryption\talgorithms, where\ta\tchange\tof\tone\tinput\tor\tkey\tbit\tresults\tin\tchanging\tapprox \u0026amp;\u0026amp;\toutput bits. This effect make attempts\tto\t“home-in”\tby guessing\tkeys\timpossible. Note, DES\texhibits\tstrong\tavalanche. Strengths of DES: Timing\tattacks One\tin\twhich\tinformation\tabout\tthe\tkey\tor\tthe\tplaintext\tis\tobtained\tby\tobserving\thow\tlong\tit\ttakes\ta\tgiven\timplementation\tto\tperform\tdecryptions\ton\tvarious\tciphertexts.\nDES exploits\tthe\tfact\tthat\tan\tencryption\tor\tdecryption\talgorithm\toften\ttakes\tslightly\tdifferent\tamounts\tof\ttime\ton\tdifferent\tinputs.\nSo\tfar\tit\tappears\tunlikely\tthat\tthis\ttechnique\twill\tever\tbe\tsuccessful\tagainst\tDES\tor\tmore\tpowerful\tsymmetric\tciphers\tsuch\tas\ttriple\tDES\tand\tAES.\nFig. 1: Strength of DES with different key size. Block Cipher Design Principles Number of Rounds The greater the number of rounds, the more difficult it is to perform cryptanalysis. In general, the criterion should be that the number of rounds is chosen so that known cryptanalytic efforts require greater effort than a simple brute-force key search attack. If DES had 15 or fewer rounds, differential cryptanalysis would require less effort than a brute-force key search. Design\tof\tFunction\tF The heart of a Feistel block cipher is the function F. The more nonlinear F, the more difficult any type of cryptanalysis will be.\nThe SAC (Strict avalanche criterion) and BIC (Bit independence criterion) criteria appear to strengthen the effectiveness of the confusion function. The algorithm should have good avalanche properties:\nStrict avalanche criterion (SAC): states that any output bit j of an S-box should change with probability 1/2 when any single input bit i is inverted for all i, j. Bit independence criterion (BIC): states that output bits j and k should change independently when any single input bit i is inverted for all i, j, and k. Key\tSchedule\tAlgorithm With\tany\tFeistel\tblock\tcipher,\tthe\tkey\tis\tused\tto\tgenerate\tone\tsubkey\tfor\teach\tround. In\tgeneral,\twe\twould\tlike\tto\tselect\tsubkeys\tto\tmaximize\tthe\tdifficulty\tof\tdeducing\tindividual\tsubkeys\tand\tthe\tdifficulty\tof\tworking\tback\tto\tthe\tmain\tkey. It\tis\tsuggested\tthat,\tat\ta\tminimum,\tthe\tkey\tschedule\tshould\tguarantee\tkey/ciphertext\tStrict\tAvalanche\tCriterion\tand\tBit\tIndependence\tCriterion.\nCitation Cited as:\nBlock Ciphers and the Data Encryption Standard https://mnguyen0226.github.io/posts/info_security_4/post/ Or\n@article{nguyen2023des, title = \u0026#34;Block Ciphers and the Data Encryption Standard\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;September\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/info_security_4/post/\u0026#34; } References [1] Pearson, https://www.pearson.com/en-us/subject-catalog/p/Stallings-Pearson-e-Text-for-Cryptography-and-Network-Security-Principles-and-Practice-Access-Card-8th-Edition/P200000003477 (accessed Sept. 18, 2023).\nFig. 2: Ginnie Spring, Florida, U.S.A (Image Source: Autumn Kuney @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/info_security_4/post/","summary":"[v.1.0] (09/18/2023): Post started!\nTraditional Block Cipher Structure Stream Cipher Primary Function: Stream Cipher encrypts a digital data stream one bit or one byte at a time.\nExamples of Stream Ciphers: Autokeyed Vigenère cipher, Vernam cipher.\nIdeal Use-case: In the perfect situation, a one-time pad version of the Vernam cipher would be utilized. In this scenario, the keystream length matches that of the plaintext bit stream.\nSecurity Consideration: If the cryptographic keystream is entirely random, the cipher becomes impenetrable unless one obtains the keystream.","title":"Block Ciphers and the Data Encryption Standard"},{"content":"[v.1.0] (09/15/2023): Post started!\nForeword The Rubber-Duck method\nWhat do you think the problem is? What exactly do you want to happen? What is actually happening? How did you get there? What have you tried so far? HTML, CSS, \u0026amp; Flexbox JavaScript Citation Cited as:\nFull-stack Web Development: The Odin Project. https://mnguyen0226.github.io/posts/web_dev_odin/post/. Or\n@article{nguyen2023odin, title = \u0026#34;Full-stack Web Development: The Odin Project\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;September\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/web_dev_odin/post/\u0026#34; } References [1] Full Stack JavaScript | The Odin Project. Theodinproject.com. Published 2023. Accessed October 25, 2023. https://www.theodinproject.com/paths/full-stack-javascript ‌\n‌[2] Trautman E. Why Learning to Code is So Damn Hard | Thinkful. Thinkful. Published April 20, 2018. Accessed October 25, 2023. https://www.thinkful.com/blog/why-learning-to-code-is-so-damn-hard/ ‌\n[3] Florian. How to Use Google to Solve Your Programming Questions – Coding in Flow. Codinginflow.com. Published March 5, 2018. Accessed October 25, 2023. https://old.codinginflow.com/google-programming-questions ‌\nFig. 2: Golden Gate Bridge, San Francisco, U.S.A (Image Source: Maarten van den Heuvel @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/web_dev_odin/post/","summary":"[v.1.0] (09/15/2023): Post started!\nForeword The Rubber-Duck method\nWhat do you think the problem is? What exactly do you want to happen? What is actually happening? How did you get there? What have you tried so far? HTML, CSS, \u0026amp; Flexbox JavaScript Citation Cited as:\nFull-stack Web Development: The Odin Project. https://mnguyen0226.github.io/posts/web_dev_odin/post/. Or\n@article{nguyen2023odin, title = \u0026#34;Full-stack Web Development: The Odin Project\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;September\u0026#34;, url = \u0026#34;https://mnguyen0226.","title":"Full-stack Web Development: The Odin Project"},{"content":"[v.1.0] (09/11/2023): Post published!\nStatic \u0026amp; Final Modifiers Static Members Static members Are shared among all objects of the class (and available without any objects)\nStatic Methods: Are stateless utility operations, intended to be used without any instances. For example, Math.abs(), Character.isDigit(), Double.parseDouble().\nStatic Fields: As a best practice, these are always decleared in conjection with final for storing constant. For example, Math.PI, Integer.MAX_VALUE, Integer.MIN_VALUE.However, some final values are not actually constant.\nFinal Members Final Methods: Are methods that cannot be inherited.\nFinal Fields: Are fields that are assiged a value exactly once. A static final field is only \u0026ldquo;constant\u0026rdquo; if its type is a primitive or an immutable class.\nArray vs. List Array Here are some of the properties of Array:\nProvides random access to elements. An array is an object. Once length is fixed it can\u0026rsquo;t be changed. Elements can be objects or primitives. Special syntax for access, length. Java arrays\u0026rsquo; lengths are immutable but their contents are mutable. Let\u0026rsquo;s look at an example of Array\nString[] arr = new String[10]; // null x 10 String[] arr = {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; myMethod(new String[]{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}); Let\u0026rsquo;s look at an example of Array class\nString[] arr2 = Arrays.copyOf(arr, arr.length); String[] arr3 = Arrays.copyOf(arr, arr.length * 2); Arrays.fill(arr, \u0026#34;\u0026#34;); Arrays.sort(arr); Arrays.toString(arr); Arrays.equals(arr1, arr2); List Here are some properties of List:\nProvides random access to elements. A list is an object. Can add elements. Elements can only be objects. No special syntax List is an interface: this means that we can implement List via ArrayList or LinkedList. Let\u0026rsquo;s look at an example of List:\nList\u0026lt;String\u0026gt; s1 = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; s2 = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; s3 = new Arrays.asList(\u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;); # not recommend as you cannot add or remove element, you can update values though. s1.add(\u0026#34;abc\u0026#34;); s1.add(\u0026#34;abc\u0026#34;, 4); s1.size(); String str = s1.get(4); String str = s2.remove(4); Interface vs. Implementation Interface: Gives you everything you need to know to use the component (or answering the question \u0026ldquo;What does the componenet do?\u0026rdquo;).\nLet\u0026rsquo;s look at an example of an interface:\npublic interface List\u0026lt;E\u0026gt; { /** * Appends the specified element * to the end of this list. * @param element element to be added */ public void add(E element); /** * Inserts the specified element * at the specified position * in this list. * @param index location to insert element * @param element element to be inserted */ public void add(int index, E element); /** * Removes all of the elements * from this list. */ public void clear(); /* Others functions for a complete List interface */ public boolean contains(E element); public boolean equals(List\u0026lt;E\u0026gt; that); public E get(int index); public int indexOf(E element); public boolean isEmpty(); public Iterator\u0026lt;E\u0026gt; iterator(); public E remove(int index); public int size(); } Implementation: The behind-the-scenes internal working of the component (or answering the question \u0026ldquo;How does the component do it?\u0026rdquo;).\nTo connect with the idea of List, a List interface can have multiple implementations.\nLet\u0026rsquo;s look at an example of an implements:\n/** * A simple generic implementation of an ArrayList. * * @param \u0026lt;E\u0026gt; the type of elements in this list */ public class ArrayList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt; { /** * The array buffer into which the elements of the ArrayList are stored. */ private E[] elements; /** * The current number of elements in the ArrayList. */ private int size; /** * The total capacity of the ArrayList. */ private int capacity; /** * Constructs an empty ArrayList with an initial capacity of ten. */ public ArrayList() { size = 0; capacity = 10; elements = (E[]) new Object[capacity]; } /** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any subsequent elements to the right. * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws AssertionError if the element is null * @throws AssertionError if the index is out of range (index \u0026lt; 0 || index \u0026gt;= size) */ public void add(int index, E element) { assert element != null; assert 0 \u0026lt;= index \u0026amp;\u0026amp; index \u0026lt; size; if (size == capacity) { capacity *= 2; elements = Arrays.copyOf(elements, capacity); } for (int i = size; i \u0026gt; index; i--) { elements[i] = elements[i-1]; } elements[index] = element; size++; } } Citation Cited as:\nNguyen, Minh. (September 2023). Java Fundamentals (Part 2) https://mnguyen0226.github.io/posts/java_fundamentals_2/post/ Or\n@article{nguyen2023java2, title = \u0026#34;Java Fundamentals (Part 2)\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;September\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/java_fundamentals_2/post/\u0026#34; } References [1] P. Deitel, Java: How To Program, Early Objects: Pearson, 2017\n[2] Horstmann, Cay S. Big Java: Early Objects. John Wiley \u0026amp; Sons, 2020.\nFig. 1: Birch Lake, Alaska, U.S.A (Image Source: Alain Bonnardeaux @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/java_fundamentals_2/post/","summary":"[v.1.0] (09/11/2023): Post published!\nStatic \u0026amp; Final Modifiers Static Members Static members Are shared among all objects of the class (and available without any objects)\nStatic Methods: Are stateless utility operations, intended to be used without any instances. For example, Math.abs(), Character.isDigit(), Double.parseDouble().\nStatic Fields: As a best practice, these are always decleared in conjection with final for storing constant. For example, Math.PI, Integer.MAX_VALUE, Integer.MIN_VALUE.However, some final values are not actually constant.","title":"Java Fundamentals (Part 2)"},{"content":"[v.1.0] (09/04/2023): Post started!\nDefinitions Plaintext: an original message.\nCiphertext: the coded message.\nEnciphering/Encryption: the process of converting from plaintext to ciphertext.\nDeciphering/Decryption: restoring the plaintext from the ciphertext.\nCryptography: the area of study of the many schemes used for encryption.\nCryptographic System/Cipher: a scheme.\nCryptanalysis: techniques used for deciphering a message without any knowledge of the enciphering details.\nCryptology: the areas of cryptography and cryptanalysis.\nSymmetric Cipher Model There\tare\ttwo\trequirements\tfor\tsecure\tuse\tof\tconventional\tencryption:\nA\tstrong\tencryption\talgorithm Sender\tand\treceiver\tmust\thave\tobtained\tcopies of\tthe\tsecret\tkey\tin\ta\tsecure\tfashion\tand\tmust keep\tthe\tkey\tsecure. Here, the sender and receiver should get the same key. Cryptographic\tSystems Cryptographic\tsystems characterized along 3 independent dimensions:\nThe type of operations used for transforming plaintext to ciphertext. Substitution. Transposition. The number of keys used. Symmetric, single-key, secret-key, conventional encryption. Asymmetric, two-key, or public-key encryption. The way in which the plaintext is processed. Block cipher. Stream cipher. Cryptanalysis\tand\tBrute-Force\tAttack Cryptanalysis:\nAttack\trelies\ton\tthe\tnature\tof\tthe algorithm\tplus\tsome\tknowledge\tof\tthe\tgeneral\tcharacteristics\tof\tthe\tplaintext. Attack\texploits\tthe\tcharacteristics\tof the\talgorithm\tto\tattempt\tto\tdeduce\ta specific\tplaintext\tor\tto\tdeduce\tthe\tkey being\tused. Brute-force\tattack:\nAttacker\ttries\tevery\tpossible\tkey\ton a\tpiece\tof\tciphertext\tuntil\tan\tintelligible\ttranslation\tinto\tplaintext\tis\tobtained. On\taverage,\thalf\tof\tall\tpossible\tkeys must\tbe\ttried\tto\tachieve\tsuccess. Types of Attacks on Encrypted Messages Ciphertext Only:\nEncryption algorithm. Ciphertext. Known Plaintext:\nEncryption algorithm. Ciphertext. One or more plaintext-ciphertext pairs formed with the secret key. Chosen Plaintext:\nEncryption algorithm. Ciphertext. Plaintext message chosen by cryptanalyst, together with its corresponding ciphertext generated with the secret key. Chosen Ciphertext:\nEncryption algorithm. Ciphertext. Plaintext message chosen by cryptanalyst, together with its corresponding ciphertext generated with the secret key. Chosen Text:\nEncryption algorithm. Ciphertext. Plaintext message chosen by cryptanalyst, together with its corresponding ciphertext generated with the secret key. Ciphertext chosen by cryptanalyst, together with its corresponding decrypted plaintext generated with the secret key. Encryption Scheme Security Unconditionally\tsecure: No\tmatter\thow\tmuch\ttime\tan\topponent\thas,\tit\tis\timpossible\tfor\thim\tor\ther\tto\tdecrypt\tthe\tciphertext\tsimply\tbecause\tthe\trequired\tinformation\tis\tnot\tthere.\nComputationally\tsecure: The\tcost\tof\tbreaking\tthe\tcipher\texceeds\tthe\tvalue\tof\tthe\tencrypted\tinformation. The\ttime\trequired\tto\tbreak\tthe\tcipher exceeds\tthe\tuseful\tlifetime\tof\tthe\tinformation\nStrong\tEncryption The\tterm\tstrong\tencryption\trefers\tto\tencryption\tschemes\tthat\tmake\tit\timpractically\tdifficult\tfor\tunauthorized\tpersons\tor\tsystems\tto\tgain\taccess\tto plaintext\tthat\thas\tbeen\tencrypted. Properties\tthat\tmake\tan\tencryption\talgorithm\tstrong\tare:\nAppropriate\tchoice\tof\tcryptographic\talgorithm. Use\tof\tsufficiently\tlong\tkey\tlengths. Appropriate\tchoice\tof\tprotocols. A\twell-engineered\timplementation. Absence\tof\tdeliberately\tintroduced\thidden\tflaws. Substitution Techniques Substitution techniques is one\tin\twhich\tthe\tletters\tof\tplaintext\tare\treplaced\tby\tother\tletters\tor\tby\tnumbers\tor symbols. If\tthe\tplaintext\tis\tviewed\tas\ta\tsequence\tof\tbits,\tthen\tsubstitution\tinvolves\treplacing\tplaintext\tbit\tpatterns\twith\tciphertext\tbit\tpatterns. Alphabet\tis\twrapped\taround\tso\tthat\tthe\tletter following\tZ\tis\tA\nplain: meet me after the toga party cipher:\tPHHW PH\tDIWHU\tWKH\tWRJD SDUWB Caesar Cipher This is the simplest\tand\tearliest\tknown\tuse\tof\ta\tsubstitution\tcipher and was used by Julius\tCaesar. It involves\treplacing\teach\tletter\tof\tthe\talphabet\twith\tthe\tletter\tstanding\tthree\tplaces\tfurther\tdown\tthe\talphabet.\nCan define transformation as:\na b c d e f g h i j k l m n o p q r s t u v w x y z\nD E F G H I J K L M N O P Q R S T U V W X Y Z A B C\nMathematically give each letter a number:\na b c d e f g h i j k l m n o p q r s t u v w x y z\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\nAlgorithm can be expressed as:\nc = E(3, p) = (p + 3) mod 26\nA shift may be of any amount, so that the general Caesar algorithm is:\nC = E(k, p) = (p + k) mod 26\nWhere k takes on a value in the range 1 to 25; the decryption algorithm is simply:\np = D(k, C) = (C - k) mod 26\nMonoalphabetic\tCipher Rather\tthan\tjust\tshifting\tthe\talphabet, this algorithm could\tshuffle\tthe\tletters\tarbitrarily. Each\tplaintext\tletter\tmaps\tto\ta\tdifferent random\tciphertext\tletter. Hence\tkey\tis\t26\tletters\tlong.\nPlain: abcdefghijklmnopqrstuvwxyz Cipher: DKVQFIBJWPESCXHTMYAUOLRGZN Plaintext: ifwewishtoreplaceletters Ciphertext: WIRFRWAJUHYFTSDVFSFUUFYA If\tthe\t“cipher”\tline\tcan\tbe\tany\tpermutation\tof\tthe\t26\talphabetic\tcharacters,\tthen\tthere\tare\t26!\tor greater\tthan\t4\tx\t1026\tpossible\tkeys. This\tis\t10\torders\tof\tmagnitude\tgreater\tthan\tthe\tkey\tspace\tfor\tDES. Approach\tis\treferred\tto\tas\ta\tmonoalphabetic\tsubstitution\tcipher\tbecause\ta\tsingle\tcipher\talphabet\tis\tused\tper message.\nHowever, this approach is not secured due to human language are redundant. The letters are not equally commonly used. In\tEnglish,\tE\tis\tby\tfar\tthe\tmost\tcommon\tletter, then\tT, R, N, I, O, A, S. Other letters are fairly rare, those are Z, J, K, Q, X.\nThis algorithm is easy\tto\tbreak\tbecause\tthey\treflect\tthe\tfrequency\tdata\tof\tthe\toriginal\talphabet. The countermeasure\tis\tto\tprovide\tmultiple\tsubstitutes (homophones)\tfor\ta\tsingle\tletter.\nPlayfair Cipher This is best know as multiple-letter\tencryption\tcipher and was invented\tby\tBritish\tscientist\tSir\tCharles\tWheatstone\tin\t1854. It treats\tdigrams\tin\tthe\tplaintext\tas\tsingle\tunits\tand\ttranslates\tthese\tunits\tinto\tciphertext\tdigrams. The algorithm is based\ton\tthe\tuse\tof\ta\t5\tx\t5\tmatrix\tof\tletters\tconstructed\tusing\ta\tkeyword.\nFill\tin\tletters\tof\tkeyword\t(minus\tduplicates)\tfrom\tleft\tto\tright\tand\tfrom\ttop\tto\tbottom,\tthen\tfill\tin\tthe\tremainder\tof\tthe\tmatrix\twith\tthe\tremaining letters\tin\talphabetic\torder.\nFor example, the keyword is MONARCHY:\nFig. 1: Playfair key matrix - MONARCHY keyword. In the process of encrypting and decrypting, plaintext is encrypted two letters at a time. Should a pair consist of a repeated letter, a filler, like \u0026lsquo;X\u0026rsquo;, is inserted. For instance, the word \u0026ldquo;balloon\u0026rdquo; would be encrypted as \u0026ldquo;ba lx lo on\u0026rdquo;. If both letters in the pair fall within the same row, each letter is replaced with the letter to its right, wrapping back to the start if it reaches the end. As an example, “ar\u0026quot; would encrypt to \u0026ldquo;RM\u0026rdquo;. Similarly, if both letters of the pair are in the same column, each one is replaced with the letter immediately below it, wrapping back to the top if it reaches the bottom. For example, “mu\u0026quot; would encrypt to \u0026ldquo;CM\u0026rdquo;. In cases where the letters don\u0026rsquo;t meet the aforementioned criteria, each letter is replaced by the one in its row in the column of the other letter of the pair. For instance, “hs\u0026quot; would encrypt as \u0026ldquo;BP\u0026rdquo;, while “ea\u0026quot; could be encrypted to either \u0026ldquo;IM\u0026rdquo; or \u0026ldquo;JM\u0026rdquo;, depending on preference.\nPlayfair cipher\u0026rsquo;s security is improved much more over monoalphabetic since we have 26 x 26 = 676 digrams. However, it still can be broken given a few hundred letters since there still has much plaintext structure.\nHill Cipher The algorithm was developed\tby\tthe\tmathematician\tLester\tHill\tin\t1929. The strength\tis\tthat\tit\tcompletely\thides\tsingleletter\tfrequencies. The\tuse\tof\ta\tlarger\tmatrix\thides\tmore\tfrequency\tinformation: A\t3\tx\t3\tHill\tcipher\thides\tnot\tonly\tsingle-letter\tbut\talso\ttwo-letter\tfrequency\tinformation. It is strong\tagainst\ta\tciphertext-only\tattack\tbut\teasily\tbroken\twith\ta\tknown\tplaintext\tattack.\nPolyalphabetic\tCiphers Improves\ton\tthe\tsimple\tmonoalphabetic\ttechnique\tby\tusing\tdifferent\tmonoalphabetic\tsubstitutions\tas one\tproceeds\tthrough\tthe\tplaintext\tmessage.\nVigenère\tCipher\nIt is best\tknown\tand\tone\tof\tthe\tsimplest\tpolyalphabetic\tsubstitution\tciphers. In\tthis\tscheme\tthe\tset\tof\trelated\tmonoalphabetic\tsubstitution\trules\tconsists\tof\tthe\t26\tCaesar ciphers\twith\tshifts\tof\t0\tthrough\t25. Each\tcipher\tis\tdenoted\tby\ta\tkey\tletter\twhich\tis\tthe ciphertext\tletter\tthat\tsubstitutes\tfor\tthe\tplaintext\tletter\t“a”. To encrypt a message, a key is needed that is as long as the message. Usually, the key is a repeating keyword. For example, if the keyword is deceptive, the message “we are discovered save yourself” is encrypted as: key: deceptivedeceptivedeceptive plaintext: wearediscoveredsaveyourself ciphertext:\tZICVTWQNGRZGVTWAVZHCQYGLMGJ Even\tthis\tscheme\tis\tvulnerable\tto\tcryptanalysis because\tthe\tkey\tand\tthe\tplaintext\tshare\tthe\tsame frequency\tdistribution\tof\tletters,\ta\tstatistical technique\tcan\tbe\tapplied. One-Time\tPad\nIt\u0026rsquo;s an improvement to the Vernam cipher and was proposed by Army Signal Corp officer, Joseph Mauborgne. Key Features: The key used for encryption and decryption is random and as long as the message itself. This ensures that it\u0026rsquo;s not repeated. After using the key for a single message, it\u0026rsquo;s discarded. Each new message requires a new key of the same length as that message. Security: The scheme is deemed unbreakable. The ciphertext output appears random and bears no statistical relationship to the plaintext, making it nearly impossible to infer the original message. Since the ciphertext provides no information about the plaintext, there\u0026rsquo;s no way to crack the code. Challenges: Creating large quantities of truly random keys poses a practical challenge, especially for heavily used systems that might require millions of such characters. The distribution of these mammoth keys is problematic because both the sender and the receiver need to possess the same key for every message. Utility Limitations: Due to the mentioned challenges, the one-time pad is of limited utility. It\u0026rsquo;s mostly used for low-bandwidth channels where very high security is paramount. Uniqueness: The one-time pad is the only cryptosystem that offers perfect secrecy. Transposition Techniques Rail\tFence\tCipher This is the simplest\ttransposition\tcipher. Plaintext\tis\twritten\tdown\tas\ta\tsequence\tof\tdiagonals\tand\tthen\tread\toff\tas\ta\tsequence\tof\trows. To\tencipher\tthe\tmessage\t“meet\tme\tafter\tthe\ttoga party”\twith\ta\trail\tfence\tof\tdepth\t2,\twe\twould\twrite:\nm\te\tm\ta\tt\tr\th\tt\tg\tp\tr\ty e\tt\te\tf\te\tt\te\to\ta\ta\tt Thus, the encrypted message is: MEMATRHTGPRYETEFETEOAAT\nRow\tTransposition\tCipher This is\ta\tmore\tcomplex\ttransposition. We write\tthe\tmessage\tin\ta\trectangle,\trow\tby\trow,\tand\tread\tthe\tmessage\toff,\tcolumn\tby\tcolumn,\tbut\tpermute\tthe\torder\tof\tthe\tcolumns. The\torder\tof\tthe\tcolumns\tthen\tbecomes\tthe\tkey\tto\tthe\talgorithm\nKey:\t4 3 1 2 5 6 7 Plaintext: a t t a c k p o s t p o n e d u n t i l t w o a m x y z Ciphertext:\tTTNAAPTMTSUOAODWCOIXKNLYPETZ Citation Cited as:\nClassical Encryption Techniques https://mnguyen0226.github.io/posts/info_security_3/post/ Or\n@article{nguyen2023cet, title = \u0026#34;Classical Encryption Techniques\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;September\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/info_security_3/post/\u0026#34; } References [1] Pearson, https://www.pearson.com/en-us/subject-catalog/p/Stallings-Pearson-e-Text-for-Cryptography-and-Network-Security-Principles-and-Practice-Access-Card-8th-Edition/P200000003477 (accessed Sept. 04, 2023).\nFig. 2: Delaware, U.S.A (Image Source: Gary Cole @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/info_security_3/post/","summary":"[v.1.0] (09/04/2023): Post started!\nDefinitions Plaintext: an original message.\nCiphertext: the coded message.\nEnciphering/Encryption: the process of converting from plaintext to ciphertext.\nDeciphering/Decryption: restoring the plaintext from the ciphertext.\nCryptography: the area of study of the many schemes used for encryption.\nCryptographic System/Cipher: a scheme.\nCryptanalysis: techniques used for deciphering a message without any knowledge of the enciphering details.\nCryptology: the areas of cryptography and cryptanalysis.\nSymmetric Cipher Model There\tare\ttwo\trequirements\tfor\tsecure\tuse\tof\tconventional\tencryption:","title":"Classical Encryption Techniques"},{"content":"[v.1.0] (08/21/2023): Post started!\nDivibility and Division Algorithm We say that a nonzero b divides a if a = mb for some m, where a, b, and m are integers.\nDivision Algorithm: Given any positive integer n and any non-negative integer a, if we divide a by n, we get an integer quotient q and an integer remainder r that obey the following relationship:\na = qn + r 0\t≤\tr\t\u0026lt;\tn;\tq\t=\t[a/n] The Euclidean Algorithm This is one of the basic techniques of number theory and is the procedure for determining the greatest common divisor of two positive integers.\nGreatest Common Divisor (GCD) The greatest common divisor of a and b is the largest integer that divides both a and b, the notion is gcd(a, b)\nPositive integer c is said to be the gcd of a and b if:\nc is the divisor of a and b. Any divisor of a and b is a divisor of c. An equivalent definition is: gcd(a,b)\t=\tmax[k,\tsuch\tthat\tk\t|\ta\tand\tk\t|\tb]\nBecause\twe\trequire\tthat\tthe\tgreatest\tcommon\tdivisor\tbe\tpositive,\tgcd(a,b)\t=\tgcd(a,-b)\t=\tgcd(-a,b)\t=\tgcd(-a,-b)\nIn\tgeneral,\tgcd(a,b)\t=\tgcd(|a|,|b|)\ngcd(60,\t24)\t=\tgcd(60,\t-\t24)\t=\t12 Also,\tbecause\tall\tnonzero\tintegers\tdivide\t0,\twe\thave\tgcd(a,0)\t=\t|a|\nWe\tstated\tthat\ttwo\tintegers\ta\tand\tb\tare\trelatively\tprime\tif\ttheir\tonly\tcommon\tpositive\tinteger\tfactor\tis\t1;\tthis\tis\tequivalent\tto\tsaying\tthat\ta\tand\tb\tare\trelatively\tprime\tif\tgcd(a,b)\t=\t1\n8\tand\t15\tare\trelatively\tprime\tbecause\tthe\tpositive\tdivisors\tof\t8\tare\t1,\t2,\t4,\tand\t8,\tand\tthe\tpositive\tdivisors\tof\t15\tare\t1,\t3,\t5,\tand\t15.\tSo\t1\tis\tthe\tonly\tinteger\ton\tboth\tlists. Euclidean Algorithm Two integers are relatively prime if their only common positive integer factor is 1.\nThis algorithm finds the greatest common divisor of two integers a and b.\nFig. 1: Euclidean algorithm. Let\u0026rsquo;s walk through an example:\nIf\twe\twant\tto\tfind\tgcd(287,\t91),\twe\tdivide 287\tby\t91:\t287\t=\t91⋅3\t+\t14. We\tknow\tthat\tfor\tintegers\ta,\tb\tand\tc,\tif\ta\t|\tb\tand\ta\t|\tc,\tthen\ta\t|\t(b\t+\tc). Therefore,\tany\tdivisor\tof\t287\tand\t91\tmust\talso\tbe\ta\tdivisor\tof\t287\t-\t91⋅3\t=\t14. Consequently,\tgcd(287,\t91)\t=\tgcd(14,\t91). In\tthe\tnext\tstep,\twe\tdivide\t91\tby\t14:\t91\t=\t14⋅6\t+\t7. This\tmeans\tthat\tgcd(14,\t91)\t=\tgcd(14,\t7). Thus,\twe\tdivide\t14\tby\t7:\t14\t=\t7⋅2\t+\t0. We\tfind\tthat\t7\t|\t14,\tand\tthus\tgcd(14,\t7)\t=\t7. Therefore,\tgcd(287,\t91)\t=\t7. Modular Arithmetic Modulus If\ta\tis\tan\tinteger\tand\tn is\ta\tpositive\tinteger,\twe\tdefine\ta\tmod\tn to\tbe\tthe\tremainder\twhen\ta\tis divided\tby\tn;\tthe\tinteger\tn is\tcalled\tthe\tmodulus.\nThus,\tfor\tany\tinteger\ta:\na\t=\tqn +\tr 0\t≤\tr\t\u0026lt;\tn;\tq\t=\t[a/\tn] a\t=\t[a/\tn]\t*\tn\t+\t(\ta\tmod\tn) Modular\tarithmetic\texhibits\tthe\tfollowing\tproperties:\n[(a\tmod\tn)\t+\t(b\tmod\tn)]\tmod\tn =\t(a\t+\tb)\tmod\tn\t[(a\tmod\tn)\t-\t(b\tmod\tn)]\tmod\tn\t=\t(a\t-\tb)\tmod\tn [(a\tmod\tn)\t*\t(b\tmod\tn)]\tmod\tn\t=\t(a\t*\tb)\tmod\tn Congruent Two\tintegers\ta\tand\tb\tare\tsaid\tto\tbe\tcongruent\tmodulo\tn\tif: (a\tmod\tn)\t=\t(b\tmod\tn).\nThis\tis\twritten\tas\ta\t≡\tb\t(mod\tn).\nIf a\t≡\t0(mod\tn),\tthen\tn |\ta.\nCongruences\thave\tthe\tfollowing\tproperties:\na\t≡\tb\t(mod\tn)\tif\tn\t|\t(a\t–\tb)\t(or\tsimilarly,\tn\t|\t(b\t–\ta)) a\t≡\tb\t(mod\tn)\timplies\tb\t≡\ta\t(mod\tn) a\t≡\tb\t(mod\tn)\tand\tb\t≡\tc\t(mod\tn)\timply\ta\t≡\tc\t(mod\tn) Prime Numbers Prime\tnumbers\tonly have\tdivisors\tof\t1\tand\titself: They\tcannot\tbe\twritten\tas\ta\tproduct\tof\tother\tnumbers.\nPrime\tnumbers\tare\tcentral\tto\tnumber\ttheory.\nFermat\u0026rsquo;s and Euler\u0026rsquo;s Theorems Fermat\u0026rsquo;s\tTheorem If\tp\tis\tprime\tand\ta\tis\ta\tpositive\tinteger\tnot\tdivisible\tby\tp\tthen a^(p-1) ≡\t1\t(mod\tp).\nAn\talternate\tform\tis: If\tp\tis\tprime\tand\ta\tis\ta\tpositive\tinteger\tthen a^p ≡ a\t(mod\tp).\nEuler’s\tTotient\tFunction\tϕ(n) For\tan\tinteger\tn,\tϕ(n)\tis\tthe\tnumber\tof\tintegers\tk\tin\tthe\trange\t1\t≤\tk\t≤\tn\tfor\twhich\tthe\tgreatest\tcommon\tdivisor\tgcd(n,\tk)\tis\tequal\tto\t1\t(k\tis\ta\trelative\tprime\tto\tn).\ngcd(1,1)\t=\t1,\tthus\tϕ(1)\t=\t1.\nϕ(p)\t=\tp-1\t,\tp\tis\ta\tprime.\nEuler\u0026rsquo;s\tTheorem For\tevery\ta\tand\tn that\tare\trelatively\tprime: a^(ϕ(n))\t≡\t1\t(mod\tn).\nAn\talternative\tform\tis: a^(ϕ(n)+1)\t≡\ta\t(mod\tn).\nTesting For Primality with Miller-Rabin Algorithm Typically\tused\tto\ttest\ta\tlarge\tnumber\tfor\tprimality.\nFig. 2: Miller-Rabin algorithm. The Chinese Remainder Theorem It\tis\tpossible\tto\treconstruct\tintegers\tin\ta\tcertain\trange\tfrom\ttheir\tresidues\tmodulo\ta\tset\tof\tpairwise\trelatively\tprime\tmoduli.\nThis\tcan\tbe\tuseful\twhen\tM\tis\t150\tdigits\tor\tmore. However,\tit\tis\tnecessary\tto\tknow\tbeforehand\tthe\tfactorization\tof\tM The Chinese Remainder Theorem solves systems of equations of the form:\nx ≡ a1 (mod m1) x ≡ a2 (mod m2) ...  x ≡ an (mod mn) When m1, m2,  and mn are pairwise relatively prime, there is a unique solution for x modulo m1*m2*...*mn.\nLet\u0026rsquo;s look at an example:\nM1 = M/3 = 105/3 = 35. M2 = M/5 = 105/5 = 21. M3 = M/7 = 15. So, x ≡ 2 × 2 × 35 + 3 × 1 × 21 + 2 × 1 × 15 = 233 ≡ 23 (mod 105). Answer: x ≡ 23 (mod 105). Discrete Logarithms Primitive\troot: For\ta\tprime\tnumber\tp,\tif\ta\tis\ta\tprimitive\troot\tof\tp, then\ta,\ta2,\t…,\ta(p-1) are\tdistinct\t(mod\tp).\nDiscrete\tLogarithms: b\t≡ a^x (mod\tp). The\texponent\tx\tis\treferred\tto\tas\tthe\tdiscrete logarithm\tof\tthe\tnumber\tb\tfor\tthe\tbase\ta\t(mod\tp).\nCitation Cited as:\nNumber Theory https://mnguyen0226.github.io/posts/info_security_2/post/ Or\n@article{nguyen2023numtheory, title = \u0026#34;Number Theory\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;August\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/info_security_2/post/\u0026#34; } References [1] Pearson, https://www.pearson.com/en-us/subject-catalog/p/Stallings-Pearson-e-Text-for-Cryptography-and-Network-Security-Principles-and-Practice-Access-Card-8th-Edition/P200000003477 (accessed Aug. 28, 2023).\nFig. 3: Bulls Bridge, Kent, Connecticut U.S.A (Image Source: Johnell Pannell @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/info_security_2/post/","summary":"[v.1.0] (08/21/2023): Post started!\nDivibility and Division Algorithm We say that a nonzero b divides a if a = mb for some m, where a, b, and m are integers.\nDivision Algorithm: Given any positive integer n and any non-negative integer a, if we divide a by n, we get an integer quotient q and an integer remainder r that obey the following relationship:\na = qn + r 0\t≤\tr\t\u0026lt;\tn;\tq\t=\t[a/n] The Euclidean Algorithm This is one of the basic techniques of number theory and is the procedure for determining the greatest common divisor of two positive integers.","title":"Number Theory"},{"content":"[v.1.0] (08/11/2023): Post published!\nObject-Oriented Concepts Terminologies Method: Stores the program statements what perform the task.\nClass: A proggram unit to store the set of methods that perform the class\u0026rsquo;s tasks.\nObject: An instance of the class.\nReuse: Of existing classes when building new classes and programs saves time and effort. Also, it helps you build more reliable and effective systems, as the existing classes and components often have undergone extensive testing, debugging, and performance tuning.\nMethod call: Each message is implemented as a method call that tells a method of the object to perform its task.\nEncapsulate: Classes (and their objects) encapsulate their attributes and methods. Objects may communicate with one another, but they are normally not allowed to know how other objects are implemented (details can be hidden within the object themselves). The practice of \u0026ldquo;information hiding\u0026rdquo; is crucial to good software engineering.\nInheritance: The new class (i.e. subclass) starts with the characteristics of an existing class (i.e. superclass), possibly customizing them and adding unique characteristrics of its own.\nInterfaces: Collections of related methods that typically enable you to tell objects what to do, but not how to do it. Note, a class \u0026ldquo;implements\u0026rdquo; zero or more interfaces, each of which can have one or more methods.\nUnified Modeling Language (UML): The most widely used graphical scheme for modeling object-oriented systems.\nJava application: Is a computer program that executes when you use the java command to launch the Java Virtual Machine (JVM).\nJava Programming: Is simple, safe, platform independent, rich library, designed for internet. Here is the comparison between C/C++ vs Java programming.\nFig. 1: C/C++ vs Java programming. Downside to JVM: As you have something in between your bytecode and CPU, the application is slower and less efficient (the disadvantage is mostly not notificable)\nOperating Systems (OS) OS: Are software systems that make using computers more convenient for users, application developers, and systems administrators. They provide services that allow each application to execute safely, efficiently, and concurrently.\nKernel: Is the software that contains the core components of the operating system.\nJava Programming Types \u0026amp; Variables Type: Defines a set of valeus and the operations that can be carried out on those values. There are 2 types in Java\nPrimitive types: simple values. Examples: int, short, long, float, double, boolean, byte, char. Reference types: objects. Examples: String, Interger, Array, List, HashSet, Rectangle, FileReader,\u0026hellip; Variable: A name for a value that you want to use at a later time.\nClasses, Objects, \u0026amp; Methods Rectangle is a class in package java.awt. Let\u0026rsquo;s implement a simplified version in a package called simplified.geometry.\nEvery public class, field, constructor, and method should be documented with appropriate Javadoc comments and tags.\n/** * Represents a rectangle defined by a set of x, y coordinates and dimensions (width and height). * The class provides basic operations such as translation and resizing, and it also includes * methods for querying the rectangle\u0026#39;s position and dimensions. * * @author Minh Nguyen * @version 1.0 */ package simplified.geometry; public class Rectangle { /** The x-coordinate of the rectangle\u0026#39;s top-left corner. */ private int x; /** The y-coordinate of the rectangle\u0026#39;s top-left corner. */ private int y; /** The width of the rectangle. */ private int width; /** The height of the rectangle. */ private int height; /** * Creates a new rectangle with coordinates (0,0) and dimensions (0,0). */ public Rectangle() { this(0, 0, 0, 0); } /** * Creates a new rectangle with specified coordinates and dimensions. * * @param x The x-coordinate of the rectangle\u0026#39;s top-left corner. * @param y The y-coordinate of the rectangle\u0026#39;s top-left corner. * @param width The width of the rectangle. * @param height The height of the rectangle. */ public Rectangle(int x, int y, int width, int height){ this.x = x; this.y = y; this.width = width; this.height = height; } /** * Returns the x-coordinate of the rectangle\u0026#39;s top-left corner. * * @return The x-coordinate. */ public int getX(){ return x; } /** * Returns the y-coordinate of the rectangle\u0026#39;s top-left corner. * * @return The y-coordinate. */ public int getY(){ return y; } /** * Returns the width of the rectangle. * * @return The width. */ public int getWidth(){ return width; } /** * Returns the height of the rectangle. * * @return The height. */ public int getHeight(){ return height; } /** * Sets the size of the rectangle to the specified width and height. * * @param width The new width of the rectangle. * @param height The new height of the rectangle. */ public void setSize(int width, int height){ this.width = width; this.height = height; } /** * Translates the rectangle by the specified amount in the x and y directions. * * @param dx The amount to translate in the x-direction. * @param dy The amount to translate in the y-direction. */ public void translate(int dx, int dy){ this.x += dx; this.y += dy; } /** * Checks if this rectangle is equal to another rectangle. * * @param that The rectangle to compare with. * @return true if the two rectangles have the same coordinates and dimensions; false otherwise. */ public boolean equals(Rectangle that){ return ((this.x == that.x) \u0026amp;\u0026amp; (this.y == that.y) \u0026amp;\u0026amp; (this.width == that.width) \u0026amp;\u0026amp; (this.height == that.height)); } /** * Returns a string representation of the rectangle in the format: * \u0026#34;Rectangle[x=...,y=...,width=...,height=...]\u0026#34;. * * @return A string representation of the rectangle. */ @Override public String toString() { return \u0026#34;Rectangle[x=\u0026#34; + x + \u0026#34;,y=\u0026#34; + y + \u0026#34;,width=\u0026#34; + width + \u0026#34;,height=\u0026#34; + height + \u0026#34;]\u0026#34;; } } Design \u0026amp; Language Concepts Encapsulation: Direct access to internal state should always be prohibited (by declaring them as private).\nConstructor: Defines the initial values of the fields for a newly-created object.\nAccessors: return artifacts of the current state of the object.\nMutators: allows potential modification of the current state, and may return useful values.\nObject Life Cycle:\nObjects are constructed (via the new operator) as instances of a class. The constructor (a special method with no return type) is called to initialize the fields. The name of the constructor is the name of the class The new operator returns the address of the newly-created object. This address acts as a \u0026ldquo;reference\u0026rdquo; (a pointer, in other languages) to the object Objects can then be accessed and/or mutated by their public methods Method calls are always requests; we ask the object to do something on our behalf. Accessors ask objects to return current state information. Mutators ask objects to make changes (which may be refused or altered) The state fields, and internal operations of each method, are hidden from other objects. Ensures the implementation can change without ripple effects throughout the system Objects cannot be deleted explicitly, but they can become unreachable Unreachable: no in-scope variable, nor reachable object\u0026rsquo;s field, references the object Once unreachable, an object becomes immediately eligible for garbage collection. The system eventually reclaims the memory of any unreachable objects. Modern garbage collection is an extremely efficient automatic background service. Citation Cited as:\nNguyen, Minh. (August 2023). Java Fundamentals (Part 1) https://mnguyen0226.github.io/posts/java_fundamentals_1/post/ Or\n@article{nguyen2023java1, title = \u0026#34;Java Fundamentals (Part 1)\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;August\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/java_fundamentals_1/post/\u0026#34; } References [1] P. Deitel, Java: How To Program, Early Objects: Pearson, 2017\n[2] Horstmann, Cay S. Big Java: Early Objects. John Wiley \u0026amp; Sons, 2020.\nFig. 2: Grand Canyon National Park, Arizona, U.S.A (Image Source: Jason Thompson @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/java_fundamentals_1/post/","summary":"[v.1.0] (08/11/2023): Post published!\nObject-Oriented Concepts Terminologies Method: Stores the program statements what perform the task.\nClass: A proggram unit to store the set of methods that perform the class\u0026rsquo;s tasks.\nObject: An instance of the class.\nReuse: Of existing classes when building new classes and programs saves time and effort. Also, it helps you build more reliable and effective systems, as the existing classes and components often have undergone extensive testing, debugging, and performance tuning.","title":"Java Fundamentals (Part 1)"},{"content":"[v.1.0] (08/21/2023): Post started!\nThe field of cybersecurity consists of: measures of deter, prevent, detect, and correct security violations that involve the storage, processing, and transmission of information.\nComputer Security Objectives: CIA Confidentiality:\nData confidentiality: assures that private or confidential information is not made available or disclosed to unauthorized individuals. Privacy: assures that individuals control or influence what information related to them may be collected and stored and by whom and to whom that information may be disclosed. Ex: Student grad information is an assert whose confidentiality is considered to be highly important by students. Integrity:\nData integrity: assures that information and programs are changed only in a specified and authorized manner. System integrity: assures that a system performs its intended function in an unpaired manner, free from deliberate or inadvertent unauthorized manipulation of the system. Ex: Patient information stored in the database - inaccurate info could result in serious harm or death to a patient and expose the hospital to massive liability. Availability: assures that the systems work promptly and service is not denied to authorized users.\nEx: An online telephone directory lookup application would be classified as a low-availability requirement. Fig. 1: CIA Triad. Privacy is not security, but security is necessary to achieve privacy (it is not sufficient).\nAuthencity: verifying that users are who they say they are and that each input arriving at the system cam from a trusted source.\nAccountability: the security goal that generates that requirement for actions of an entity to be traced uniquely to that entity.\nThe OSI Security Architecture Security attack: any action that compromised the security of information owned by an organization.\nSecurity mechanism: a process (or a device incorporating such a process) that is designed to detect, prevent, or recover from a security attack.\nSecurity service: a process or communication service that enhances the security of the data processing systems and the information transfers of an organization. Intended to counter security attacks and they make use of one or more security mechanism to provide the service.\nSecurity Attacks Threat: a potential for violation of security, which exists when there is a circumstance, capability, action, or event that could breach security and cause harm. That is, a threat is a possible danger that might exploit a vulnerability.\nAttack: an assault on system security that derives from an intelligent threat; that is, an intelligent act that is deliberate attempt (especially in the sense of a method or technique) to evade security services and violate the security policy of a system.\nPassive attack: attempts to learn or make use of info from the system but does not affect system resources, such as monitoring and eavesdrop. There are 2 types:\nThe release of message contents. Traffic analysis Active attack: attempts to alter system resources or affect their operation, such as modify, abuse resources. There are 4 types:\nMasquerade: Takes place when one entity pretends to be a different entity. Usually includes one of the other forms of active attack. Replay: Involves the passive capture of a data unit and its subsequent retransmission to produce an unauthorized effect. Modification of messages: Some portion of a legitimate message is altered, or messages are delayed or reordered to produce an unauthorized effect. Denial of service: Prevents or inhibits the normal use or management of communications facilities. Security Services Authentication: concerned with assuring that a communication is authentic.\nAccess control: is the ability to limit and control the access to the host system and the applicaiton via communication links. To achieve this, each entity trying to gain access must first be identified, or authenticated, so that access rights can be tailored to the individual.\nData Confidentiality: is both the protection of transmitted data from passive attacks or the protection of traffic flow from analysis.\nData Integrity: is a connectionless integrity service deals with individual messages without regard to any larger context or generally provides protection against message modification only. I don\u0026rsquo;t care if you know the info but I do care if you modify it.\nNonrepudiation: prevents either sender or receiver from denying a transmitted message. When a message is sent, the receiver can prove that the alleged sender in fact send the message. When a message is received, the sender can prove that the alleged receiver in fact received the message.\nAvalability of services: addresses the security concerns raised by denial-of-service attacks.\nSecurity Mechanisms Cryptographic algorithms: we can distinguish between reversible cryptographic mechanisms and irreversible cryptographic mechanisms.\nData integrity: covers a variety of mechanisms used to assure the integrity of a data unit or stream of data units.\nDigital signature: data appended to, or a cryptographic transformation of, a data unit that allows a recipient of the data unit to prove the source and integrity of data unit and protect against forgery.\nAuthentication exchange: a mechanism intended to ensure the identity of an entity by means of information exchange.\nAccess control: a variety of mechanisms that enforce access rights to resources.\nTraffic padding: the insertion of bits into gaps in a data stream to frustrate traffic analysis attempts.\nRouting control: enables selections of particular physically or logically ensure routes for certain data.\nNotarization: the use of a trusted third party to assure certain properties of a data exchange.\nCryptography Crytographic algorithms and protocols can be grouped into 4 main areas:\nSymmetric encryption: used to conceal the contents of blokcs or streams of data of any size, including messages, files, encryption keys, and passwords. Asymmetric encryption: used to conceal small blocks of data, such as encryptionn keys and hash function values, which are used in digital signatures. Data integrity algorithms: used to protect blocks of data, such as messages, from alteration. Authentication protocols: schemes based on the used of cryptographic algorithms designed to authenticate the identity of entities. Fig. 2: Types of cryptographic algorithms. Keyless algorithms: a pseudorandom number generator produces a deterministic sequence of numbers or bits that has the appearance of being a truly random sequence.\nSingle-key algorithms: depends on the use of a secret key.\nAsymmetric (two keys) algorithms: a pair of keys are used instead of only one shared secret key.\nFundametals of Security Design Principles Economy of mechanism: the design of security measures embodied in both hardware and software should be as simple and small as possible.\nFail-safe default: access decisions should be based on permission rather than exclusion - the default situation is lack of access, and the protection scheme identifies conditions under which access is permitted.\nComplete mediation: every access much be checked against the access control mechanism.\nOpen design: the design of a security mechanism should be open rather than secret.\nSeparation of priviledge: a practice in which multiple privilege attributes are required to achieve access to restricted resource.\nLeast privilege: every process and every user of the system should operate using the least set of privileges necessary to perform the task.\nLeast common mechanism: the design should minimize the functions shared by different users, providing mutual security.\nPsychological acceptability: security mechanisms should not interfere unduly with the work of users, while at the same time metting the needs of those who authorize access.\nIsolation: a principle that applies in 3 contexts\nPublic access systems should be isolated from critical resources to prevent disclosure to tampering. The processes and files of individual users should be isolated from one another except where it is explicitly desired. Security mechanisms should be isolated in the sense of preventing access to those mechanisms. Encapsulation: viewed as a specific form of isolation based on object-oriented functionality.\nModularity: refers both to the development of security functions as separate, protected modules and to the use of modular architecture for mechanism design and implementation.\nLayering: referes to the use of multiple, overlapping protection approaches addressing the people, technology, and operational aspects of the information systems.\nLeast astonishment: a program or user interface should always respond in the way that least likely to astonish the user.\nAttack surface Network attack surface: vulnerabilities over an enterprise network, wide-area network, or internet.\nSoftware attack surface: vulnerabilities in application, utility, or OS code.\nHuman attack surface: vulnerabilities created by personnel or outsiders such as social engineering, human error, and trusted insiders.\nFig. 3: Defense in depth and attack surface. Citation Cited as:\nInformation and Network Security Concepts https://mnguyen0226.github.io/posts/info_security/post/ Or\n@article{nguyen2023insc, title = \u0026#34;Information and Network Security Concepts\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;August\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/info_security_1/post/\u0026#34; } References [1] Pearson, https://www.pearson.com/en-us/subject-catalog/p/Stallings-Pearson-e-Text-for-Cryptography-and-Network-Security-Principles-and-Practice-Access-Card-8th-Edition/P200000003477 (accessed Aug. 21, 2023).\nFig. 4: Lone Eagle Peak, Colorado, U.S.A (Image Source: Alyssa Teboda @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/info_security_1/post/","summary":"[v.1.0] (08/21/2023): Post started!\nThe field of cybersecurity consists of: measures of deter, prevent, detect, and correct security violations that involve the storage, processing, and transmission of information.\nComputer Security Objectives: CIA Confidentiality:\nData confidentiality: assures that private or confidential information is not made available or disclosed to unauthorized individuals. Privacy: assures that individuals control or influence what information related to them may be collected and stored and by whom and to whom that information may be disclosed.","title":"Information and Network Security Concepts"},{"content":"[v.1.1] (08/15/2023): Source code published!\n[v.1.0] (05/27/2023): Post published!\nRecently, I had an opportunity of joining the Mathbridge project, led by Virginia Tech\u0026rsquo;s Computer Science Department. Our goal was to develop a data visualization web application that serves as an interactive playground for students to explore and visualize concepts related to linear algebra and machine learning algorithms. This project holds particular significance for my university, which has a strong focus on machine learning and regularly produces groundbreaking research in the field. By creating this website, we aim to attract students and provide them with a valuable resource for their ML-focused programs. I\u0026rsquo;m delighted to announce that we have successfully deployed the prototype of the website, and we are continuously working on adding additional stylings, ML algorithms, and expanding the tech stack to enhance the user experience. Stay tuned for regular updates as we evolve and improve this exciting project.\nStarter code can be found here.\nFig. 1: Only after document, test, and code review are completed that a feature-implementation task is considered completed (Image source: MonkeyUser.com). Architecture The web application we have developed follows the single-page application (SPA) architecture, allowing for real-time updates and seamless user interactions. While there are popular SPA frameworks like Vue.js (open-sourced by Evan You), React (open-sourced by Meta), and Angular (open-sourced by Google), for this project, I made the decision to use Dash, a Python framework specifically designed for creating analytical web applications.\nDash combines the best of both worlds, incorporating elements of React and Flask API. It leverages Flask\u0026rsquo;s backend infrastructure to handle HTTP requests and responses while providing responsive components that enable dynamic interactions with the user.\nNow, why did I choose Dash? My introduction to this powerful tool came through the CS-5764: Information Visualization class, where I learned about its capabilities. Additionally, Dash offers a strong integration with Plotly, a widely-used visualization library (often seen on platforms like Kaggle), which allows for the creation of interactive plots. The reactive nature of Dash simplifies development by automatically updating visualizations when data or inputs change, similar to web-hooks.\nFig. 2: Architecture of Mathbridge. Let's dive into the front-end and back-end aspects of the application: Front-end To build the interactive visualizations, I utilized Dash Core Components (DCC), which provides a way to define HTML layouts in Dash, styled with CSS. As the project progresses, I plan to gradually integrate Dash Bootstrap Components (DBC) to further enhance the styling and overall user experience.\nBack-end Dash\u0026rsquo;s powerful callbacks are a key component of the back-end infrastructure. These callbacks connect user input to the appropriate functions and facilitate real-time updates of visualizations, calculated values, or any other types of output. To handle data manipulation and analysis, I leveraged popular data science libraries such as NumPy and Pandas. It\u0026rsquo;s worth noting that, at present, there is no database integration in this project.\nBy leveraging Dash\u0026rsquo;s reactive components and powerful callbacks, we have created an intuitive and interactive web application for visualizing linear algebra and machine learning concepts. The combination of Dash\u0026rsquo;s front-end capabilities and Flask\u0026rsquo;s backend infrastructure, along with the seamless integration with Plotly, has made development efficient and enjoyable.\nDeployment To ensure consistent performance across different environments, I utilized Docker for containerization. Docker effectively addresses the issue of \u0026ldquo;it works on my machine but not on yours.\u0026rdquo; By using Docker, I created containers that provide isolated and reproducible environments for my application. The Dockerfile served as the blueprint for building a Docker image, and the Docker container acted as the runtime instance of that image.\nTo make the deployment process more convenient, I pushed the built and tested Docker image to Docker Hub. Docker Hub serves as a centralized registry where the image can be easily accessed. This streamlined the deployment process, allowing for effortless deployment on various machines and environments without the need for manual image transfers or sharing through other means.\nFig. 3: Always check whether the product is deployed, else no update will be made (Image source: MonkeyUser.com). Why did I switch from using DockerHub to GitLab? I encountered rate limits on Docker Hub and had concerns about the security of my pushed images. As a solution, I switched to using GitLab Container Registry. GitLab Container Registry, integrated within my GitLab projects, provides a secure and scalable alternative for storing and managing Docker images. This shift allowed me to overcome rate limiting restrictions and gain more control over the security and accessibility of my Docker images. I could now push the Docker images to GitLab Container Registry and subsequently pull them from there for deployment on my target environments.\nFor scalable deployment and management, I turned to Kubernetes, a powerful container orchestration platform. By leveraging Kubernetes, I could effectively manage and scale my web application based on demand. With features like pods and load balancing, Kubernetes enabled the website to achieve high availability and efficient resource utilization. To deploy the website, I utilized Virginia Tech\u0026rsquo;s cloud service. Both the Kubernetes web interface and the KubeCTL command line tool were employed for managing the deployment, ensuring flexibility and ease of use.\nThrough the utilization of Docker for containerization, GitLab Container Registry for image storage and management, and Kubernetes for scalable deployment, I have established a robust and efficient deployment process for the web application. This combination of technologies allows for seamless and reliable deployment across different environments while ensuring optimal performance and security.\nIn conclusion, our data visualization web application built using Dash has laid the foundation for an exciting and interactive learning platform for students and enthusiasts of linear algebra and machine learning. The project\u0026rsquo;s journey has been filled with learning opportunities and significant milestones, and we are committed to further enhancing the application as it evolves.\nFig. 4: Project development is an iterative process, until the requirements are met and satisfied 😆 (Image source: MonkeyUser.com). One aspect we will focus on is improving the user interface and overall user experience. By gradually incorporating DBC, we aim to create a visually appealing and intuitive interface that enhances user engagement and interaction. The addition of styling elements will contribute to a more polished and professional look, making the application even more inviting for users. Furthermore, we plan to introduce more advanced ML algorithms to the application. By leveraging the power of popular data science libraries such as NumPy and Pandas, we can integrate cutting-edge algorithms that enable users to explore and experiment with various machine learning techniques. This expansion will provide students with a hands-on experience in applying ML concepts and foster a deeper understanding of the subject matter.\nCitation Cited as:\nNguyen, Minh. (May 2023). Building a Data Visualization Web App with Dash https://mnguyen0226.github.io/posts/mathbridge/post/ Or\n@article{nguyen2023webdash, title = \u0026#34;Building a Data Visualization Web App with Dash\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;May\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/mathbridge/post/\u0026#34; } References [1] “Gitlab documentation,” GitLab Documentation, https://docs.gitlab.com/ (accessed May 26, 2023).\n[2] “Command line tool (kubectl),” Kubernetes, https://kubernetes.io/docs/reference/kubectl/ (accessed May 26, 2023). [3] “Kubernetes Documentation,” Kubernetes, https://kubernetes.io/docs/home/ (accessed May 26, 2023).\n[4] “Docker docs: How to build, share, and run applications,” Docker Documentation, https://docs.docker.com/ (accessed May 26, 2023).\n[5] “Dash documentation \u0026amp; user guide,” Plotly, https://dash.plotly.com/ (accessed May 26, 2023).\nFig. 5: Golden Bridge in Da Nang, Viet Nam (Image source: Jet Dela Cruz @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/mathbridge/post/","summary":"[v.1.1] (08/15/2023): Source code published!\n[v.1.0] (05/27/2023): Post published!\nRecently, I had an opportunity of joining the Mathbridge project, led by Virginia Tech\u0026rsquo;s Computer Science Department. Our goal was to develop a data visualization web application that serves as an interactive playground for students to explore and visualize concepts related to linear algebra and machine learning algorithms. This project holds particular significance for my university, which has a strong focus on machine learning and regularly produces groundbreaking research in the field.","title":"Building a Data Visualization Web App with Dash"},{"content":"[v.1.0] (06/15/2023): Post published!\nDuring a recent interview for a software engineer intern position, I had an intriguing conversation with a start-up CEO. We discussed a software-system problem that presented an opportunity to gradually integrate a machine learning (ML) solution. The challenge involved a Software-as-a-Service (SaaS) platform that aimed to match buyers or customers with suitable sellers or agents. This blog chronicles my research into the fascinating profile-matching problem, with a specific focus on the matching algorithms employed.\nSimilar matching services can be observed in popular dating apps like Tinder and Bumble, as well as social media platforms such as LinkedIn, Facebook, Instagram, and YouTube.\nFig. 1: Harnessing the power of technology to connect people (Image source: freeCodeCamp). In this blog I will introduce four potential ML-based solutions:\nAgent-Profile Recommendation. Similar Agent-Profile Listing. People You Might Know. Chatbot. Prerequisites Before diving into the profile-matching solutions, it\u0026rsquo;s important to establish that the following two features have already been implemented or will be addressed separately:\nBuyer-profile creation:\nAccount Creation: Buyers must be able to create an account by providing necessary credentials. Details on filing personal information will be discussed in later sections focusing on profile-matching algorithms. Robust Authentications: Implementing a secure authentication system, including features like 2-factor authentication (2FA), is crucial to maintain the integrity of buyer accounts. Communication Preferences: Buyers should have the option to specify their preferred communication channels and indicate their availability for booking meetings or engaging in chats with sellers. Seller-profile creation:\nAccount Creation: Sellers should have the capability to create an account using appropriate credentials. Details on filing personal information will be discussed in later sections focusing on profile-matching algorithms. Robust Authentications: Similar to buyers, incorporating robust authentication measures such as 2-factor authentication (2FA) helps ensure the security and trustworthiness of seller accounts. Availability and Profile Updates: Sellers should be able to manage their availability status and make necessary updates to their profiles or listed commodities. Agent-Profile Recommendation Consider the task of matching buyers and sellers as a recommendation system, where the goal is to pair each buyer with the most suitable potential seller (or vice versa).\nFig. 2: Diagram illustrating Agent-Profile recommendation system. Assumptions: Initially, the buyer may not need to directly interact with the seller, but they should have access to view the seller\u0026rsquo;s profile and schedule a conversation or chat if desired. It is also assumed that the buyer has logged in, allowing us to collect data from them. Furthermore, it is important to have a substantial number of sellers\u0026rsquo; profiles available in our database.\nFraming problem as ML task: The objective is to maximize the number of relevant sellers within certain constraints, such as identifying the top 5 relevant sellers. The definition of relevance can be established by engineers or managers based on predefined rules. For instance, a seller\u0026rsquo;s profile can be considered relevant if the buyer explicitly marks it as a favorite by pressing a \u0026ldquo;star\u0026rdquo; button. Once relevance is defined, we can construct a dataset and train a model to predict the relevance score between buyers and seller(s).\nData Collection: Since both sellers and buyers need to log in, there are two approaches to collecting personal information and preference data: filtering-tabs or questionnaires. These questions can be curated by the company\u0026rsquo;s commodity specialists. Here are examples of databases for sellers, buyers, and their interactions.\nFig. 3: Illustration of Buyer, Seller, and Buyer-Seller Interaction databases. Matching Algorithms: Within the realm of agent-profile recommendation, there are three types of algorithms commonly employed: Rule-based Filtering (non-personalized), Profile-based Filtering (personalized), and Collaborative Filtering (personalized).\nRule-based Filtering Rule-based filtering is a non-personalized approach that does not require the application of ML. In this method, the sellers\u0026rsquo; profiles are filtered based on the buyer\u0026rsquo;s selected filtering tabs or questionnaire responses. This approach relies solely on the Seller database and can serve as a good starting point for our system.\n✅ Pros:\nMinimal data requirement. ▪ Rule-based filtering operates efficiently with the existing seller database without the need for extensive data collection or model training. ❌ Cons:\nLack of personalization. ▪ Generic rules used in rule-based filtering may result in recommendations that are not highly tailored to the individual preferences of buyers. Profile-based Filtering Profile-based filtering is a personalized algorithm that utilizes the features of sellers\u0026rsquo; profiles to recommend new seller profiles to buyers based on their previous interactions and preferences.\nFig. 4: Illustration of Profile-based Filtering algorithm diagram. For example, in Fig. 4, we observe that Buyer 1 has engaged with Seller 1, Seller 2, and Seller 3 in the past, indicating relevance through actions such as starring the profile, engaging in conversations, providing feedback, or making purchases. Since Seller 4 has a similar profile to Seller 1, Seller 2, and Seller 3, the system will recommend Seller 4 to Buyer 1.\n✅ Pros:\nRecommendations of newly added seller profiles. ▪ Profile-based filtering can effectively recommend newly added seller profiles to buyers, ensuring timely exposure to relevant sellers without prior viewing. ❌ Cons:\nChallenges in discovering new buyer interests. ▪ Profile-based filtering may struggle to identify a buyer's new interests that have not been previously exhibited. It relies on historical engagement data, which may overlook emerging preferences. Collaborative Filtering Collaborative filtering is a filtering solution that leverages the similarities between buyers to recommend new buyers\u0026rsquo; profiles. The underlying idea is that buyers who exhibit similar behavior or preferences are likely to be interested in similar sellers.\nFig. 5: Illustration of Collaborative Filtering algorithm diagram. For instance, in Fig. 5, the objective is to recommend a new seller\u0026rsquo;s profile to Buyer 2. To achieve this, we first identify a similar buyer to Buyer 2 based on their previous interactions, such as Buyer 1. Next, we identify a seller\u0026rsquo;s profile, in this case, Seller 3, which Buyer 1 has engaged with but Buyer 2 has not yet seen. We then recommend Seller 3 to Buyer 2.\nThe main difference between collaborative filtering and profile-based filtering is that collaborative filtering does not rely on the features of sellers\u0026rsquo; profiles. Instead, it exclusively relies on the historical interactions of buyers to make recommendations.\n✅ Pros:\nNo domain knowledge required. ▪ Collaborative filtering does not rely on sellers' profiles, resulting in lower computational requirements and reducing the need for extensive domain knowledge. ❌ Cons:\nAccuracy issues with few seller profiles. ▪ In the case of a limited number of seller profiles, the system may struggle to provide accurate recommendations, known as the cold-start problem . Inability to handle niche interests. ▪ Collaborative filtering, based on similar buyers, may have difficulty accommodating niche interests with limited data, potentially overlooking unique preferences. Fig. 6: Comparison table of Profile-based Filtering and Collaborative Filtering. Similar Agent-Profile Listing In our SaaS platform, we can incorporate a feature that presents a list of \u0026ldquo;similar sellers\u0026rsquo; profiles\u0026rdquo; to the buyer after they have clicked on a specific seller\u0026rsquo;s profile.\nFig. 7: Illustration of Similar Agent-Profile Listing algorithm diagram. Assumptions: The input for this feature is the list of sellers\u0026rsquo; profiles that the buyer is currently viewing, which can be obtained through manual filtering or selection via clicks. The desired output is a ranked list of similar listings that the buyer is likely to click on next. This system can cater to both logged-in (identified) and non-logged-in (anonymous) buyers.\nFraming problem as ML task: We observe that the sequence of listings that a buyer clicks on often shares common characteristics, such as sellers located in the same city or offering similar commodities within an acceptable price range. Leveraging this observation, we define the ML objective as accurately predicting the list of sellers\u0026rsquo; profiles that the buyer is likely to click on next.\nData Collection: For logged-in users, personal information and preference data can be collected through filtering-tabs or questionnaires. These data collection methods can be curated by the company\u0026rsquo;s commodity specialists. In the case of anonymous users, we can utilize the ELK (ElasticSearch, Kibana, Logstash) stack and the Mozilla Interaction Observer API to capture users\u0026rsquo; engagement with the web app. This stack has been utilized by companies like Facebook and Netflix for their algorithms, analyzing user scroll feed and recommending content based on scroll activity. Software companies like Amplitude offer similar services through their Amplitude APIs, enabling developers to create data analytic dashboards that showcase users\u0026rsquo; web app engagement levels. Here are examples of seller, buyer, and interaction databases that can be utilized for data analysis and model training.\nFig. 8: Examples of Buyer, Seller, and Buyer-Seller Interaction databases. Matching Algorithm: Rather than relying solely on the buyer\u0026rsquo;s historical interactions to understand their long-term interests, our approach for profile recommendations focuses on the buyer\u0026rsquo;s recently viewed listings. This approach is known as a session-based recommendation system. The objective is to predict the next profile that the buyer is likely to click on, based on the sequence of sellers\u0026rsquo; profiles they have recently browsed. By prioritizing the user\u0026rsquo;s most recent interactions, we aim to provide more accurate and timely recommendations, tailored to their immediate preferences.\nFig. 9: KNN for Similar Seller Profile Listing algorithm. To implement this system, we train a model that maps each listing to an embedding vector. By doing so, if two listings frequently appear together in the buyer\u0026rsquo;s browsing history, their corresponding embedding vectors will be positioned closely in the embedding space. This proximity indicates a higher likelihood of similarity between the listings.\nWhen recommending similar listings, our system searches the embedding space for listings that are closest to the ones currently being viewed. In Fig. 9, we illustrate this process by selecting the top 3 listings with the closest embeddings. One simple supervised learning algorithm that can be used for this task is the K-Nearest Neighbor (KNN) algorithm.\n✅ Pros:\nTimely recommendations. ▪ The algorithm focuses on the buyer's recent interactions, providing recommendations that align with their immediate preferences and increasing relevance and timeliness. Personalization. ▪ By considering the buyer's browsing history, the algorithm generates personalized recommendations tailored to their preferences, enhancing the user experience. Embedding space efficiency. ▪ Mapping listings to embedding vectors enables faster computation and retrieval of similar listings, improving system performance. ❌ Cons:\nLimited long-term preferences. ▪ The algorithm may not fully capture the buyer's long-term interests or evolving preferences, potentially leading to less accurate recommendations over time. Cold-start problem. ▪ New buyers or sellers with limited browsing history pose challenges for accurate recommendations due to insufficient data to establish patterns or similarities. Dependency on browsing history. ▪ Sparse or incomplete browsing history may compromise the algorithm's performance and result in less accurate suggestions. People You Might Know This system is particularly useful when buyers are unsure of what they want but are interested in using the service. Its purpose is to connect individuals who share common interests and help them find mutually beneficial deals. Known as \u0026ldquo;People You May Know\u0026rdquo; (PYMK), it provides a list of users who you may want to connect with based on shared attributes such as location, personality traits, or commodity preferences. Major social platforms like Facebook, LinkedIn, and Twitter leverage the power of PYMK to enhance their software.\nFig. 10: Illustration of PYMK algorithm diagram. Assumptions: In the context of matching suitable sellers to buyers (or vice versa), we assume that there is a single commodity being handled by multiple sellers.\nFraming problem as ML task: The primary objective is to maximize the number of strong connections between users. This entails identifying individuals who have compatible preferences and characteristics, increasing the likelihood of a successful match.\nData Collection: To collect personal information and preference data, both sellers and buyers are required to log in. This data can be gathered through filtering-tabs or questionnaires, which can be curated by the company\u0026rsquo;s commodity specialists. Additionally, companies may employ tools such as the Myers-Briggs Type Indicator (MBTI) to assess personality preferences and the Gallup Clifton Strengths assessment to understand individuals\u0026rsquo; strengths or natural talents. The idea behind these assessments is that individuals with similar personality traits and complementary strengths are more likely to form meaningful connections. Here are examples of seller, buyer, and seller-buyer rating databases that can be utilized for data analysis and model training.\nFig. 11: Examples of Buyer, Seller, and Buyer-Seller Rating databases. Matching Algorithms: In the PYMK system, there are two approaches that can be used: Pointwise Learning to Rank and Edge Prediction.\nPointwise Learning to Rank In the Pointwise Learning to Rank (LTR) approach, we utilize a binary classification model that takes two user profiles as input and outputs the probabilities of connection strength between them.\nFig. 12: Illustration of LTR algorithm diagram. ✅ Pros:\nSimplicity. ▪ LTR offers a straightforward binary classification model for assessing connection strength between users based on their profiles. Privacy preservation. ▪ LTR's pairwise comparisons protect user privacy by not exposing detailed profiles. Efficient computation. ▪ LTR's binary classification model is computationally efficient, making it suitable for large-scale systems. ❌ Cons:\nLimited context. ▪ LTR may overlook the broader social context and interactions among users, potentially resulting in less accurate predictions. It doesn't capture network effects and community dynamics that influence connections. Edge Prediction The Edge Prediction approach is commonly used in social media platforms as it encourages users to build larger networks. As we are not trying to build a social network, this approach might not be suitable for our SaaS. In this approach, we enhance the model by incorporating graph information. This allows the model to leverage additional knowledge extracted from the social graph to predict the existence of an edge (connection) between two nodes (users). It\u0026rsquo;s important to note that the graph represents the relationships or edges between nodes, capturing the connections between users in the system.\n✅ Pros:\nSocial context. ▪ Edge Prediction leverages graph information to consider social connections, enhancing the accuracy of recommendations by capturing network effects and community dynamics. Enhanced recommendations. ▪ Edge Prediction provides more personalized and meaningful recommendations, leading to stronger connections and user satisfaction. Scalability. ▪ Edge Prediction scales well for large-scale social graphs, allowing for efficient processing. ❌ Cons:\nIncreased complexity. ▪ Integrating graph information adds complexity, requiring additional computational resources and algorithmic considerations. Data sparsity. ▪ Edge Prediction may struggle with sparse data or limited connections, leading to less accurate predictions for users with fewer network connections. Chatbot Slow customer support is a common challenge that can be addressed effectively through the integration of chatbots. These automated systems can reduce manual labor while providing quick assistance to meet buyer\u0026rsquo;s needs.\nFig. 13: Chatbot (Image source: Siam Computing). Assumptions: Although slow customer support is not inherently an ML problem, optimizing the response time lies in routing buyer requests to the appropriate seller. This can be framed as a multi-class classification problem, where the objective is to classify and route requests accurately.\nFraming problem as ML task: Slow customer support is a problem but it is not an ML problem as there is no obvious objective function to optimize. The bottleneck here is the responding to buyer\u0026rsquo;s requests lies in routing the request to the right seller. Thus, this is a multi-class classification problem.\nData Collection: Data can be collected through filtering-tabs or chatbot questionnaires, leveraging the interaction between buyers and the chatbot. Advanced pretrained natural language processing (NLP) models can be used to extract relevant features from the customer conversations.\nMatching Algorithm: To address the routing challenge, a combination of NLP techniques, text processing, and feature extraction can be employed. For multi-class classification, lightweight algorithms like Decision Trees can be utilized. Alternatively, deep learning models such as pretrained BERT can be employed for more complex conversation and text classification tasks.\n✅ Pros:\nEnhanced customer support. ▪ Chatbots provide quick and automated assistance, improving the overall customer support experience. Reduced manual labor. ▪ Chatbots reduce the need for manual communication, freeing up resources for other tasks. Data-driven personalization. ▪ Chatbots collect and analyze data to offer personalized recommendations and responses. Advanced NLP capabilities. ▪ Pretrained NLP models enable accurate feature extraction and understanding of customer conversations. ❌ Cons:\nLack of human interaction. ▪ Some buyers may prefer the human touch and empathy that chatbots may lack. Limited contextual understanding. ▪ Complex or nuanced customer requests may pose challenges for chatbots in understanding and providing appropriate responses. Initial development and training effort. ▪ Building and training chatbot systems, especially with advanced models, requires significant upfront investment. Potential misinterpretation of intent. ▪ Chatbots may occasionally misinterpret buyer queries, leading to incorrect responses or routing to inappropriate sellers. Citation Cited as:\nNguyen, Minh. (May 2023). Machine Learning for Profile-Matching System https://mnguyen0226.github.io/posts/profile_matching/post/ Or\n@article{nguyen2023mlpm, title = \u0026#34;Machine Learning for Profile-Matching System\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;May\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/profile_matching/post/\u0026#34; } References [1] C. Huyen, Designing Machine Learning Systems. Beijing: O’Reilly, 2022.\n[2] Amplitude, “Amplitude apis,” Amplitude Developer Center, https://www.docs.developers.amplitude.com/analytics/apis/ (accessed May 28, 2023).\n[3] MozDevNet, “Intersection observer API - web apis: MDN,” Web APIs | MDN, https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API (accessed May 28, 2023).\n[4] “The Elk Stack: From the creators of Elasticsearch,” Elastic, https://www.elastic.co/what-is/elk-stack (accessed May 28, 2023).\n[5] “Optimizing people you may know (PYMK) for Equity in Network Creation,” LinkedIn Engineering, https://engineering.linkedin.com/blog/2021/optimizing-pymk-for-equity-in-network-creation (accessed May 28, 2023).\n[6] “Serving a billion personalized news feeds,” YouTube, https://youtu.be/Xpx5RYNTQvg?t=1823 (accessed May 28, 2023).\n[7] M. Grbovic, “Listing embeddings in search ranking,” Medium, https://medium.com/airbnb-engineering/listing-embeddings-for-similar-listing-recommendations-and-real-time-personalization-in-search-601172f7603e (accessed May 28, 2023).\n[8] “Powered by AI: Instagram’s explore recommender system,” Meta AI, https://ai.facebook.com/blog/powered-by-ai-instagrams-explore-recommender-system (accessed May 28, 2023).\n[9] Deep Neural Networks for YouTube recommendations, https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45530.pdf (accessed May 28, 2023).\n[10] C. Goodrow, “On YouTube’s recommendation system,” blog.youtube, https://blog.youtube/inside-youtube/on-youtubes-recommendation-system/ (accessed May 28, 2023).\nFig. 14: Early morning mist at Ha Long Bay, Vietnam (Image source: Warren @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/profile_matching/post/","summary":"[v.1.0] (06/15/2023): Post published!\nDuring a recent interview for a software engineer intern position, I had an intriguing conversation with a start-up CEO. We discussed a software-system problem that presented an opportunity to gradually integrate a machine learning (ML) solution. The challenge involved a Software-as-a-Service (SaaS) platform that aimed to match buyers or customers with suitable sellers or agents. This blog chronicles my research into the fascinating profile-matching problem, with a specific focus on the matching algorithms employed.","title":"Machine Learning for Profile-Matching System"},{"content":"[v.1.0] (05/08/2023): Post published!\nChip Huyen, a Vietnamese writer, computer scientist, and co-founder of Claypot AI, has an impressive background as a lecturer at Stanford and as a machine learning engineer at NVIDIA, Snorkel AI, Netflix, and Primer. I have been an avid reader of Chip\u0026rsquo;s books since her best-selling works in Vietnam, which inspired me to pursue my study-abroad journey in the U.S. Her latest book, published in June 2022, offers invaluable insights and practical advice on building reliable machine learning systems. After reading it for the first time, I was captivated by the depth of knowledge shared, prompting me to revisit the book multiple times to fully absorb its ideas. In this blog post, I will share my reflections and takeaways from Chip Huyen\u0026rsquo;s book after the first-read, which has greatly influenced my understanding and approach to machine learning.\nFig. 1: Designing Machine Learning Systems's cover (Image source: O'Reilly). Overview of ML Systems In her book, Chip Huyen presents an overview of ML systems, defining eight main components that constitute such systems. The book adopts a \u0026ldquo;divide-and-conquer\u0026rdquo; approach, examining each component individually to facilitate a comprehensive understanding of the entire system.\nFig. 2: Diagram illustrating the components of a machine learning system (Image inspired from: O'Reilly). Chip\u0026rsquo;s definition of machine learning revolves around learning complex patterns from existing data and using them to make predictions on unseen data. This definition aligns with the prevalent use of supervised learning, as most ML applications involve leveraging vast amounts of user data stored in SQL databases.\nSo why does company integrate ML in their product? Companies integrate ML into their products due to the low cost of wrong predictions, scalability advantages, and the ability of ML models to adapt to changing patterns. For example, by identifying potential customers, displaying targeted ads, and offering timely discounts, companies like Lyft can significantly increase profits by reducing costs and attracting more long-term users.\nSo what is the difference between traditional software vs. ML? There are notable differences between traditional software engineering (SWE) and ML systems. In SWE, the emphasis is on modular and separated components, whereas in ML systems, code and data intertwine, making it challenging to apply SWE principles such as S.O.L.I.D or the 12-factor app to these systems.\nFig. 3: Comparison between Software Engineering and Machine Learning (Image inspired from: O'Reilly). Considerations Before applying ML algorithms to solve a problem, it is essential to frame the problem in a way that ML can address it effectively. This involves determining the appropriate task for ML, such as binary classification, multi-class classification, or regression.\nWhile ML metrics like accuracy or F1 score are important, most companies prioritize the ultimate goal of any project: increasing profit. This can be achieved by boosting sales, reducing costs, enhancing customer satisfaction, or increasing app engagement.\nFig. 4: Alignment of Integration in Software Engineering and Machine Learning with business objectives (Image source: MonkeyUser.com). Predicting ad click-through rates and fraud detection are popular ML use cases because they directly impact business metrics. Higher click-through rates translate into increased ad revenue, while detecting and preventing fraudulent transactions saves money.\nData \u0026amp; Feature Engineering Let\u0026rsquo;s look at how data can be handled in the data science perspective. For now, I will focus on sampling, labeling, and feature engineering techniques.\nData Sampling To create train/validate/test sets, there are various data sampling techniques available. Two common approaches include random sampling and stratified sampling.\nData Labeling When it comes to data labeling, there are several options to consider:\nHand-labeling: This approach can be expensive, time-consuming, and may raise concerns about data privacy. Third-party service: Companies like Scale AI offer data labeling services and have recently secured significant contracts, such as the $250 million data labeling contract from the Department of Defense. Benchmark datasets: Utilizing established benchmark datasets like ImageNet and BATADAL can provide pre-labeled data for specific tasks. Methodological changes: If feasible, it's possible to switch from traditional supervised learning with training from scratch to alternative approaches like transfer learning, self-supervised learning, or semi-supervised learning. These methods can reduce the reliance on extensive labeled data. Fig. 5: Importance of dataset selection and processing for targeted application (Image source: MonkeyUser.com). Feature Engineering The significance of feature engineering cannot be overstated in the development of ML models. Even with state-of-the-art ML architectures, performance can suffer if an inadequate set of features is used. While (deep learning) models can extract features to some extent, providing well-engineered features that enable the model to better comprehend the data can greatly benefit your application. By inputting carefully selected and curated features, you enhance the model\u0026rsquo;s ability to effectively capture and utilize relevant information.\nML Algorithms \u0026amp; Evaluation Let\u0026rsquo;s see what is Chip\u0026rsquo;s tips in terms of suitable ML algorithm(s), training paradigm, and evaluation metrics.\nModel Selection Given the constraints of limited computation power and time, it is crucial to strategically choose ML models based on their advantages and disadvantages. This is where the knowledge gained from classes and academic papers becomes applicable. Benchmark datasets, such as ImageNet, SMAC, or VQA, can serve as valuable references for model selection. Additionally, factors like the number of parameters (model complexity) and interpretability can influence the choice of models. The availability of auto-selecting tools like AutoML from H2O.ai or AutoTrain from HuggingFace provides reasonable options as well.\nDistributed Training Paradigms Consideration of distributed training paradigms is important when dealing with large models or datasets. Let\u0026rsquo;s examine data parallelism and model parallelism.\nData parallelism involves splitting the data across multiple machines, training the model on each machine, and accumulating gradients.\nModel parallelism, on the other hand, involves training different components of the model on different machines. For instance, machine 0 handles the computation for the first two layers while machine 1 handles the next two layers. It\u0026rsquo;s important to note that \u0026ldquo;model parallelism\u0026rdquo; can be misleading because in some cases, parallel execution doesn\u0026rsquo;t occur across different parts of the model on different machines. Instead, each part is executed sequentially or consecutively.\nFig. 6: Comparison of Data Parallelism and Model Parallelism (Image source: anyscale.com). Model Evaluation Deploying a model involves more than simply pickling the model and using it in a Python script. There are several important aspects to consider in the deployment process.\nModel Deployment Model deployment is not simply \u0026ldquo;pickle\u0026rdquo; the model and use it on a Python script, there are several aspects to be considered.\nBatch vs. Online Training Online prediction is when predictions are generated and returned as soon as requests for these predictions arrive. For example, you enter an English sentence into Google Translate and get back its French translation immediately. When doing online prediction, requests are sent to the prediction service via RESTful APIs, that means to send back the input data, call model prediction and return the prediction result\nBatch prediction is when predictions are generated periodically or whenever triggered. The predictions are stored somewhere, such as in SQL tables or an in-memory database, and retrieved as needed. For example, Netflix might generate movie recommendations for all of its users every four hours, and the precomputed recommendations are fetched and shown to users when they log on to Netflix. For example, every 4 hours, Netflix might generate movie recommendations for all of its users.\nModel Compression In scenarios where convolutional neural networks are used, model compression techniques can be applied. For example, replacing the convolutional layer with depth-wise separable convolutional layers can significantly reduce the number of parameters while maintaining performance. Similarly, classical ML algorithms like Decision Trees can be pruned to reduce model complexity.\nCloud vs. Hardware Model deployment options include cloud deployment to platforms like AWS or GCP and hardware deployment, often referred to as edge computing. Cloud deployment offers scalability but comes with associated costs ranging from $50K to $2M per year. On the other hand, hardware deployment enables models to operate in environments with limited or unreliable internet connectivity, such as rural areas or developing countries. Edge computing also reduces network latency concerns. However, privacy risks still exist, as attackers could potentially steal user data by physically accessing the devices. Major companies like Google, Apple, and Tesla are actively developing their own chips optimized for edge computing.\nFig. 7: Google's Pixel 6 Tensor Chip, Apple's M1 Chip, Tesla's D1 Chip. In support of the semiconductor industry, the CHIPS and Science Act was signed by President Biden on August 9, 2022, aiming to strengthen the US semiconductor supply chain and foster research and development of advanced technologies within the country.\nInfrastructure The right infrastructure setup can automate processes, saving engineering time, accelerating ML application development and delivery, reducing the risk of bugs, and enabling new use cases. Conversely, a poorly implemented infrastructure can be cumbersome and costly to replace.\nFig. 8: Machine learning infrastructure layers for building reliable systems. Storage: is where data is collected and stored. It can range from simple setups like hard disk drives (HDD) or solid-state drives (SSD) to more sophisticated solutions like centralized storage in platforms such as Amazon S3 or Snowflake. Data can be stored in a single location or distributed across multiple locations.\nResource Management: comprises tools to schedule and orchestrate your workloads to make the most out of your available compute resources. Popular examples in this category include Airflow, Kubeflow, and Metaflow, which help manage and allocate computing resources efficiently.\nML Platform: provides tools to aid the development of ML applications such as model stores, feature stores, and monitoring tools. Prominent examples of ML platforms include SageMaker and MLflow, which provide comprehensive capabilities for ML application development and management.\nDeployment: Major cloud providers like AWS (SageMaker), GCP (Vertex AI), Azure (Azure ML), and Alibaba (Machine Learning) offer robust deployment options for ML applications. These platforms provide infrastructure and services to streamline the deployment process and ensure scalability and reliability.\nDevelopment Environment: A variety of development environments are available to facilitate ML application development. Tools such as VS Code, PyCharm, Anaconda, Jupyter Notebook, Git, and Docker are commonly used by data scientists and developers to write and manage code, create reproducible environments, and collaborate efficiently.\nTeam Structures In many job descriptions, it is common to see Data Scientists taking ownership of the entire process, from data collection to productionization. However, Netflix has implemented an effective team structure for full-stack data scientists.\nNetflix\u0026rsquo;s model involves specialists who initially own specific parts of a project. These specialists create tools and automation to streamline their respective areas. Data scientists can then leverage these tools to take ownership of their projects from end to end. As tools are developed and integrated with each other, the entire workflow is cohesive and well-integrated.\nThis team structure at Netflix allows for a seamless collaboration where specialists contribute their expertise to build tools, and data scientists can utilize these tools to manage the complete life cycle of their projects.\nFig. 9: Netflix's full cycle data science development with specialists create reusable tools. (Image source: Netflix Technology Blog). Citation Cited as:\nNguyen, Minh. (May 2023). Designing Machine Learning Systems: A Summary https://mnguyen0226.github.io/posts/ml_systems_design/post/ Or\n@article{nguyen2023mlsys, title = \u0026#34;Designing Machine Learning Systems: A Summary\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;May\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/ml_systems_design/post/\u0026#34; } References [1] “Full cycle developers at Netflix,” Medium, https://netflixtechblog.com/full-cycle-developers-at-netflix-a08c31f83249 (accessed May 19, 2023).\n[2] “President Biden Signs Chips and science act into law,” White \u0026amp; Case LLP, https://www.whitecase.com/insight-alert/president-biden-signs-chips-and-science-act-law (accessed May 19, 2023).\n[3] “Cloud cost management and optimization by ANODOT,” Anodot, https://www.anodot.com/cloud-cost-management/ (accessed May 19, 2023).\n[4] F. Chollet, “Xception: Deep learning with depthwise separable convolutions,” arXiv.org, https://arxiv.org/abs/1610.02357 (accessed May 19, 2023).\n[5] C. Huyen, “Introduction to streaming for Data scientists,” Chip Huyen, https://huyenchip.com/2022/08/03/stream-processing-for-data-scientists.html#:~:text=Batch%20prediction%20means%20periodically%20generating,whenever%20they%20visit%20the%20website. (accessed May 19, 2023).\n[6] Y. Wu et al., “Google’s Neural Machine Translation System: Bridging the gap between human and machine translation,” arXiv.org, https://arxiv.org/abs/1609.08144 (accessed May 19, 2023).\n[7] “What is distributed training?,” Anyscale, https://www.anyscale.com/blog/what-is-distributed-training (accessed May 19, 2023).\n[8] VQA: Visual question answering | IEEE conference publication - IEEE xplore, https://ieeexplore.ieee.org/document/7410636 (accessed May 19, 2023).\n[9] B. Ellis et al., “SMACv2: An improved benchmark for cooperative multi-agent reinforcement learning,” arXiv.org, https://arxiv.org/abs/2212.07489 (accessed May 19, 2023).\n[10] Practical lessons from predicting clicks on ads at facebook, https://quinonero.net/Publications/predicting-clicks-facebook.pdf (accessed May 19, 2023).\n[11] “Scale AI selected by U.S. Department of Defense to accelerate government’s AI capabilities,” Business Wire, https://www.businesswire.com/news/home/20220131005304/en/Scale-AI-Selected-by-U.S.-Department-of-Defense-to-Accelerate-Government%E2%80%99s-AI-Capabilities (accessed May 19, 2023).\n[12] “Deep learning with python,” Manning Publications, https://www.manning.com/books/deep-learning-with-python (accessed May 19, 2023).\n[13] J. Henriksen, “Valuing lyft requires a deep look into unit economics,” Forbes, https://www.forbes.com/sites/jeffhenriksen/2019/05/17/valuing-lyft-requires-a-deep-look-into-unit-economics/?sh=17155c9a7add (accessed May 19, 2023).\n[14] L. Ceci and J. 7, “Mobile app user acquisition cost 2019,” Statista, https://www.statista.com/statistics/185736/mobile-app-average-user-acquisition-cost/ (accessed May 19, 2023).\n[15] C. Huyen, “Designing machine learning systems,” O’Reilly Online Learning, https://www.oreilly.com/library/view/designing-machine-learning/9781098107956/ (accessed May 19, 2023).\nFig. 10: Morning hike at McAfee Knob, Roanoke, Virginia, U.S.A. ","permalink":"https://mnguyen0226.github.io/posts/ml_systems_design/post/","summary":"[v.1.0] (05/08/2023): Post published!\nChip Huyen, a Vietnamese writer, computer scientist, and co-founder of Claypot AI, has an impressive background as a lecturer at Stanford and as a machine learning engineer at NVIDIA, Snorkel AI, Netflix, and Primer. I have been an avid reader of Chip\u0026rsquo;s books since her best-selling works in Vietnam, which inspired me to pursue my study-abroad journey in the U.S. Her latest book, published in June 2022, offers invaluable insights and practical advice on building reliable machine learning systems.","title":"Designing Machine Learning Systems: A Summary"},{"content":"[v.1.0] (04/28/2023): Post published!\nI recently finished an excellent graduate course, Software Engineering (CS5704), and learned about different aspects of software projects and how different-size companies handle their technical/business changes to deliver successful products to their customer. Some important topics are Process Models (Waterfall, V-Model, Spiral, Agile), Requirements Definition, and Architecture Design Patterns. Especially, S.O.L.I.D principles have struck me as must-known concepts for writing better and cleaner code.\nWhy do S.O.L.I.D principles matter? According to Uncle Bob, bad code slows down the development team as it is confusing and fragile. Confusing code does not explain what it is doing, while fragile code breaks in many places when you change one or a few lines of code.\nWhat we want is the code that is clear, rigid, and reusable.\nFun Fact: In his talk in S.O.L.I.D Principles, he mentioned that he was not the first to realize or coin the acronym \u0026ldquo;SOLID.”\nSingle Responsibility Principle SRP: \u0026ldquo;A class should have one, and only one reason to change\u0026rdquo; — Robert C. Martin. In Object Oriented Programming (OOP), a class should have only one primary function. If there is more than one utility for that class, we should split it into multiple courses. This helps distribute the functional responsibilities across numerous classes or objects (or developers).\nFig. 1: Divide and conquer! Distribute responsibilities to avoid code and project overload (Image source: MonkeyUser.com). Web Development Example Let\u0026rsquo;s say you are a developer in the Google Shopping team who is in charge of designing a class to process post-item-purchase.\nCode Example class PostPurchaseProcess: def web_notification(self, message): \u0026#34;\u0026#34;\u0026#34; Code to send confirmation bill to Google Chrome \u0026#34;\u0026#34;\u0026#34; pass def email_notification(self, message): \u0026#34;\u0026#34;\u0026#34; Code to send confirmation bill to Gmail \u0026#34;\u0026#34;\u0026#34; pass def phone_notification(self, message): \u0026#34;\u0026#34;\u0026#34; Code to send confirmation bill to Google Pixel \u0026#34;\u0026#34;\u0026#34; pass In the example above, the class PostPurchaseProcess violates the SRP as it contains too many responsibilities: sending notifications to web app, email, and mobile. What if there are errors in sending notifications to Google Pixel and Gmail? It may take time to pinpoint precisely which function(s) is responsible for the mistake!\nFix: We can refactor the code into multiple classes, each with single responsibility.\nFig. 2: Design refactored with the Single Responsibility Principle for improved clarity and maintainability. Code Example class WebPurchaseProcess: def web_notification(self, message): \u0026#34;\u0026#34;\u0026#34; Code to send confirmation bill to Google Chrome \u0026#34;\u0026#34;\u0026#34; pass class EmailPurchaseProcess: def email_notification(self, message): \u0026#34;\u0026#34;\u0026#34; Code to send confirmation bill to Gmail \u0026#34;\u0026#34;\u0026#34; pass class PhonePurchaseProcess: def phone_notification(self, message): \u0026#34;\u0026#34;\u0026#34; Code to send confirmation bill to Google Pixel \u0026#34;\u0026#34;\u0026#34; pass Data Science Example Suppose you are a Data Scientist at C3.ai who is processing a tabular dataset for a supervised classification application. There are multiple steps to investigate the structure, quality, and content of the dataset, such as: checking datatypes, removing duplicates, data imputation, removing outliers, class-balancing, feature analysis, or feature engineering. Similar to the Google Shopping example above, to follow the SRP, we will need to put these steps into their separate class.\nCode Example class DataImputation: def median_fill(self, data): \u0026#34;\u0026#34;\u0026#34; Code to fill missing data by median of feature \u0026#34;\u0026#34;\u0026#34; pass class OutlierRemoval: def remove_by_euclidean_dist(self, data): \u0026#34;\u0026#34;\u0026#34; Code to remove outliers using Euclidean distance \u0026#34;\u0026#34;\u0026#34; pass class FeatureAnalysis: def pearson_corr_cal(self, data): \u0026#34;\u0026#34;\u0026#34; Code to calculate Pearson correlation scores between input feature(s) and output label(s) \u0026#34;\u0026#34;\u0026#34; pass However, I don\u0026rsquo;t find this principle helpful in a Kaggle or data science project, as each Jupyter Notebook cell can be run and tested individually.\nOpen-Closed Principle OCP: \u0026ldquo;A module (or component) should be open for extension but closed for modification\u0026rdquo; — Bertrand Meyer. When making changes, the principle prevents the already functional design from bugs or breaks. This principle promotes a modular and flexible design that allows for the easy integration of a new idea while making your codebase more maintainable and scalable. The OCP can be hard to understand, so let\u0026rsquo;s walk through some examples.\nFig. 3: The challenge of implementing new features without refactoring existing code (Image source: MonkeyUser.com). Web Development Example An easy-to-see symptom of OCP violation to look for is the use of if/elif/else or switch-case statements. Let\u0026rsquo;s say that you are a (Flask or Django) backend developer at Meta who is writing a REST API that uses HTTP request protocols (POST, GET, PUT, DELETE) to allow users to interact with the database via CRUD (Create, Read, Update, Delete).\nCode Example class RequestHandler: def handle_request(self, request): \u0026#34;\u0026#34;\u0026#34; Code to handle request based on type \u0026#34;\u0026#34;\u0026#34; if request.method == \u0026#34;GET\u0026#34;: self.handle_get(request) elif request.method == \u0026#34;POST\u0026#34;: self.handle_post(request) elif request.method == \u0026#34;PUT\u0026#34;: self.handle_put(request) elif request.method == \u0026#34;DELETE\u0026#34;: self.handle_delete(request) def handle_get(self, request): \u0026#34;\u0026#34;\u0026#34; Code to handle GET request \u0026#34;\u0026#34;\u0026#34; pass def handle_post(self, request): \u0026#34;\u0026#34;\u0026#34; Code to handle POST request \u0026#34;\u0026#34;\u0026#34; pass def handle_put(self, request): \u0026#34;\u0026#34;\u0026#34; Code to handle PUT request \u0026#34;\u0026#34;\u0026#34; pass def handle_delete(self, request): \u0026#34;\u0026#34;\u0026#34; Code to handle DELETE request \u0026#34;\u0026#34;\u0026#34; pass The example above violates OCP because every time a new request type is added (e.g., PATCH), our RequestHandler class needs to be modified. This can introduce new bugs into existing code. As the OCP stated, we should design our code to be fixed but extended.\nFix: A solution to OCP violation is to separate each request type into individual classes, thus abstracting the RequestHandler class. Therefore, if we want to add a PATCH request, we can extend our API by adding a new PatchRequestHander class.\nFig. 4: Refactored design showcasing the application of the Open-Closed Principle. Code Example class RequestHandler: def handle_request(self, request): \u0026#34;\u0026#34;\u0026#34; Code to handle request based on type \u0026#34;\u0026#34;\u0026#34; request.handle() class GetRequestHandler: def handle(self): \u0026#34;\u0026#34;\u0026#34; Code to handle GET request \u0026#34;\u0026#34;\u0026#34; pass class PostRequestHandler: def handle(self): \u0026#34;\u0026#34;\u0026#34; Code to handle POST request \u0026#34;\u0026#34;\u0026#34; pass class PutRequestHandler: def handle(self): \u0026#34;\u0026#34;\u0026#34; Code to handle PUT request \u0026#34;\u0026#34;\u0026#34; pass class DeleteRequestHandler: def handle(self): \u0026#34;\u0026#34;\u0026#34; Code to handle DELETE request \u0026#34;\u0026#34;\u0026#34; pass class PatchRequestHandler: def handle(self): \u0026#34;\u0026#34;\u0026#34; Code to handle PATCH request (extended) \u0026#34;\u0026#34;\u0026#34; pass Data Science Example Let\u0026rsquo;s say you are a Machine Learning Engineer at NVIDIA who is writing a Python script for a baseline model with data preprocessing, model training, and model evaluation. Like the REST API example above, you want your class ModelPipeline to remain closed for modification but open for extension by strictly following the OCP.\nCode Example class DataPreprocessor: def preprocess(self, dataset): \u0026#34;\u0026#34;\u0026#34; Code to preprocess data \u0026#34;\u0026#34;\u0026#34; pass class ModelTrainer: def train(self, dataset): \u0026#34;\u0026#34;\u0026#34; Code to train model \u0026#34;\u0026#34;\u0026#34; pass class ModelEvaluator: def evaluate(self, model, dataset): \u0026#34;\u0026#34;\u0026#34; Code to evaluate model \u0026#34;\u0026#34;\u0026#34; pass class ModelPipeline: def __init__(self, preprocessor, trainer, evaluator): \u0026#34;\u0026#34;\u0026#34; Code to build a ModelPipeline constructor (object) \u0026#34;\u0026#34;\u0026#34; self.preprocessor = preprocessor self.trainer = trainer self.evaluator = evaluator def run_pipeline(self, dataset): \u0026#34;\u0026#34;\u0026#34; Code to run the machine learning project end-to-end \u0026#34;\u0026#34;\u0026#34; preprocessed_data = self.preprocessor.preprocess(dataset) model = self.trainer.train(preprocessed_data) evaluation_result = self.evaluator.evaluate(model, preprocessed_data) return evaluation_result Your teammate develops a new way of processing the dataset. Luckily, due to your guideline of OCP, your teammate can easily extend the existing baseline model by inheriting the DataPreprocessor class without the risk of breaking your functional baseline design.\nCode Example class NewDataPreprocessor(DataPreprocessor): def preprocess(self, dataset): \u0026#34;\u0026#34;\u0026#34; Code to preprocess data with new technique \u0026#34;\u0026#34;\u0026#34; pass Liskov Substitution Principle LSP: \u0026ldquo;Subclasses should be substitutable for their base classes (without affecting the correctness of the program)\u0026rdquo; — Barbara Liskov. In OOP, what we want is for any method or code that works for a base class should continue to work correctly when used with the derived types. This principle ensures the inheritance hierarchies are consistent, extensible, and correct.\nFig. 5: Creating a predictable and reusable codebase design (Image source: MonkeyUser.com). Web Development \u0026amp; Data Science Example Let\u0026rsquo;s say that you are to design a codebase at Netflix to write processed data into a MySQL database and a CSV file (You can think of adding new columns into a database by scraping or engineering new features).\nCode Example class DataHandler(): def write_db(self, data): \u0026#34;\u0026#34;\u0026#34; Code to write processed data to MySQL database \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Handling MySQL database.\u0026#34;) def write_csv(self, data): \u0026#34;\u0026#34;\u0026#34; Code to write processed data to CSV file \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Handling CSV file.\u0026#34;) class WriteDB(DataHandler): def write_db(self, data): \u0026#34;\u0026#34;\u0026#34; Code to write processed data to MySQL database \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Handling MySQL database.\u0026#34;) def write_csv(self, data): \u0026#34;\u0026#34;\u0026#34; Code to write processed data to CSV file \u0026#34;\u0026#34;\u0026#34; raise Exception(\u0026#34;Error: Can\u0026#39;t write to CSV file.\u0026#34;) class WriteCSV(DataHandler): def write_db(self, data): \u0026#34;\u0026#34;\u0026#34; Code to write processed data to MySQL database \u0026#34;\u0026#34;\u0026#34; raise Exception(\u0026#34;Error: Can\u0026#39;t write to MySQL database.\u0026#34;) def write_csv(self, data): \u0026#34;\u0026#34;\u0026#34; Code to write processed data to CSV file \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Handling CSV file.\u0026#34;) Here, our base class DataHandler defined two methods, write_db() and write_csv(). The derived class WriteDB inherits from DataHander and overrides the write_csv method. However, instead of providing the expected behavior, it prints an error message indicating it can\u0026rsquo;t write to a CSV file. Similarly, the derived class WriteCSV prints out the error message indicating it can\u0026rsquo;t write to MySQL file. This design violates the LSP as the derived classes do not behave as expected based on the contract defined by the DataHandler base class. The base class is designed to be too specific, thus causing its children to handle edge case(s) based on the characteristics of the child classes.\nFixed: Let\u0026rsquo;s write a more generic base class!\nFig. 6: Codebase design refactored with Liskov Substitution Principle. Code Example class DataHandler(): def write(self, data): \u0026#34;\u0026#34;\u0026#34; Code to handle processed data \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Handling data.\u0026#34;) class WriteDB(DataHandler): def write(self, data): \u0026#34;\u0026#34;\u0026#34; Code to write processed data to MySQL database \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Handling MySQL database.\u0026#34;) class WriteCSV(DataHandler): def write(self, data): \u0026#34;\u0026#34;\u0026#34; Code to write processed data to CSV file \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Handling CSV file.\u0026#34;) If you have an object of type WriteDB or WriteCSV, you can safely use it wherever an object of type DataHandler is expected because they adhere to the same contract.\nInterface Segregation Principle ISP: \u0026ldquo;Many client-specific interfaces are better than one general purpose interface\u0026rdquo; — Robert C. Martin. If we have an extensive interface with many functions, the class implementing the interface might only use some defined functions! It is better to break up the interface into multiple smaller interfaces; then, we can inherit our class\u0026rsquo;s needed interface(s). This principle promotes code modularity, reduces unnecessary dependencies, and makes it easier to maintain/extend the existing codebase.\nFig. 7: Challenges of dealing with extensive classes for refactoring, inheritance, and reusability (Image source: MonkeyUser.com). Web Development Example Let\u0026rsquo;s say you are a Full-stack Web Developer at Odoo who writes a simple web app with a home page and admin page.\nCode Example class WebPage: def render(self): \u0026#34;\u0026#34;\u0026#34; Code to render HTML of a generic web page \u0026#34;\u0026#34;\u0026#34; pass def save(self): \u0026#34;\u0026#34;\u0026#34; Code to save data of a generic web page into a database \u0026#34;\u0026#34;\u0026#34; pass def delete(self): \u0026#34;\u0026#34;\u0026#34; Code to delete data of a generic web page from a database \u0026#34;\u0026#34;\u0026#34; pass class HomePage(WebPage): def render(self): \u0026#34;\u0026#34;\u0026#34; Code to render HTML of home page \u0026#34;\u0026#34;\u0026#34; pass def save(self): \u0026#34;\u0026#34;\u0026#34; Code to save data of home page into a database \u0026#34;\u0026#34;\u0026#34; pass def delete(self): \u0026#34;\u0026#34;\u0026#34; Code to delete data of home page from a database \u0026#34;\u0026#34;\u0026#34; raise Exception(\u0026#34;Error: Only Admin can delete data from database.\u0026#34;) class AdminPage(WebPage) def render(self): \u0026#34;\u0026#34;\u0026#34; Code to render HTML of admin page \u0026#34;\u0026#34;\u0026#34; pass def save(self): \u0026#34;\u0026#34;\u0026#34; Code to save data of admin page into a database \u0026#34;\u0026#34;\u0026#34; pass def delete(self): \u0026#34;\u0026#34;\u0026#34; Code to delete data of admin page from a database \u0026#34;\u0026#34;\u0026#34; pass The example above violates the ISP because the children should not be forced to depend on the parent\u0026rsquo;s method(s) they do not use. While the AdminPage class inherits just fine, the HomePage class can\u0026rsquo;t use the delete() function. This creates an unnecessary dependency!\nFixed: It will be better to segregate the parent (WebPage) class into smaller interface(s) that meet the needs of each child. We can separate render(), save(), and delete() functions into multiple classes.\nFig. 8: Design refactored to adhere to the Interface Segregation Principle, promoting interface granularity and avoiding client dependencies on unnecessary methods. Code Example class Renderable: def render(self): \u0026#34;\u0026#34;\u0026#34; Code to render HTML of a generic web page \u0026#34;\u0026#34;\u0026#34; pass class Savable: def save(self): \u0026#34;\u0026#34;\u0026#34; Code to save data of a generic web page into a database \u0026#34;\u0026#34;\u0026#34; pass class Deletable: def delete(self): \u0026#34;\u0026#34;\u0026#34; Code to delete data of a generic web page from a database \u0026#34;\u0026#34;\u0026#34; pass class HomePage(Renderable, Savable): def render(self): \u0026#34;\u0026#34;\u0026#34; Code to render HTML of home page \u0026#34;\u0026#34;\u0026#34; pass def save(self): \u0026#34;\u0026#34;\u0026#34; Code to save data of home page into a database \u0026#34;\u0026#34;\u0026#34; pass class AdminPage(Renderable, Savable, Deletable): def render(self): \u0026#34;\u0026#34;\u0026#34; Code to render HTML of admin page \u0026#34;\u0026#34;\u0026#34; pass def save(self): \u0026#34;\u0026#34;\u0026#34; Code to save data of admin page into a database \u0026#34;\u0026#34;\u0026#34; pass def delete(self): \u0026#34;\u0026#34;\u0026#34; Code to delete data of admin page from a database \u0026#34;\u0026#34;\u0026#34; pass Data Science Example Let\u0026rsquo;s say that you are a Data Scientist at LinkedIn who is working on a multimodal application. You are tasked to process image and text data. Like the web development example above, you want separate interfaces for each subtask and inherit related interfaces to process images and text accordingly.\nCode Example class DataLoader: def load(self, data): \u0026#34;\u0026#34;\u0026#34; Code to load data to notebook memory (entire dataset or as a generator) \u0026#34;\u0026#34;\u0026#34; pass class DuplicateRemoval: def remove_dup(self, data): \u0026#34;\u0026#34;\u0026#34; Code to remove duplicate images in the dataset \u0026#34;\u0026#34;\u0026#34; pass class DataAugmentation: def img_augment(self, data): \u0026#34;\u0026#34;\u0026#34; Code to augment images in the dataset \u0026#34;\u0026#34;\u0026#34; pass class DataSmoothing: def ts_smooth(self, data): \u0026#34;\u0026#34;\u0026#34; Code to smooth time-series dataset \u0026#34;\u0026#34;\u0026#34; pass class ProcessTimeSeriesDataset(DataLoader, DataSmoothing): def load(self, data): \u0026#34;\u0026#34;\u0026#34; Code to load data to notebook memory (entire dataset or as a generator) \u0026#34;\u0026#34;\u0026#34; pass def ts_smooth(self, data): \u0026#34;\u0026#34;\u0026#34; Code to smooth time-series dataset \u0026#34;\u0026#34;\u0026#34; pass class ProcessImageDataset(DataLoader, DuplicateRemoval, DataAugmentation): def load(self, data): \u0026#34;\u0026#34;\u0026#34; Code to load data to notebook memory (entire dataset or as a generator) \u0026#34;\u0026#34;\u0026#34; pass def remove_dup(self, data): \u0026#34;\u0026#34;\u0026#34; Code to remove duplicate images in the dataset \u0026#34;\u0026#34;\u0026#34; pass def img_augment(self, data): \u0026#34;\u0026#34;\u0026#34; Code to augment images in the dataset \u0026#34;\u0026#34;\u0026#34; pass Here, we have the defined separate interfaces for data load, removing duplicates, image augmentation, and time-series smoothing. The ProcessTimeSeriesDataset and ProcessImageDataset classes only implement (or inherit) the interfaces (or parent classes) that are relevant to them.\nDependency Inversion Principle DIP: \u0026ldquo;Depend on abstractions. Do not depend on concretions\u0026rdquo; — Robert C. Martin. The main idea is to decouple high-level modules from low-level modules by introducing abstractions as mediators. When integrating external dependencies, it is better to create wrapper(s) around them so that your code depends on the wrapper you make and not the details of the dependencies. This allows for better flexibility, as different implementations can be easily substituted without affecting the high-level modules. This principle promotes modularity and maintainability in codebase design.\nFig. 9: Implementation of a wrapper to encapsulate system details and provide a simplified interface to users, shielding them from unnecessary complexity and internal workings (Image source: MonkeyUser.com). Web Development Example Let\u0026rsquo;s say you are a Mobile Developer at Apple who work on the payment integration aspect of Apple Music. Your task is to integrate Stripe Payment API into your backend codebase.\nCode Example class StripeProcessor: def process_payment(self, credit_cart_num): \u0026#34;\u0026#34;\u0026#34; Code to process payment via Stripe Payment API \u0026#34;\u0026#34;\u0026#34; pass class AppleMusic: def notify_payment(self, credit_cart_num): \u0026#34;\u0026#34;\u0026#34; Code to process payment in iOS backend \u0026#34;\u0026#34;\u0026#34; processor = StripeProcessor() processor.process_payment(credit_cart_num) The Apple Music example above violates DIP as the AppleMusic class directly depends on StripeProcessor class, a specific low-level implementation. Imagine that Stripe provides Stripe Payment API version 2.0, which has a massive change in multiple methods. Our AppleMusic (and any other class that uses the StripeProcessor object) will be broken. We will have to fix every single line that uses StripeProcessor\u0026rsquo;s methods.\nFixed: AppleMusic and StripeProcessor classes should depend on abstractions (or a wrapper for StripeProcessor) to avoid such catastrophe. In addition, we can easily swap the external API (e.g., Venmo Payment API) within the wrapper class by having a wrapper.\nFig. 10: Refactoring design with the Dependency Inversion Principle, where high-level modules depend on abstractions, promoting loose coupling and flexibility in the system architecture. Code Example class PaymentProcessor: def process_payment(self, credit_cart_num): \u0026#34;\u0026#34;\u0026#34; Code to process payment via external API \u0026#34;\u0026#34;\u0026#34; pass class StripeProcessor(PaymentProcessor): def process_payment(self, credit_cart_num): \u0026#34;\u0026#34;\u0026#34; Code to process payment via Stripe Payment API \u0026#34;\u0026#34;\u0026#34; pass class VenmoProcessor(PaymentProcessor): def process_payment(self, credit_cart_num): \u0026#34;\u0026#34;\u0026#34; Code to process payment via Venmo Payment API \u0026#34;\u0026#34;\u0026#34; pass class AppleMusic: def __init__(self, processor: PaymentProcessor): \u0026#34;\u0026#34;\u0026#34; Code to build AppleMusic constructor (object) \u0026#34;\u0026#34;\u0026#34; self.processor = processor def notify_payment(self, credit_cart_num): \u0026#34;\u0026#34;\u0026#34; Code to process payment in iOS backend \u0026#34;\u0026#34;\u0026#34; self.processor.process_payment(credit_cart_num) Data Science Example Let\u0026rsquo;s say you are a Data Analyst at Deloitte who is in charge of plotting the dataset to show insight to stakeholders. Similarly to the Apple Music example above, creating a wrapper for the data visualization task would be best.\nCode Example class Plotter: def show_plots(self, dataset): \u0026#34;\u0026#34;\u0026#34; Code to plot the dataset \u0026#34;\u0026#34;\u0026#34; pass class SeabornPlotter(Plotter): def show_plots(self, dataset): \u0026#34;\u0026#34;\u0026#34; Code to plot the dataset bia Seaborn API \u0026#34;\u0026#34;\u0026#34; pass class PlotlyPlotter(Plotter): def show_plots(self, dataset): \u0026#34;\u0026#34;\u0026#34; Code to plot the dataset bia Plotly API \u0026#34;\u0026#34;\u0026#34; pass class BusinessInsight(): def __init__(self, plotter: Plotter): \u0026#34;\u0026#34;\u0026#34; Code to build BusinessInsight constructor (object) \u0026#34;\u0026#34;\u0026#34; self.plotter = plotter def notify_payment(self, dataset): \u0026#34;\u0026#34;\u0026#34; Code to show the visualization trends or patterns of the dataset \u0026#34;\u0026#34;\u0026#34; self.plotter.show_plots(dataset) Here, the BusinessInsight class depends on the Plotter abstraction through its constructor, allowing different plotting implementations to be injected without modifying the BusinessInsight class. The Plotter class serves as the abstraction, while SeabornPlotter and PlotlyPlotter are concrete implementations of the Plotter class. Depending on the abstraction (Plotter), the BusinessInsight class is decoupled from specific plotting implementations. This promotes flexibility and modularity, as different plotting libraries or variations can be used interchangeably by appropriately implementing the Plotter abstraction to the BusinessInsight class.\nCitation Cited as:\nNguyen, Minh. (April 2023). S.O.L.I.D Principles Explained https://mnguyen0226.github.io/posts/solid_principles/post/ Or\n@article{nguyen2023solid, title = \u0026#34;S.O.L.I.D Principles Explained\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;April\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/solid_principles/post/\u0026#34; } References [1] R. S. Pressman and B. R. Maxim, Software Engineering: A Practitioner’s Approach. New York, NY: McGraw-Hill Education, 2020.\n[2] R. C. Martin, M. C. Feathers, T. R. Ottinger, and J. J. Langr, Clean Code A Handbook of Agile Software Craftsmanship. Boston, MA: Pearson Education, Inc, 2016.\n[3] R. C. Martin, “Clean Code - Lecture Series,” YouTube, https://www.youtube.com/watch?v=7EmboKQH8lM\u0026amp;amp;list=PLwAjnlpkQEft41G-GvHAKnh_CkaEKFawh\u0026amp;amp;ab_channel=UnityCoin (accessed May 12, 2023).\n[4] “SOLID Design Principle - Web Dev Simplified,” YouTube, https://www.youtube.com/watch?v=UQqY3_6Epbg\u0026amp;amp;list=PLZlA0Gpn_vH9kocFX7R7BAe_CvvOCO_p9\u0026amp;amp;ab_channel=WebDevSimplified (accessed May 12, 2023).\nFig. 11: Sunrise at Ho Chi Minh City, Viet Nam (Image source: Peter Nguyen @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/solid_principles/post/","summary":"[v.1.0] (04/28/2023): Post published!\nI recently finished an excellent graduate course, Software Engineering (CS5704), and learned about different aspects of software projects and how different-size companies handle their technical/business changes to deliver successful products to their customer. Some important topics are Process Models (Waterfall, V-Model, Spiral, Agile), Requirements Definition, and Architecture Design Patterns. Especially, S.O.L.I.D principles have struck me as must-known concepts for writing better and cleaner code.\nWhy do S.","title":"S.O.L.I.D Principles Explained"},{"content":"[v.1.0] (03/20/2023): Post published!\nDuring a recent interview with a Data Science Lead at a digital agriculture tech company, I had the opportunity to delve into the machine learning team\u0026rsquo;s exciting project. The team was utilizing multi-task learning (MTL) to deploy models to farming hardware, which piqued my interest and prompted me to explore this approach combined with deep learning. In particular, I wanted to investigate the effectiveness of MTL on vision transformers (ViT) and deep residual networks (ResNet-152).\nIn recent years, MTL has gained significant attention as a powerful technique to tackle multiple tasks simultaneously while optimizing computational resources. In computer vision, MTL has shown great potential in addressing challenges such as image segmentation, key-point detection, and edge detection. It has demonstrated remarkable improvements in data efficiency and performance on related tasks. Notably, Andrej Karpathy\u0026rsquo;s work on \u0026ldquo;Tesla Autopilot and Multi-Task Learning for Perception and Prediction\u0026rdquo; highlights how MTL enables the deployment of large models in constrained hardware settings while improving task-specific performance.\nFig. 1: Leveraging Multi-Task Learning for deploying large models in constraint settings (Image Source: Andrej Karpathy @ Tesla). Motivated by these advancements, my goal is to thoroughly investigate the effectiveness of MTL using the ViT architecture for image classification. Additionally, I aim to compare its performance against single-task learning (STL). I focus on class and super-class classification tasks extracted from the popular CiFAR-10 and CiFAR-100 datasets to conduct this investigation. I leverage the power of Python and Tensorflow in implementing and evaluating these experiments. For the convenience of interested readers, I have made the code and results of this research available in my Github repository.\nMulti-Task Learning Multi-Task Learning (MTL) is a powerful technique that allows networks to learn multiple related tasks simultaneously instead of training separate models for each task. MTL offers better efficiency and generalization than Single-Task Learning (STL), making it popular in various fields.\nEfficiency is crucial in embedded applications and deployment, where hardware limitations and cloud storage costs are considerations. MTL optimizes computational resources by jointly learning multiple tasks in a single model, improving efficiency and reducing complexity.\nGeneralization is essential for building artificial generalized intelligence. MTL leverages shared representations to gain a broader understanding of data patterns and correlations, enhancing adaptability to diverse scenarios.\nThere are two main approaches to implementing MTL: \u0026ldquo;hard-parameter\u0026rdquo; sharing and \u0026ldquo;soft-parameter\u0026rdquo; sharing. Hard-parameter sharing involves sharing some or all of the layers between tasks, enabling efficient knowledge transfer and improving model performance. In this post, I explore the application of hard-parameter sharing in image classification, specifically using vision transformers (ViT) and deep residual networks (ResNet-152).\nFig. 2: Comparison of Hard-Parameter Sharing and Soft-Parameter Sharing in Multi-Task Learning (Image inspired from The Gradient). There are three research questions that I want to tackle:\nRQ1: Is an MTL ViT model superior in performance to an MTL Convolution-based model (ResNet-152)? RQ2: Can an MTL ViT model achieve better results than two separate STL ViT models? RQ3: Does an STL ViT model outperform an STL Convolution-based model (ResNet152) in terms of accuracy? CiFAR-10 \u0026amp; CiFAR-100 Datasets For the CiFAR-10 dataset, I have selected two tasks: Task 1 involves a 10-class classification, while Task 2 focuses on binary classification by categorizing the ten classes into \u0026ldquo;animal\u0026rdquo; or \u0026ldquo;vehicle\u0026rdquo; labels. For the CiFAR-100 dataset, I have identified two tasks: Task 1 encompasses a 100-class classification, and Task 2 involves a 20-superclass classification, where the 100 classes are grouped into 20 superclasses, such as aquatic mammals, fish, flowers, and food containers. The dataset details can be found on the University of Toronto\u0026rsquo;s website.\nFig. 3: CiFAR-10 dataset (Image Source: University of Toronto). Vision Transformers (ViT) ViT is an encoder-based transformer neural network that uses a self-attention mechanism to transform the input image into fixed-size patches and encode their positions into the input, allowing the network to capture global features and locations. In contrast, convolutional neural networks (CNN) focus on extracting local features. The ViT architecture consists of the following steps: input, linear projection, stacked encoder, multi-layer perceptron, and output labels.\nFig. 4: Architecture of the Vision Transformers (Image Source: Dosovitskiy, Alexey, et al.). The explanation of ViT is cited from the original paper An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale\u0026quot; by Dosovitskiy, Alexey, et al. The image is first converted into patches, and each patch is reshaped into a 1D vector multiplied by a learnable matrix to create a vector. Next, positional embedding is integrated as ViT is invariant to position on patches. The encoder of ViT is copied directly from the original Transformer architecture. The embedded patches are passed through a Layer Normalization to reduce training time and stabilize the training phases. Then, we pass the information through a multi-head attention network added by a skip connection to improve the performance while reducing the risk of gradient explosion or vanishing. We then pass through another Layer Normalization, Multi-layer Perceptron, and skip connection for further processing. The use of positional embedding allows ViT to behave like CNN, and this is the only inductive bias in ViT. Compared with CNN, ViT enables the network to learn the global and abstract representations of the input image, making it more robust.\nJupyter Notebooks ▪ Single-Task Learning on CiFAR-10 Dataset: A Vision Transformer Approach. ▪ Single-Task Learning on CiFAR-10 Dataset - Super-Class Classfication: A Vision Transformer Approach. ▪ Single-Task Learning on CiFAR-100 Dataset: A Vision Transformer Approach. ▪ Single-Task Learning on CiFAR-100 Dataset - Super-Class Classfication: A Vision Transformer Approach. ▪ Multi-Task Learning on CiFAR-10 Dataset: A Vision Transformer Approach. ▪ Multi-Task Learning on CiFAR-100 Dataset: A Vision Transformer Approach. Deep Residual Network (ResNet-152) Deep residual network-152 layers, also known as ResNet-152, is a convolutional neural network architecture designed to address the vanishing gradient problem in building deep neural networks. It was introduced in the original paper \u0026ldquo;Deep residual learning for image recognition\u0026rdquo; by He, Kaiming, et al.\nFig. 5: Architecture of the ResNet (Image Source: He, Kaiming, et al.). The key innovation of ResNet-152 is the residual block, which allows the network to learn residual functions that map the input to the output, rather than trying to learn the entire mapping in one shot. The residual block consists of two convolutional layers with batch normalization and ReLU activation, and a skip connection that adds the input of the block to the output of the second convolutional layer. Due to its depth, ResNet-152 can capture more complex features and achieve better performance than its shallower counterparts, such as ResNet-18, ResNet-34, and ResNet50. It has been used in various computer vision tasks, such as object detection, image classification, and image segmentation.\nJupyter Notebooks ▪ Single-Task Learning on CiFAR-10 Dataset (10 Classes): A ResNet-152 Approach. ▪ Single-Task Learning on CiFAR-10 Dataset (2 Classes): A ResNet-152 Approach. ▪ Single-Task Learning on CiFAR-100 Dataset (100 Classes): A ResNet-152 Approach. ▪ Single-Task Learning on CiFAR-100 Dataset (20 Superclasses): A ResNet-152 Approach. ▪ Mullti-task Learning on CiFAR-10 Dataset: A ResNet-152 Approach. ▪ Mullti-task Learning on CiFAR-100 Dataset: A ResNet-152 Approach. Experimental Results The experiment result summary can be found here.\nFrom the experimental result, we can answer the three research questions:\nRQ1: Is an MTL ViT model superior in performance to an MTL Convolution-based model (ResNet-152)?\nMTL ViT outperformed MTL ResNet-152 on CiFAR-100, while MTL ResNet-152 outperformed MTL ViT on CiFAR-10 regarding testing accuracies. This result suggests that the MTL ViT is better suited for complex classification tasks, as CiFAR-100 is a more complex dataset than CiFAR-10. With more complex datasets or longer training epochs, I expect MTL ViT to outperform MTL ResNet-152 on both datasets.\nRQ2: Can an MTL ViT model achieve better results than two separate STL ViT models?\nMTL ViT outperformed two STL ViTs on CiFAR-10 and CiFAR-100 regarding testing accuracies. This result aligns with previous studies on benchmark datasets such as Taskonomy, Replica, and CocoDoom. The superior performance of MTL ViT is due to the sharing of the same backbone between the two tasks, which enables the network to learn more representations while significantly reducing the number of parameters.\nRQ3: Does an STL ViT model outperform an STL Convolution-based model (ResNet152) in terms of accuracy?\nFor this question, there is no clear answer. If we use a more complex dataset or train with more epochs, we might see that ViT outperforms ResNet152 in CiFAR-10 and CiFAR-100. ViT can capture global features due to its positional embedding and attention mechanism, while ResNet-152 can capture local features due to the convolutional operation.\nCitation Cited as:\nNguyen, Minh. (March 2023). Multi-Task Learning for Image Classification https://mnguyen0226.github.io/posts/multitask_learning/post/ Or\n@article{nguyen2023mtl, title = \u0026#34;Multi-Task Learning for Image Classification\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;March\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/multitask_learning/post/\u0026#34; } References [1] Y. Chen, J. Yu, Y. Zhao, J. Chen, and X. Du. Task’s choice: Pruning-based feature sharing (pbfs) for multi-task learning. Entropy, 24(3):432, 2022.\n[2] M. Cordts, M. Omran, S. Ramos, T. Rehfeld, M. Enzweiler, R. Benenson, U. Franke, S. Roth, and B. Schiele. The cityscapes dataset for semantic urban scene understanding. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 3213–3223, 2016.\n[3] M. Crawshaw. Multi-task learning with deep neural networks: A survey. arXiv preprint arXiv:2009.09796, 2020.\n[4] A. Dosovitskiy, L. Beyer, A. Kolesnikov, D. Weissenborn, X. Zhai, T. Unterthiner, M. Dehghani, M. Minderer, G. Heigold, S. Gelly, et al. An image is worth 16x16 words: Transformers for image recognition at scale. arXiv preprint arXiv:2010.11929, 2020.\n[5] Evannex. Andrej karpathy talks tesla autopilot amp; multitask learning, Aug 2019.\n[6] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 770–778, 2016.\n[7] A. Krizhevsky, V. Nair, and G. Hinton. Cifar-10 and cifar100 datasets. URl: https://www. cs. toronto. edu/kriz/cifar.html, 6(1):1, 2009.\n[8] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ramanan, P. Dollar, and C. L. Zitnick. Microsoft coco: Common objects in context. In Computer Vision–ECCV 2014: 13th European Conference, Zurich, Switzerland, September 6-12, 2014, Proceedings, Part V 13, pages 740–755.Springer, 2014.\n[9] A. Mahendran, H. Bilen, J. F. Henriques, and A. Vedaldi. Researchdoom and cocodoom: Learning computer vision with games. arXiv preprint arXiv:1610.02431, 2016.\n[10] I. Misra, A. Shrivastava, A. Gupta, and M. Hebert. Crossstitch networks for multi-task learning. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 3994–4003, 2016.\n[11] S. Ruder. An overview of multi-task learning in deep neural networks. arXiv preprint arXiv:1706.05098, 2017.\n[12] J. Straub, T. Whelan, L. Ma, Y. Chen, E. Wijmans, S. Green, J. J. Engel, R. Mur-Artal, C. Ren, S. Verma, et al. The replica dataset: A digital replica of indoor spaces. arXiv preprint arXiv:1906.05797, 2019.\n[13] A. R. Zamir, A. Sax, W. Shen, L. J. Guibas, J. Malik, and S. Savarese. Taskonomy: Disentangling task transfer learning. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 3712–3722, 2018.\n[14] X. Zheng, B. Wu, X. Zhu, and X. Zhu. Multi-task deep learning seismic impedance inversion optimization based on homoscedastic uncertainty. Applied Sciences, 12(3):1200, 2022.\nFig. 6: Sunset over Minneapolis, Minnesota, U.S.A (Image Source: Nicole Geri @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/multitask_learning/post/","summary":"[v.1.0] (03/20/2023): Post published!\nDuring a recent interview with a Data Science Lead at a digital agriculture tech company, I had the opportunity to delve into the machine learning team\u0026rsquo;s exciting project. The team was utilizing multi-task learning (MTL) to deploy models to farming hardware, which piqued my interest and prompted me to explore this approach combined with deep learning. In particular, I wanted to investigate the effectiveness of MTL on vision transformers (ViT) and deep residual networks (ResNet-152).","title":"Multi-Task Learning for Image Classification"},{"content":"👨‍💻 Experience Data Engineer Intern @ Homebase (Y-Combinator) ▪ Tech Stack: Python (Scrapy, Selenium, Pandas), PHP, Redis, Airflow, PostgreSQL, AWS. ▪ Date: 06/2023 - 9/2023. ▪ Location: Ho Chi Minh City, Vietnam (Remote). Responsibilities ▪ Developed a distributed web‑scraper with Python (Scrapy, Selenium, Pandas), Redis, and Airflow, reducing runtime by 75%. ▪ Automated ETL from WordPress to Strapi CMS with PHP, Pandas, RESTful APIs, PostgreSQL, and AWS S3, reducing operational time by 25%. ▪ Built a WordPress blog website using AWS EC2, boosting traffic organically from search engines. Graduate Research Assistant @ CS Department (Virginia Tech) ▪ Tech Stack: Python (Dash, Plotly), Docker, Kubernetes. \u0026nbsp; \u0026nbsp; ▪ Date: 04/2023 - Present. ▪ Location: Falls Church, Virginia. Responsibilities ▪ Designed and built an interactive website for statistics and ML algorithms visualization with Python (Dash, Plotly) and Docker. ▪ Deployed the website on Kubernetes cluster, ensuring scalability and reliability. Graduate Research Assistant @ Commonwealth Cyber Initiatives (Virginia Tech) ▪ Tech Stack: Python, Tensorflow, Matplotlib, Pandas, Seaborn. ▪ Date: 05/2022 - 08/2022. ▪ Location: Arlington, Virginia. Responsibilities ▪ Developed and fine‑tuned RNN, LSTM, and Transformer forecasting models with Python and Tensorflow, reducing operational costs by 30%. ▪ Enhanced time‑series data quality via data cleaning, feature engineering, exploratory data analysis (EDA) using Pandas and Plotly. ▪ Designed and implemented the visualization dashboard with Python and Dash for seamless integration of ML into existing SCADA system. ▪ Boosted prediction accuracy by 4% and doubled database records by implementing TimeGAN data synthesis model. Research Assistant @ Terrestrial Robotics Engineering \u0026 Controls Lab (Virginia Tech) ▪ Tech Stack: C#, C++, Unity. \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; ▪ Date: 09/2021 - 05/2022. ▪ Location: Blacksburg, Virginia. Responsibilities ▪ Improved transparency by applying ROS-Bridge data transfer pipeline between the low-level robotic controller and Unity. ▪ Created 3D interactive simulation environments in Unity with VR headsets and Haptix Gloves synchronization. ▪ Poster, Presentation. Machine Learning Intern @ Heron Systems (Shield AI Subsidiary) ▪ Tech Stack: Python, Javascript, PyTorch, Pandas, Plotly, SpaCy, Flask, MySQL. ▪ Date: 05/2021 - 08/2021. ▪ Location: Alexandria, Virginia. Responsibilities ▪ Developed and refined the classification model using Python and PyTorch, predicting battle outcomes for DARPA’s Game Breaker. ▪ Determined optimal pre‑deployment configurations for LSTM, GRU, and Transformer models by evaluating them using IMDb dataset. ▪ Built the dashboard with Python, Dash, and SQLAlchemy of the models, aiding in the securement of DARPA’s $1M second funding round. Research Assistant @ Geo Lab (William \u0026 Mary College) ▪ Tech Stack: Python, Tensorflow, Matplotlib. ▪ Date: 09/2020 - 05/2021. ▪ Location: Williamsburg, Virginia. Responsibilities ▪ Led a team to develop CNN models (ResNet, VGG, Inception‑V3) with Python and Tensorflow for satellite‑image‑based road quality classification. ▪ Enhanced benchmark dataset by 40% through efficient data collection and class balancing using image augmentation techniques. ▪ Mitigated 70% of data‑poisoning attacks on the model by implementing and fine‑tuning an Auto‑Encoder. ▪ Achieved 3rd place among eight competing universities. Research Assistant @ Hybrid Electric Vehicle Team (Virginia Tech) ▪ Tech Stack: C++, MATLAB. \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; ▪ Date: 09/2020 - 05/2021. ▪ Location: Blacksburg, Virginia. Responsibilities ▪ Applied Sensor Fusion algorithm to Chevrolet Blazer 2019 by integrating/testing Borsh radar and Mobileye6 camera sensors. ▪ Implemented and tested the algorithm's performance in simulation; earned full points in the EcoCar Competition's road driving tests. Teaching Assistant @ Integrate System Design (Virginia Tech) ▪ Tech Stack: C++, Circuit Design, Arduino, MIT Mobile App Inventor. ▪ Date: 05/2020 - 05/2021. ▪ Location: Blacksburg, Virginia. Responsibilities ▪ Conducted 3 two‑hour office sessions and graded labs for 50+ students 2 times per week. ▪ Proactively addressed student inquiries on micro‑controller applications and software development in C. Research Assistant @ Wireless Lab (Virginia Tech) ▪ Tech Stack: C++, Python. ▪ Date: 05/2020 - 08/2020. ▪ Location: Blacksburg, Virginia. Responsibilities ▪ Designed a controller with two stepper motors using Python, Arduino, and GRBL library for long-range signal receiving or signal sweeping tasks. The user can control the Antenna's movements through their preferred angles by entering the angles in the Python scripted interface. 🔧 Skills Frontend: JavaScript, TypeScript, HTML5, CSS, SCSS | React.js, Next.js, Vue.js. Backend: Python, Java, SQL, C++, C | Flask, Dash, Node.js, RESTful API | MySQL, SQLite, PostgreSQL. Data Science Tools: Tensorflow, PyTorch, Scikit-learn, NumPy, Matplotlib, Pandas, Seaborn, Plotly, BeautifulSoup, OpenCV. Others: Docker, Kubernetes, AWS, Git, Linux. 🎓 Education Master of Science in Computer Engineering ▪ Concentration: Software \u0026 Machine Intelligence. ▪ GPA: 3.75. ▪ Date: 08/2022 - Present. ▪ Location: Falls Church, Virginia. Bachelor of Science in Computer Engineering (Graduated) ▪ Concentration: Machine Learning, Computer Science Minor. ▪ GPA: 3.60. ▪ Date: 08/2018 - 05/2022. ▪ Location: Blacksburg, Virginia. Relevant Courses ▪ Deep Learning ▪ Web Application Development ▪ Software Engineering ▪ Data Visualization ▪ Advanced Machine Learning ▪ Trustworthy Machine Learning ▪ Data Analytics ▪ Computer Vision ▪ Digital Image Processing ▪ AI \u0026 Engineering Applications ▪ Real-time Systems ▪ Data Structure \u0026 Algorithms ▪ Principles Of Computer Architecture 📜 Publications \"DeepH20: Cyber attack detection in water distribution systems using deep learning.\" Nazmul Sikder, Minh T. Nguyen, Donald Elliot, Feras Batarseh. Elsevier's Journal of Water Process Engineering (Vol 52.) (04/2023). Link.\n\"AI for Cyberbiosecurity in Water Systems—A Survey.\" Daniel Sobien, Mehmet O. Yardimci, Minh T. Nguyen, Wan-Yi Mao, Vinita Fordham, Abdul Rahman, Susan Duncan, Feras Batarseh. Springer's Cyberbiosecurity Book (01/2023). Link.\n💻 Projects Machine Learning Algorithms Visualization ▪ Tech Stack: Python, Dash, Bootstrap, Docker, Kubernetes, HTML, CSS. \u0026nbsp; \u0026nbsp; ▪ Designed and built the user‑friendly website to aid CS students in effectively comprehending complex ML and statistics concepts. ▪ Dockerized and deployed the website on Virginia Tech’s Rancher (Kubernetes) cluster to improve scalability and reliability. ▪ Link. Web Bookstore ▪ Tech Stack: Java, Vue.js, MySQL, Figma, HTML, CSS. \u0026nbsp; \u0026nbsp; ▪ Developed the single‑page website with client/server‑side transaction validation, session handling, and user history tracking. ▪ Implemented the middleware and RESTful APIs with Java Servlet, Apache Tomcat and MySQL database. ▪ Employed the Data Access Object (DAO) design pattern and adhered to SOLID principles, ensuring the modular and maintainable system. ▪ Github. Web News ▪ Tech Stack: Python, Javascript, MySQL, Flask API, Werkzeug API, CKEditor API, Bootstrap, HTML, CSS. \u0026nbsp; \u0026nbsp; ▪ Transformed Y Combinator’s Hacker News into a user‑centric web app, leveraging RESTful APIs for efficient data interchange. ▪ Developed a multi‑page functionality including user registration, login, post management, commenting system, and voting mechanism. ▪ Github. Smart Home Simulation ▪ Tech Stack: C++, Circuit Design, Arduino, MIT Mobile App Inventor. \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; ▪ Designed, built, and tested hardware simulation with 8 automated sensors, controlled wirelessly via an Android mobile app. ▪ Appointed to class's teaching assistant by professor due to project's design, presentation, report, and assistance to classmates. ▪ Github. 🏅 Awards Best ML Poster @ FLAIRS-35 ▪ Best journal poster for ML applications in cyberbiosecurity, awarded by juries amongst 40+ submissions. ▪ Link. Turing Research Fellowship @ Commonwealth Cyber Initiatives ▪ Awarded AI Fellowship out of 21 universities in the Commonwealth of Virginia state. ▪ Link. Geo Research Fellowship @ Geo Lab ▪ One of 30 fellows (out of 150 applicants) for the US's largest geospatial data security lab. ▪ Link. 🙌 Volunteers President @ Teaching Robotics \u0026 Engineering Club (Virginia Tech) ▪ Taught C/C++, Arduino, and electric foundations and robotics projects for 15-25 club members. ▪ Supervised club Officers in making teaching materials and mentoring club members. Industry Relations Chair @ IEEE Student Branch (Virginia Tech) ▪ Tripled the number of participants by hosting peer networking events and info sessions to connect students to faculty-sponsored and company-sponsored opportunities in the ECE department. ▪ Collaborated with company representatives in IEEE@VT Summit, resume review sessions, and tech talks. ▪ Raised a $6,000 annual sponsorship from Collins Aerospace, Lockheed Martin, Boeing, and Texas Instruments. Student Mentor @ Center for Enhancement of Engineering Diversity (Virginia Tech) ▪ Served as a sounding board for various issues that confront first-year students during the first 10 weeks. ▪ Held weekly meetings to provide 10 mentees about how to smoothly transition into Virginia Tech culture. Officer @ IEEE Student Branch (Virginia Tech) ▪ Organized “Fun Friday’s” peer networking events and the IEEE Summit industry/leadership conference. Captain @ Math Team (St. Paul Preparatory School) ▪ Won Team Second Place in the 2017 Minnesota High School Mathematics League Tournament. ▪ Assisted the teacher with explaining difficult problems to members. ▪ Assigned math areas to different teammates based on skill sets to boost the team's total score. ","permalink":"https://mnguyen0226.github.io/about/","summary":"👨‍💻 Experience Data Engineer Intern @ Homebase (Y-Combinator) ▪ Tech Stack: Python (Scrapy, Selenium, Pandas), PHP, Redis, Airflow, PostgreSQL, AWS. ▪ Date: 06/2023 - 9/2023. ▪ Location: Ho Chi Minh City, Vietnam (Remote). Responsibilities ▪ Developed a distributed web‑scraper with Python (Scrapy, Selenium, Pandas), Redis, and Airflow, reducing runtime by 75%. ▪ Automated ETL from WordPress to Strapi CMS with PHP, Pandas, RESTful APIs, PostgreSQL, and AWS S3, reducing operational time by 25%.","title":"About Me"},{"content":"[v.1.0] (01/20/2023): Post started!\nComputer Memory \u0026amp; Storage Storage HDD (hard disk drive): it works by spinning magnetics disk. SSD (solid state drive): it uses NAND-based flash memory, providing fast data access, reduces power consumption, and increases durability. It is more expensive. USB Drive: is a small plug-and-play device for convenient data transfer between computers. SD Card is commonly found in camera and smartphone. There is SD Card, Mini Card, and Micro Card. Memory RAM (random access memory): is a type of memory that store data temperarily while the computer is running. It\u0026rsquo;s fast and flexible. However, all the data is lost after the power is off. SRAM (static random access memory): is a fast and expensive DRAM used in high speed application like CPU caches, where quick access time is crucial. DRAM (dynamic random access memory): is slower and cheaper than SRAM. It needs to be constantly refreshed to maintain data. SDRAM DDR SDRAM: with examples like DDR4, DDR5. GGDDR SDRAM: is a specialized of DRAM with faster data transfer rates for parallel processing. ROM (read only memory): is a type of memory that retains data, even when the memory is off. It is used to store essential information like firmware and BIOS. Firmware: is a type of software stored in ROM that determines how hardware devices communicate with each others BIOS (basic input-output systems): first run when you booth up the computer. It is responsible for starting your computer, initializes hardware components, and hands over controls to the OS. Domain Name System (DNS) It is the backbone of the internet.\nBut how does it work?\nDNS is a directory: it translates human-readable domain names (i.e, www.google.com) to machine-readable IP-addresses.\nThere are different DNS servers with different purposes. The DNS Resolver can be provided by Cloudflare (1.1.1.1) or Google (8.8.8.8).\nHow does the DNS Resolver find the authoritative nameservers?\nThere are 3 levels of DNS:\nRoot Nameservers: stores the IP-addresses of the TLD nameservers. There are 13 logical Root Nameservers. Ex: .com, .org, .edu Top Level Domain (TLD) Nameservers: stores the IP-addresses of the Authoritative Nameservers. Ex: google.com, wikipedia.org, mit.edu. Authoritative Nameservers: stores authoritative answers to queries Such design above make DNS decentralized and robust.\nHow does the workflow look like?\nFig. 1: DNS workflow (Image source: ByteByteGo.com). The user types \u0026ldquo;google.com\u0026rdquo; to browser. The browser first checks its cache, if there is no answer, it makes the OS call to get the answer. The OS then reachs out to DNS Resolver. The DNS Resolver first checks its cache, if it is not there or if the answer is expired, it will ask the Root Nameservers. The Rootname Servers responses with the root name TLD Nameservers. Here, if the RootName Servers found the root name TLD Nameservers (i.e. .com as it is common) in its cache, it will return. The DNS Resolver then reachout to the TLD Nameservers, which return the Authoritative Nameservers for \u0026ldquo;google.com\u0026rdquo;. The DNS Resolver then reachout to the Authoritative Nameservers and get the IP-address of \u0026ldquo;google.com\u0026rdquo;. The DNS Resolver then returns the address of the IP system to the OS, and the OS returns it to the browswer. Common Latency Numbers Fig. 2: Latency number hierachy (Image source: ByteByteGo.com). 1 ns: Accessing CPU registers, CPU clock cycle. 1-10 ns: L1/L2 cache, Branch mispredict. 10-100 ns: L3 cache. 100-1000 ns: System call, MD5 hash. 1-10 µs: Context switches between threads. 10-100 µs: Higher level operations such as process a http request, sequential read, read a 8K page. 100-1000 µs: SSD write latency, intra-zone networking round trip, memcache/redis get operation. 1-10 ms: Intra-zone network latency, seek time of HDD. 10-100 ms: Network round-trip from US West-East. 100-1000 ms: Bcrypt a password, TLS handshake, reading sequentially 1GB of SSD. 1 s: Tranfer 1GB over the network within the same cloud region. Citation Cited as:\nSystem Design Fundamentals Note https://mnguyen0226.github.io/posts/system_design_concepts/post/ Or\n@article{nguyen2023sdfund, title = \u0026#34;System Design Fundamentals Note\u0026#34;, author = \u0026#34;Nguyen, Minh\u0026#34;, journal = \u0026#34;mnguyen0226.github.io\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;January\u0026#34;, url = \u0026#34;https://mnguyen0226.github.io/posts/system_design_concepts/post/\u0026#34; } References [1] A. Xu, System Design Interview - An Insider’s Guide. Independently Published, 2020. ‌\n[2] ByteByteGo, “10+ Key Memory \u0026amp; Storage Systems: Crash Course System Design #5,” YouTube. Mar. 28, 2023. Accessed: Oct. 25, 2023. [YouTube Video]. Available: https://www.youtube.com/watch?v=lX4CrbXMsNQ\u0026amp;list=PLCRMIe5FDPsd0gVs500xeOewfySTsmEjf ‌\nFig. 2: Golden Gate Bridge, San Francisco, U.S.A (Image Source: Maarten van den Heuvel @ Unsplash). ","permalink":"https://mnguyen0226.github.io/posts/system_design_concepts/post/","summary":"[v.1.0] (01/20/2023): Post started!\nComputer Memory \u0026amp; Storage Storage HDD (hard disk drive): it works by spinning magnetics disk. SSD (solid state drive): it uses NAND-based flash memory, providing fast data access, reduces power consumption, and increases durability. It is more expensive. USB Drive: is a small plug-and-play device for convenient data transfer between computers. SD Card is commonly found in camera and smartphone. There is SD Card, Mini Card, and Micro Card.","title":"System Design Fundamentals Note"}]